"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["mocks_browser_ts"],{

/***/ "../../../node_modules/.pnpm/@mswjs+interceptors@0.37.1/node_modules/@mswjs/interceptors/lib/browser/chunk-PFGO5BSM.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@mswjs+interceptors@0.37.1/node_modules/@mswjs/interceptors/lib/browser/chunk-PFGO5BSM.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value: true}));// src/utils/hasConfigurableGlobal.ts\nfunction hasConfigurableGlobal(propertyName) {\n  const descriptor = Object.getOwnPropertyDescriptor(globalThis, propertyName);\n  if (typeof descriptor === \"undefined\") {\n    return false;\n  }\n  if (typeof descriptor.get === \"function\" && typeof descriptor.get() === \"undefined\") {\n    return false;\n  }\n  if (typeof descriptor.get === \"undefined\" && descriptor.value == null) {\n    return false;\n  }\n  if (typeof descriptor.set === \"undefined\" && !descriptor.configurable) {\n    console.error(\n      `[MSW] Failed to apply interceptor: the global \\`${propertyName}\\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`\n    );\n    return false;\n  }\n  return true;\n}\n\n\n\nexports.hasConfigurableGlobal = hasConfigurableGlobal;\n//# sourceMappingURL=chunk-PFGO5BSM.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Btc3dqcytpbnRlcmNlcHRvcnNAMC4zNy4xL25vZGVfbW9kdWxlcy9AbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9icm93c2VyL2NodW5rLVBGR081QlNNLmpzIiwibWFwcGluZ3MiOiJBQUFhLDhDQUE2QyxDQUFDLFlBQVksRUFBQyxDQUFDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGFBQWE7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsiL1VzZXJzL2h5ZW9uam9uZy9Eb2N1bWVudHMvR2l0SHViL21zdy1zY2VuYXJpb3Mvbm9kZV9tb2R1bGVzLy5wbnBtL0Btc3dqcytpbnRlcmNlcHRvcnNAMC4zNy4xL25vZGVfbW9kdWxlcy9AbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9icm93c2VyL2NodW5rLVBGR081QlNNLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7Ly8gc3JjL3V0aWxzL2hhc0NvbmZpZ3VyYWJsZUdsb2JhbC50c1xuZnVuY3Rpb24gaGFzQ29uZmlndXJhYmxlR2xvYmFsKHByb3BlcnR5TmFtZSkge1xuICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWxUaGlzLCBwcm9wZXJ0eU5hbWUpO1xuICBpZiAodHlwZW9mIGRlc2NyaXB0b3IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmdldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZXNjcmlwdG9yLmdldCgpID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09IFwidW5kZWZpbmVkXCIgJiYgZGVzY3JpcHRvci52YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZGVzY3JpcHRvci5zZXQgPT09IFwidW5kZWZpbmVkXCIgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBbTVNXXSBGYWlsZWQgdG8gYXBwbHkgaW50ZXJjZXB0b3I6IHRoZSBnbG9iYWwgXFxgJHtwcm9wZXJ0eU5hbWV9XFxgIHByb3BlcnR5IGlzIG5vbi1jb25maWd1cmFibGUuIFRoaXMgaXMgbGlrZWx5IGFuIGlzc3VlIHdpdGggeW91ciBlbnZpcm9ubWVudC4gSWYgeW91IGFyZSB1c2luZyBhIGZyYW1ld29yaywgcGxlYXNlIG9wZW4gYW4gaXNzdWUgYWJvdXQgdGhpcyBpbiB0aGVpciByZXBvc2l0b3J5LmBcbiAgICApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5cbmV4cG9ydHMuaGFzQ29uZmlndXJhYmxlR2xvYmFsID0gaGFzQ29uZmlndXJhYmxlR2xvYmFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstUEZHTzVCU00uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/@mswjs+interceptors@0.37.1/node_modules/@mswjs/interceptors/lib/browser/chunk-PFGO5BSM.js\n"));

/***/ }),

/***/ "../../../node_modules/.pnpm/@mswjs+interceptors@0.37.1/node_modules/@mswjs/interceptors/lib/browser/interceptors/WebSocket/index.js":
/*!*******************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@mswjs+interceptors@0.37.1/node_modules/@mswjs/interceptors/lib/browser/interceptors/WebSocket/index.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value: true}));\n\nvar _chunkPFGO5BSMjs = __webpack_require__(/*! ../../chunk-PFGO5BSM.js */ \"../../../node_modules/.pnpm/@mswjs+interceptors@0.37.1/node_modules/@mswjs/interceptors/lib/browser/chunk-PFGO5BSM.js\");\n\n\n\nvar _chunkTIPR373Rjs = __webpack_require__(/*! ../../chunk-TIPR373R.js */ \"../../../node_modules/.pnpm/@mswjs+interceptors@0.37.1/node_modules/@mswjs/interceptors/lib/browser/chunk-TIPR373R.js\");\n\n// src/interceptors/WebSocket/utils/bindEvent.ts\nfunction bindEvent(target, event) {\n  Object.defineProperties(event, {\n    target: {\n      value: target,\n      enumerable: true,\n      writable: true\n    },\n    currentTarget: {\n      value: target,\n      enumerable: true,\n      writable: true\n    }\n  });\n  return event;\n}\n\n// src/interceptors/WebSocket/utils/events.ts\nvar kCancelable = Symbol(\"kCancelable\");\nvar kDefaultPrevented = Symbol(\"kDefaultPrevented\");\nvar CancelableMessageEvent = class extends MessageEvent {\n  constructor(type, init) {\n    super(type, init);\n    this[kCancelable] = !!init.cancelable;\n    this[kDefaultPrevented] = false;\n  }\n  get cancelable() {\n    return this[kCancelable];\n  }\n  set cancelable(nextCancelable) {\n    this[kCancelable] = nextCancelable;\n  }\n  get defaultPrevented() {\n    return this[kDefaultPrevented];\n  }\n  set defaultPrevented(nextDefaultPrevented) {\n    this[kDefaultPrevented] = nextDefaultPrevented;\n  }\n  preventDefault() {\n    if (this.cancelable && !this[kDefaultPrevented]) {\n      this[kDefaultPrevented] = true;\n    }\n  }\n};\nkCancelable, kDefaultPrevented;\nvar CloseEvent = class extends Event {\n  constructor(type, init = {}) {\n    super(type, init);\n    this.code = init.code === void 0 ? 0 : init.code;\n    this.reason = init.reason === void 0 ? \"\" : init.reason;\n    this.wasClean = init.wasClean === void 0 ? false : init.wasClean;\n  }\n};\nvar CancelableCloseEvent = class extends CloseEvent {\n  constructor(type, init = {}) {\n    super(type, init);\n    this[kCancelable] = !!init.cancelable;\n    this[kDefaultPrevented] = false;\n  }\n  get cancelable() {\n    return this[kCancelable];\n  }\n  set cancelable(nextCancelable) {\n    this[kCancelable] = nextCancelable;\n  }\n  get defaultPrevented() {\n    return this[kDefaultPrevented];\n  }\n  set defaultPrevented(nextDefaultPrevented) {\n    this[kDefaultPrevented] = nextDefaultPrevented;\n  }\n  preventDefault() {\n    if (this.cancelable && !this[kDefaultPrevented]) {\n      this[kDefaultPrevented] = true;\n    }\n  }\n};\nkCancelable, kDefaultPrevented;\n\n// src/interceptors/WebSocket/WebSocketClientConnection.ts\nvar kEmitter = Symbol(\"kEmitter\");\nvar kBoundListener = Symbol(\"kBoundListener\");\nvar WebSocketClientConnection = class {\n  constructor(socket, transport) {\n    this.socket = socket;\n    this.transport = transport;\n    this.id = _chunkTIPR373Rjs.createRequestId.call(void 0, );\n    this.url = new URL(socket.url);\n    this[kEmitter] = new EventTarget();\n    this.transport.addEventListener(\"outgoing\", (event) => {\n      const message = bindEvent(\n        this.socket,\n        new CancelableMessageEvent(\"message\", {\n          data: event.data,\n          origin: event.origin,\n          cancelable: true\n        })\n      );\n      this[kEmitter].dispatchEvent(message);\n      if (message.defaultPrevented) {\n        event.preventDefault();\n      }\n    });\n    this.transport.addEventListener(\"close\", (event) => {\n      this[kEmitter].dispatchEvent(\n        bindEvent(this.socket, new CloseEvent(\"close\", event))\n      );\n    });\n  }\n  /**\n   * Listen for the outgoing events from the connected WebSocket client.\n   */\n  addEventListener(type, listener, options) {\n    if (!Reflect.has(listener, kBoundListener)) {\n      const boundListener = listener.bind(this.socket);\n      Object.defineProperty(listener, kBoundListener, {\n        value: boundListener,\n        enumerable: false,\n        configurable: false\n      });\n    }\n    this[kEmitter].addEventListener(\n      type,\n      Reflect.get(listener, kBoundListener),\n      options\n    );\n  }\n  /**\n   * Removes the listener for the given event.\n   */\n  removeEventListener(event, listener, options) {\n    this[kEmitter].removeEventListener(\n      event,\n      Reflect.get(listener, kBoundListener),\n      options\n    );\n  }\n  /**\n   * Send data to the connected client.\n   */\n  send(data) {\n    this.transport.send(data);\n  }\n  /**\n   * Close the WebSocket connection.\n   * @param {number} code A status code (see https://www.rfc-editor.org/rfc/rfc6455#section-7.4.1).\n   * @param {string} reason A custom connection close reason.\n   */\n  close(code, reason) {\n    this.transport.close(code, reason);\n  }\n};\nkEmitter;\n\n// src/interceptors/WebSocket/WebSocketServerConnection.ts\nvar _outvariant = __webpack_require__(/*! outvariant */ \"../../../node_modules/.pnpm/outvariant@1.4.3/node_modules/outvariant/lib/index.js\");\n\n// src/interceptors/WebSocket/WebSocketOverride.ts\n\nvar _deferredpromise = __webpack_require__(/*! @open-draft/deferred-promise */ \"../../../node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/build/index.js\");\nvar WEBSOCKET_CLOSE_CODE_RANGE_ERROR = \"InvalidAccessError: close code out of user configurable range\";\nvar kPassthroughPromise = Symbol(\"kPassthroughPromise\");\nvar kOnSend = Symbol(\"kOnSend\");\nvar kClose = Symbol(\"kClose\");\nvar WebSocketOverride = class extends EventTarget {\n  constructor(url, protocols) {\n    super();\n    this.CONNECTING = 0;\n    this.OPEN = 1;\n    this.CLOSING = 2;\n    this.CLOSED = 3;\n    this._onopen = null;\n    this._onmessage = null;\n    this._onerror = null;\n    this._onclose = null;\n    this.url = url.toString();\n    this.protocol = \"\";\n    this.extensions = \"\";\n    this.binaryType = \"blob\";\n    this.readyState = this.CONNECTING;\n    this.bufferedAmount = 0;\n    this[kPassthroughPromise] = new (0, _deferredpromise.DeferredPromise)();\n    queueMicrotask(async () => {\n      if (await this[kPassthroughPromise]) {\n        return;\n      }\n      this.protocol = typeof protocols === \"string\" ? protocols : Array.isArray(protocols) && protocols.length > 0 ? protocols[0] : \"\";\n      if (this.readyState === this.CONNECTING) {\n        this.readyState = this.OPEN;\n        this.dispatchEvent(bindEvent(this, new Event(\"open\")));\n      }\n    });\n  }\n  set onopen(listener) {\n    this.removeEventListener(\"open\", this._onopen);\n    this._onopen = listener;\n    if (listener !== null) {\n      this.addEventListener(\"open\", listener);\n    }\n  }\n  get onopen() {\n    return this._onopen;\n  }\n  set onmessage(listener) {\n    this.removeEventListener(\n      \"message\",\n      this._onmessage\n    );\n    this._onmessage = listener;\n    if (listener !== null) {\n      this.addEventListener(\"message\", listener);\n    }\n  }\n  get onmessage() {\n    return this._onmessage;\n  }\n  set onerror(listener) {\n    this.removeEventListener(\"error\", this._onerror);\n    this._onerror = listener;\n    if (listener !== null) {\n      this.addEventListener(\"error\", listener);\n    }\n  }\n  get onerror() {\n    return this._onerror;\n  }\n  set onclose(listener) {\n    this.removeEventListener(\"close\", this._onclose);\n    this._onclose = listener;\n    if (listener !== null) {\n      this.addEventListener(\"close\", listener);\n    }\n  }\n  get onclose() {\n    return this._onclose;\n  }\n  /**\n   * @see https://websockets.spec.whatwg.org/#ref-for-dom-websocket-send%E2%91%A0\n   */\n  send(data) {\n    if (this.readyState === this.CONNECTING) {\n      this.close();\n      throw new DOMException(\"InvalidStateError\");\n    }\n    if (this.readyState === this.CLOSING || this.readyState === this.CLOSED) {\n      return;\n    }\n    this.bufferedAmount += getDataSize(data);\n    queueMicrotask(() => {\n      var _a;\n      this.bufferedAmount = 0;\n      (_a = this[kOnSend]) == null ? void 0 : _a.call(this, data);\n    });\n  }\n  close(code = 1e3, reason) {\n    _outvariant.invariant.call(void 0, code, WEBSOCKET_CLOSE_CODE_RANGE_ERROR);\n    _outvariant.invariant.call(void 0, \n      code === 1e3 || code >= 3e3 && code <= 4999,\n      WEBSOCKET_CLOSE_CODE_RANGE_ERROR\n    );\n    this[kClose](code, reason);\n  }\n  [(kPassthroughPromise, kOnSend, kClose)](code = 1e3, reason, wasClean = true) {\n    if (this.readyState === this.CLOSING || this.readyState === this.CLOSED) {\n      return;\n    }\n    this.readyState = this.CLOSING;\n    queueMicrotask(() => {\n      this.readyState = this.CLOSED;\n      this.dispatchEvent(\n        bindEvent(\n          this,\n          new CloseEvent(\"close\", {\n            code,\n            reason,\n            wasClean\n          })\n        )\n      );\n      this._onopen = null;\n      this._onmessage = null;\n      this._onerror = null;\n      this._onclose = null;\n    });\n  }\n  addEventListener(type, listener, options) {\n    return super.addEventListener(\n      type,\n      listener,\n      options\n    );\n  }\n  removeEventListener(type, callback, options) {\n    return super.removeEventListener(type, callback, options);\n  }\n};\nWebSocketOverride.CONNECTING = 0;\nWebSocketOverride.OPEN = 1;\nWebSocketOverride.CLOSING = 2;\nWebSocketOverride.CLOSED = 3;\nfunction getDataSize(data) {\n  if (typeof data === \"string\") {\n    return data.length;\n  }\n  if (data instanceof Blob) {\n    return data.size;\n  }\n  return data.byteLength;\n}\n\n// src/interceptors/WebSocket/WebSocketServerConnection.ts\nvar kEmitter2 = Symbol(\"kEmitter\");\nvar kBoundListener2 = Symbol(\"kBoundListener\");\nvar kSend = Symbol(\"kSend\");\nvar WebSocketServerConnection = class {\n  constructor(client, transport, createConnection) {\n    this.client = client;\n    this.transport = transport;\n    this.createConnection = createConnection;\n    this[kEmitter2] = new EventTarget();\n    this.mockCloseController = new AbortController();\n    this.realCloseController = new AbortController();\n    this.transport.addEventListener(\"outgoing\", (event) => {\n      if (typeof this.realWebSocket === \"undefined\") {\n        return;\n      }\n      queueMicrotask(() => {\n        if (!event.defaultPrevented) {\n          this[kSend](event.data);\n        }\n      });\n    });\n    this.transport.addEventListener(\n      \"incoming\",\n      this.handleIncomingMessage.bind(this)\n    );\n  }\n  /**\n   * The `WebSocket` instance connected to the original server.\n   * Accessing this before calling `server.connect()` will throw.\n   */\n  get socket() {\n    _outvariant.invariant.call(void 0, \n      this.realWebSocket,\n      'Cannot access \"socket\" on the original WebSocket server object: the connection is not open. Did you forget to call `server.connect()`?'\n    );\n    return this.realWebSocket;\n  }\n  /**\n   * Open connection to the original WebSocket server.\n   */\n  connect() {\n    _outvariant.invariant.call(void 0, \n      !this.realWebSocket || this.realWebSocket.readyState !== WebSocket.OPEN,\n      'Failed to call \"connect()\" on the original WebSocket instance: the connection already open'\n    );\n    const realWebSocket = this.createConnection();\n    realWebSocket.binaryType = this.client.binaryType;\n    realWebSocket.addEventListener(\n      \"open\",\n      (event) => {\n        this[kEmitter2].dispatchEvent(\n          bindEvent(this.realWebSocket, new Event(\"open\", event))\n        );\n      },\n      { once: true }\n    );\n    realWebSocket.addEventListener(\"message\", (event) => {\n      this.transport.dispatchEvent(\n        bindEvent(\n          this.realWebSocket,\n          new MessageEvent(\"incoming\", {\n            data: event.data,\n            origin: event.origin\n          })\n        )\n      );\n    });\n    this.client.addEventListener(\n      \"close\",\n      (event) => {\n        this.handleMockClose(event);\n      },\n      {\n        signal: this.mockCloseController.signal\n      }\n    );\n    realWebSocket.addEventListener(\n      \"close\",\n      (event) => {\n        this.handleRealClose(event);\n      },\n      {\n        signal: this.realCloseController.signal\n      }\n    );\n    realWebSocket.addEventListener(\"error\", () => {\n      const errorEvent = bindEvent(\n        realWebSocket,\n        new Event(\"error\", { cancelable: true })\n      );\n      this[kEmitter2].dispatchEvent(errorEvent);\n      if (!errorEvent.defaultPrevented) {\n        this.client.dispatchEvent(bindEvent(this.client, new Event(\"error\")));\n      }\n    });\n    this.realWebSocket = realWebSocket;\n  }\n  /**\n   * Listen for the incoming events from the original WebSocket server.\n   */\n  addEventListener(event, listener, options) {\n    if (!Reflect.has(listener, kBoundListener2)) {\n      const boundListener = listener.bind(this.client);\n      Object.defineProperty(listener, kBoundListener2, {\n        value: boundListener,\n        enumerable: false\n      });\n    }\n    this[kEmitter2].addEventListener(\n      event,\n      Reflect.get(listener, kBoundListener2),\n      options\n    );\n  }\n  /**\n   * Remove the listener for the given event.\n   */\n  removeEventListener(event, listener, options) {\n    this[kEmitter2].removeEventListener(\n      event,\n      Reflect.get(listener, kBoundListener2),\n      options\n    );\n  }\n  /**\n   * Send data to the original WebSocket server.\n   * @example\n   * server.send('hello')\n   * server.send(new Blob(['hello']))\n   * server.send(new TextEncoder().encode('hello'))\n   */\n  send(data) {\n    this[kSend](data);\n  }\n  [(kEmitter2, kSend)](data) {\n    const { realWebSocket } = this;\n    _outvariant.invariant.call(void 0, \n      realWebSocket,\n      'Failed to call \"server.send()\" for \"%s\": the connection is not open. Did you forget to call \"server.connect()\"?',\n      this.client.url\n    );\n    if (realWebSocket.readyState === WebSocket.CLOSING || realWebSocket.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    if (realWebSocket.readyState === WebSocket.CONNECTING) {\n      realWebSocket.addEventListener(\n        \"open\",\n        () => {\n          realWebSocket.send(data);\n        },\n        { once: true }\n      );\n      return;\n    }\n    realWebSocket.send(data);\n  }\n  /**\n   * Close the actual server connection.\n   */\n  close() {\n    const { realWebSocket } = this;\n    _outvariant.invariant.call(void 0, \n      realWebSocket,\n      'Failed to close server connection for \"%s\": the connection is not open. Did you forget to call \"server.connect()\"?',\n      this.client.url\n    );\n    this.realCloseController.abort();\n    if (realWebSocket.readyState === WebSocket.CLOSING || realWebSocket.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    realWebSocket.close();\n    queueMicrotask(() => {\n      this[kEmitter2].dispatchEvent(\n        bindEvent(\n          this.realWebSocket,\n          new CancelableCloseEvent(\"close\", {\n            /**\n             * @note `server.close()` in the interceptor\n             * always results in clean closures.\n             */\n            code: 1e3,\n            cancelable: true\n          })\n        )\n      );\n    });\n  }\n  handleIncomingMessage(event) {\n    const messageEvent = bindEvent(\n      event.target,\n      new CancelableMessageEvent(\"message\", {\n        data: event.data,\n        origin: event.origin,\n        cancelable: true\n      })\n    );\n    this[kEmitter2].dispatchEvent(messageEvent);\n    if (!messageEvent.defaultPrevented) {\n      this.client.dispatchEvent(\n        bindEvent(\n          /**\n           * @note Bind the forwarded original server events\n           * to the mock WebSocket instance so it would\n           * dispatch them straight away.\n           */\n          this.client,\n          // Clone the message event again to prevent\n          // the \"already being dispatched\" exception.\n          new MessageEvent(\"message\", {\n            data: event.data,\n            origin: event.origin\n          })\n        )\n      );\n    }\n  }\n  handleMockClose(_event) {\n    if (this.realWebSocket) {\n      this.realWebSocket.close();\n    }\n  }\n  handleRealClose(event) {\n    this.mockCloseController.abort();\n    const closeEvent = bindEvent(\n      this.realWebSocket,\n      new CancelableCloseEvent(\"close\", {\n        code: event.code,\n        reason: event.reason,\n        wasClean: event.wasClean,\n        cancelable: true\n      })\n    );\n    this[kEmitter2].dispatchEvent(closeEvent);\n    if (!closeEvent.defaultPrevented) {\n      this.client[kClose](event.code, event.reason);\n    }\n  }\n};\n\n// src/interceptors/WebSocket/WebSocketClassTransport.ts\nvar WebSocketClassTransport = class extends EventTarget {\n  constructor(socket) {\n    super();\n    this.socket = socket;\n    this.socket.addEventListener(\"close\", (event) => {\n      this.dispatchEvent(bindEvent(this.socket, new CloseEvent(\"close\", event)));\n    });\n    this.socket[kOnSend] = (data) => {\n      this.dispatchEvent(\n        bindEvent(\n          this.socket,\n          // Dispatch this as cancelable because \"client\" connection\n          // re-creates this message event (cannot dispatch the same event).\n          new CancelableMessageEvent(\"outgoing\", {\n            data,\n            origin: this.socket.url,\n            cancelable: true\n          })\n        )\n      );\n    };\n  }\n  addEventListener(type, callback, options) {\n    return super.addEventListener(type, callback, options);\n  }\n  dispatchEvent(event) {\n    return super.dispatchEvent(event);\n  }\n  send(data) {\n    queueMicrotask(() => {\n      if (this.socket.readyState === this.socket.CLOSING || this.socket.readyState === this.socket.CLOSED) {\n        return;\n      }\n      const dispatchEvent = () => {\n        this.socket.dispatchEvent(\n          bindEvent(\n            /**\n             * @note Setting this event's \"target\" to the\n             * WebSocket override instance is important.\n             * This way it can tell apart original incoming events\n             * (must be forwarded to the transport) from the\n             * mocked message events like the one below\n             * (must be dispatched on the client instance).\n             */\n            this.socket,\n            new MessageEvent(\"message\", {\n              data,\n              origin: this.socket.url\n            })\n          )\n        );\n      };\n      if (this.socket.readyState === this.socket.CONNECTING) {\n        this.socket.addEventListener(\n          \"open\",\n          () => {\n            dispatchEvent();\n          },\n          { once: true }\n        );\n      } else {\n        dispatchEvent();\n      }\n    });\n  }\n  close(code, reason) {\n    this.socket[kClose](code, reason);\n  }\n};\n\n// src/interceptors/WebSocket/index.ts\nvar _WebSocketInterceptor = class extends _chunkTIPR373Rjs.Interceptor {\n  constructor() {\n    super(_WebSocketInterceptor.symbol);\n  }\n  checkEnvironment() {\n    return _chunkPFGO5BSMjs.hasConfigurableGlobal.call(void 0, \"WebSocket\");\n  }\n  setup() {\n    const originalWebSocketDescriptor = Object.getOwnPropertyDescriptor(\n      globalThis,\n      \"WebSocket\"\n    );\n    const WebSocketProxy = new Proxy(globalThis.WebSocket, {\n      construct: (target, args, newTarget) => {\n        const [url, protocols] = args;\n        const createConnection = () => {\n          return Reflect.construct(target, args, newTarget);\n        };\n        const socket = new WebSocketOverride(url, protocols);\n        const transport = new WebSocketClassTransport(socket);\n        queueMicrotask(() => {\n          try {\n            const server = new WebSocketServerConnection(\n              socket,\n              transport,\n              createConnection\n            );\n            const hasConnectionListeners = this.emitter.emit(\"connection\", {\n              client: new WebSocketClientConnection(socket, transport),\n              server,\n              info: {\n                protocols\n              }\n            });\n            if (hasConnectionListeners) {\n              socket[kPassthroughPromise].resolve(false);\n            } else {\n              socket[kPassthroughPromise].resolve(true);\n              server.connect();\n              server.addEventListener(\"open\", () => {\n                socket.dispatchEvent(bindEvent(socket, new Event(\"open\")));\n                if (server[\"realWebSocket\"]) {\n                  socket.protocol = server[\"realWebSocket\"].protocol;\n                }\n              });\n            }\n          } catch (error) {\n            if (error instanceof Error) {\n              socket.dispatchEvent(new Event(\"error\"));\n              if (socket.readyState !== WebSocket.CLOSING && socket.readyState !== WebSocket.CLOSED) {\n                socket[kClose](1011, error.message, false);\n              }\n              console.error(error);\n            }\n          }\n        });\n        return socket;\n      }\n    });\n    Object.defineProperty(globalThis, \"WebSocket\", {\n      value: WebSocketProxy,\n      configurable: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(\n        globalThis,\n        \"WebSocket\",\n        originalWebSocketDescriptor\n      );\n    });\n  }\n};\nvar WebSocketInterceptor = _WebSocketInterceptor;\nWebSocketInterceptor.symbol = Symbol(\"websocket\");\n\n\n\n\nexports.WebSocketClientConnection = WebSocketClientConnection; exports.WebSocketInterceptor = WebSocketInterceptor; exports.WebSocketServerConnection = WebSocketServerConnection;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Btc3dqcytpbnRlcmNlcHRvcnNAMC4zNy4xL25vZGVfbW9kdWxlcy9AbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9icm93c2VyL2ludGVyY2VwdG9ycy9XZWJTb2NrZXQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWEsOENBQTZDLENBQUMsWUFBWSxFQUFDOztBQUV4RSx1QkFBdUIsbUJBQU8sQ0FBQyxzSkFBeUI7Ozs7QUFJeEQsdUJBQXVCLG1CQUFPLENBQUMsc0pBQXlCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBWTs7QUFFdEM7O0FBRUEsdUJBQXVCLG1CQUFPLENBQUMsNkpBQThCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQSxpQ0FBaUMsOEJBQThCLDRCQUE0Qix5QkFBeUIsaUNBQWlDO0FBQ3JKIiwic291cmNlcyI6WyIvVXNlcnMvaHllb25qb25nL0RvY3VtZW50cy9HaXRIdWIvbXN3LXNjZW5hcmlvcy9ub2RlX21vZHVsZXMvLnBucG0vQG1zd2pzK2ludGVyY2VwdG9yc0AwLjM3LjEvbm9kZV9tb2R1bGVzL0Btc3dqcy9pbnRlcmNlcHRvcnMvbGliL2Jyb3dzZXIvaW50ZXJjZXB0b3JzL1dlYlNvY2tldC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuXG52YXIgX2NodW5rUEZHTzVCU01qcyA9IHJlcXVpcmUoJy4uLy4uL2NodW5rLVBGR081QlNNLmpzJyk7XG5cblxuXG52YXIgX2NodW5rVElQUjM3M1JqcyA9IHJlcXVpcmUoJy4uLy4uL2NodW5rLVRJUFIzNzNSLmpzJyk7XG5cbi8vIHNyYy9pbnRlcmNlcHRvcnMvV2ViU29ja2V0L3V0aWxzL2JpbmRFdmVudC50c1xuZnVuY3Rpb24gYmluZEV2ZW50KHRhcmdldCwgZXZlbnQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZXZlbnQsIHtcbiAgICB0YXJnZXQ6IHtcbiAgICAgIHZhbHVlOiB0YXJnZXQsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuICAgIGN1cnJlbnRUYXJnZXQ6IHtcbiAgICAgIHZhbHVlOiB0YXJnZXQsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8vIHNyYy9pbnRlcmNlcHRvcnMvV2ViU29ja2V0L3V0aWxzL2V2ZW50cy50c1xudmFyIGtDYW5jZWxhYmxlID0gU3ltYm9sKFwia0NhbmNlbGFibGVcIik7XG52YXIga0RlZmF1bHRQcmV2ZW50ZWQgPSBTeW1ib2woXCJrRGVmYXVsdFByZXZlbnRlZFwiKTtcbnZhciBDYW5jZWxhYmxlTWVzc2FnZUV2ZW50ID0gY2xhc3MgZXh0ZW5kcyBNZXNzYWdlRXZlbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBpbml0KSB7XG4gICAgc3VwZXIodHlwZSwgaW5pdCk7XG4gICAgdGhpc1trQ2FuY2VsYWJsZV0gPSAhIWluaXQuY2FuY2VsYWJsZTtcbiAgICB0aGlzW2tEZWZhdWx0UHJldmVudGVkXSA9IGZhbHNlO1xuICB9XG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzW2tDYW5jZWxhYmxlXTtcbiAgfVxuICBzZXQgY2FuY2VsYWJsZShuZXh0Q2FuY2VsYWJsZSkge1xuICAgIHRoaXNba0NhbmNlbGFibGVdID0gbmV4dENhbmNlbGFibGU7XG4gIH1cbiAgZ2V0IGRlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXNba0RlZmF1bHRQcmV2ZW50ZWRdO1xuICB9XG4gIHNldCBkZWZhdWx0UHJldmVudGVkKG5leHREZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpc1trRGVmYXVsdFByZXZlbnRlZF0gPSBuZXh0RGVmYXVsdFByZXZlbnRlZDtcbiAgfVxuICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlICYmICF0aGlzW2tEZWZhdWx0UHJldmVudGVkXSkge1xuICAgICAgdGhpc1trRGVmYXVsdFByZXZlbnRlZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcbmtDYW5jZWxhYmxlLCBrRGVmYXVsdFByZXZlbnRlZDtcbnZhciBDbG9zZUV2ZW50ID0gY2xhc3MgZXh0ZW5kcyBFdmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGluaXQgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUsIGluaXQpO1xuICAgIHRoaXMuY29kZSA9IGluaXQuY29kZSA9PT0gdm9pZCAwID8gMCA6IGluaXQuY29kZTtcbiAgICB0aGlzLnJlYXNvbiA9IGluaXQucmVhc29uID09PSB2b2lkIDAgPyBcIlwiIDogaW5pdC5yZWFzb247XG4gICAgdGhpcy53YXNDbGVhbiA9IGluaXQud2FzQ2xlYW4gPT09IHZvaWQgMCA/IGZhbHNlIDogaW5pdC53YXNDbGVhbjtcbiAgfVxufTtcbnZhciBDYW5jZWxhYmxlQ2xvc2VFdmVudCA9IGNsYXNzIGV4dGVuZHMgQ2xvc2VFdmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGluaXQgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUsIGluaXQpO1xuICAgIHRoaXNba0NhbmNlbGFibGVdID0gISFpbml0LmNhbmNlbGFibGU7XG4gICAgdGhpc1trRGVmYXVsdFByZXZlbnRlZF0gPSBmYWxzZTtcbiAgfVxuICBnZXQgY2FuY2VsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2FuY2VsYWJsZV07XG4gIH1cbiAgc2V0IGNhbmNlbGFibGUobmV4dENhbmNlbGFibGUpIHtcbiAgICB0aGlzW2tDYW5jZWxhYmxlXSA9IG5leHRDYW5jZWxhYmxlO1xuICB9XG4gIGdldCBkZWZhdWx0UHJldmVudGVkKCkge1xuICAgIHJldHVybiB0aGlzW2tEZWZhdWx0UHJldmVudGVkXTtcbiAgfVxuICBzZXQgZGVmYXVsdFByZXZlbnRlZChuZXh0RGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXNba0RlZmF1bHRQcmV2ZW50ZWRdID0gbmV4dERlZmF1bHRQcmV2ZW50ZWQ7XG4gIH1cbiAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsYWJsZSAmJiAhdGhpc1trRGVmYXVsdFByZXZlbnRlZF0pIHtcbiAgICAgIHRoaXNba0RlZmF1bHRQcmV2ZW50ZWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5rQ2FuY2VsYWJsZSwga0RlZmF1bHRQcmV2ZW50ZWQ7XG5cbi8vIHNyYy9pbnRlcmNlcHRvcnMvV2ViU29ja2V0L1dlYlNvY2tldENsaWVudENvbm5lY3Rpb24udHNcbnZhciBrRW1pdHRlciA9IFN5bWJvbChcImtFbWl0dGVyXCIpO1xudmFyIGtCb3VuZExpc3RlbmVyID0gU3ltYm9sKFwia0JvdW5kTGlzdGVuZXJcIik7XG52YXIgV2ViU29ja2V0Q2xpZW50Q29ubmVjdGlvbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc29ja2V0LCB0cmFuc3BvcnQpIHtcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLmlkID0gX2NodW5rVElQUjM3M1Jqcy5jcmVhdGVSZXF1ZXN0SWQuY2FsbCh2b2lkIDAsICk7XG4gICAgdGhpcy51cmwgPSBuZXcgVVJMKHNvY2tldC51cmwpO1xuICAgIHRoaXNba0VtaXR0ZXJdID0gbmV3IEV2ZW50VGFyZ2V0KCk7XG4gICAgdGhpcy50cmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcIm91dGdvaW5nXCIsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGJpbmRFdmVudChcbiAgICAgICAgdGhpcy5zb2NrZXQsXG4gICAgICAgIG5ldyBDYW5jZWxhYmxlTWVzc2FnZUV2ZW50KFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgZGF0YTogZXZlbnQuZGF0YSxcbiAgICAgICAgICBvcmlnaW46IGV2ZW50Lm9yaWdpbixcbiAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgdGhpc1trRW1pdHRlcl0uZGlzcGF0Y2hFdmVudChtZXNzYWdlKTtcbiAgICAgIGlmIChtZXNzYWdlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnRyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzW2tFbWl0dGVyXS5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBiaW5kRXZlbnQodGhpcy5zb2NrZXQsIG5ldyBDbG9zZUV2ZW50KFwiY2xvc2VcIiwgZXZlbnQpKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTGlzdGVuIGZvciB0aGUgb3V0Z29pbmcgZXZlbnRzIGZyb20gdGhlIGNvbm5lY3RlZCBXZWJTb2NrZXQgY2xpZW50LlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGlmICghUmVmbGVjdC5oYXMobGlzdGVuZXIsIGtCb3VuZExpc3RlbmVyKSkge1xuICAgICAgY29uc3QgYm91bmRMaXN0ZW5lciA9IGxpc3RlbmVyLmJpbmQodGhpcy5zb2NrZXQpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3RlbmVyLCBrQm91bmRMaXN0ZW5lciwge1xuICAgICAgICB2YWx1ZTogYm91bmRMaXN0ZW5lcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzW2tFbWl0dGVyXS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgdHlwZSxcbiAgICAgIFJlZmxlY3QuZ2V0KGxpc3RlbmVyLCBrQm91bmRMaXN0ZW5lciksXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBldmVudC5cbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgdGhpc1trRW1pdHRlcl0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIGV2ZW50LFxuICAgICAgUmVmbGVjdC5nZXQobGlzdGVuZXIsIGtCb3VuZExpc3RlbmVyKSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgdG8gdGhlIGNvbm5lY3RlZCBjbGllbnQuXG4gICAqL1xuICBzZW5kKGRhdGEpIHtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKGRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIEEgc3RhdHVzIGNvZGUgKHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjQ1NSNzZWN0aW9uLTcuNC4xKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiBBIGN1c3RvbSBjb25uZWN0aW9uIGNsb3NlIHJlYXNvbi5cbiAgICovXG4gIGNsb3NlKGNvZGUsIHJlYXNvbikge1xuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gIH1cbn07XG5rRW1pdHRlcjtcblxuLy8gc3JjL2ludGVyY2VwdG9ycy9XZWJTb2NrZXQvV2ViU29ja2V0U2VydmVyQ29ubmVjdGlvbi50c1xudmFyIF9vdXR2YXJpYW50ID0gcmVxdWlyZSgnb3V0dmFyaWFudCcpO1xuXG4vLyBzcmMvaW50ZXJjZXB0b3JzL1dlYlNvY2tldC9XZWJTb2NrZXRPdmVycmlkZS50c1xuXG52YXIgX2RlZmVycmVkcHJvbWlzZSA9IHJlcXVpcmUoJ0BvcGVuLWRyYWZ0L2RlZmVycmVkLXByb21pc2UnKTtcbnZhciBXRUJTT0NLRVRfQ0xPU0VfQ09ERV9SQU5HRV9FUlJPUiA9IFwiSW52YWxpZEFjY2Vzc0Vycm9yOiBjbG9zZSBjb2RlIG91dCBvZiB1c2VyIGNvbmZpZ3VyYWJsZSByYW5nZVwiO1xudmFyIGtQYXNzdGhyb3VnaFByb21pc2UgPSBTeW1ib2woXCJrUGFzc3Rocm91Z2hQcm9taXNlXCIpO1xudmFyIGtPblNlbmQgPSBTeW1ib2woXCJrT25TZW5kXCIpO1xudmFyIGtDbG9zZSA9IFN5bWJvbChcImtDbG9zZVwiKTtcbnZhciBXZWJTb2NrZXRPdmVycmlkZSA9IGNsYXNzIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHByb3RvY29scykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5DT05ORUNUSU5HID0gMDtcbiAgICB0aGlzLk9QRU4gPSAxO1xuICAgIHRoaXMuQ0xPU0lORyA9IDI7XG4gICAgdGhpcy5DTE9TRUQgPSAzO1xuICAgIHRoaXMuX29ub3BlbiA9IG51bGw7XG4gICAgdGhpcy5fb25tZXNzYWdlID0gbnVsbDtcbiAgICB0aGlzLl9vbmVycm9yID0gbnVsbDtcbiAgICB0aGlzLl9vbmNsb3NlID0gbnVsbDtcbiAgICB0aGlzLnVybCA9IHVybC50b1N0cmluZygpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBcIlwiO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IFwiXCI7XG4gICAgdGhpcy5iaW5hcnlUeXBlID0gXCJibG9iXCI7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5DT05ORUNUSU5HO1xuICAgIHRoaXMuYnVmZmVyZWRBbW91bnQgPSAwO1xuICAgIHRoaXNba1Bhc3N0aHJvdWdoUHJvbWlzZV0gPSBuZXcgKDAsIF9kZWZlcnJlZHByb21pc2UuRGVmZXJyZWRQcm9taXNlKSgpO1xuICAgIHF1ZXVlTWljcm90YXNrKGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChhd2FpdCB0aGlzW2tQYXNzdGhyb3VnaFByb21pc2VdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvdG9jb2wgPSB0eXBlb2YgcHJvdG9jb2xzID09PSBcInN0cmluZ1wiID8gcHJvdG9jb2xzIDogQXJyYXkuaXNBcnJheShwcm90b2NvbHMpICYmIHByb3RvY29scy5sZW5ndGggPiAwID8gcHJvdG9jb2xzWzBdIDogXCJcIjtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuQ09OTkVDVElORykge1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSB0aGlzLk9QRU47XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChiaW5kRXZlbnQodGhpcywgbmV3IEV2ZW50KFwib3BlblwiKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldCBvbm9wZW4obGlzdGVuZXIpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsIHRoaXMuX29ub3Blbik7XG4gICAgdGhpcy5fb25vcGVuID0gbGlzdGVuZXI7XG4gICAgaWYgKGxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG9ub3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb25vcGVuO1xuICB9XG4gIHNldCBvbm1lc3NhZ2UobGlzdGVuZXIpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcIm1lc3NhZ2VcIixcbiAgICAgIHRoaXMuX29ubWVzc2FnZVxuICAgICk7XG4gICAgdGhpcy5fb25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgaWYgKGxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG9ubWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25tZXNzYWdlO1xuICB9XG4gIHNldCBvbmVycm9yKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5fb25lcnJvcik7XG4gICAgdGhpcy5fb25lcnJvciA9IGxpc3RlbmVyO1xuICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuICBnZXQgb25lcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fb25lcnJvcjtcbiAgfVxuICBzZXQgb25jbG9zZShsaXN0ZW5lcikge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHRoaXMuX29uY2xvc2UpO1xuICAgIHRoaXMuX29uY2xvc2UgPSBsaXN0ZW5lcjtcbiAgICBpZiAobGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG9uY2xvc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uY2xvc2U7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jcmVmLWZvci1kb20td2Vic29ja2V0LXNlbmQlRTIlOTElQTBcbiAgICovXG4gIHNlbmQoZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuQ09OTkVDVElORykge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIkludmFsaWRTdGF0ZUVycm9yXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkNMT1NJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkNMT1NFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlcmVkQW1vdW50ICs9IGdldERhdGFTaXplKGRhdGEpO1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRoaXMuYnVmZmVyZWRBbW91bnQgPSAwO1xuICAgICAgKF9hID0gdGhpc1trT25TZW5kXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgY2xvc2UoY29kZSA9IDFlMywgcmVhc29uKSB7XG4gICAgX291dHZhcmlhbnQuaW52YXJpYW50LmNhbGwodm9pZCAwLCBjb2RlLCBXRUJTT0NLRVRfQ0xPU0VfQ09ERV9SQU5HRV9FUlJPUik7XG4gICAgX291dHZhcmlhbnQuaW52YXJpYW50LmNhbGwodm9pZCAwLCBcbiAgICAgIGNvZGUgPT09IDFlMyB8fCBjb2RlID49IDNlMyAmJiBjb2RlIDw9IDQ5OTksXG4gICAgICBXRUJTT0NLRVRfQ0xPU0VfQ09ERV9SQU5HRV9FUlJPUlxuICAgICk7XG4gICAgdGhpc1trQ2xvc2VdKGNvZGUsIHJlYXNvbik7XG4gIH1cbiAgWyhrUGFzc3Rocm91Z2hQcm9taXNlLCBrT25TZW5kLCBrQ2xvc2UpXShjb2RlID0gMWUzLCByZWFzb24sIHdhc0NsZWFuID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuQ0xPU0lORyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuQ0xPU0VEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IHRoaXMuQ0xPU0lORztcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSB0aGlzLkNMT1NFRDtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgYmluZEV2ZW50KFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbmV3IENsb3NlRXZlbnQoXCJjbG9zZVwiLCB7XG4gICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgd2FzQ2xlYW5cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgdGhpcy5fb25vcGVuID0gbnVsbDtcbiAgICAgIHRoaXMuX29ubWVzc2FnZSA9IG51bGw7XG4gICAgICB0aGlzLl9vbmVycm9yID0gbnVsbDtcbiAgICAgIHRoaXMuX29uY2xvc2UgPSBudWxsO1xuICAgIH0pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3VwZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIHR5cGUsXG4gICAgICBsaXN0ZW5lcixcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIH1cbn07XG5XZWJTb2NrZXRPdmVycmlkZS5DT05ORUNUSU5HID0gMDtcbldlYlNvY2tldE92ZXJyaWRlLk9QRU4gPSAxO1xuV2ViU29ja2V0T3ZlcnJpZGUuQ0xPU0lORyA9IDI7XG5XZWJTb2NrZXRPdmVycmlkZS5DTE9TRUQgPSAzO1xuZnVuY3Rpb24gZ2V0RGF0YVNpemUoZGF0YSkge1xuICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gIH1cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIGRhdGEuc2l6ZTtcbiAgfVxuICByZXR1cm4gZGF0YS5ieXRlTGVuZ3RoO1xufVxuXG4vLyBzcmMvaW50ZXJjZXB0b3JzL1dlYlNvY2tldC9XZWJTb2NrZXRTZXJ2ZXJDb25uZWN0aW9uLnRzXG52YXIga0VtaXR0ZXIyID0gU3ltYm9sKFwia0VtaXR0ZXJcIik7XG52YXIga0JvdW5kTGlzdGVuZXIyID0gU3ltYm9sKFwia0JvdW5kTGlzdGVuZXJcIik7XG52YXIga1NlbmQgPSBTeW1ib2woXCJrU2VuZFwiKTtcbnZhciBXZWJTb2NrZXRTZXJ2ZXJDb25uZWN0aW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIHRyYW5zcG9ydCwgY3JlYXRlQ29ubmVjdGlvbikge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuY3JlYXRlQ29ubmVjdGlvbiA9IGNyZWF0ZUNvbm5lY3Rpb247XG4gICAgdGhpc1trRW1pdHRlcjJdID0gbmV3IEV2ZW50VGFyZ2V0KCk7XG4gICAgdGhpcy5tb2NrQ2xvc2VDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMucmVhbENsb3NlQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKFwib3V0Z29pbmdcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMucmVhbFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHRoaXNba1NlbmRdKGV2ZW50LmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnRyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJpbmNvbWluZ1wiLFxuICAgICAgdGhpcy5oYW5kbGVJbmNvbWluZ01lc3NhZ2UuYmluZCh0aGlzKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBgV2ViU29ja2V0YCBpbnN0YW5jZSBjb25uZWN0ZWQgdG8gdGhlIG9yaWdpbmFsIHNlcnZlci5cbiAgICogQWNjZXNzaW5nIHRoaXMgYmVmb3JlIGNhbGxpbmcgYHNlcnZlci5jb25uZWN0KClgIHdpbGwgdGhyb3cuXG4gICAqL1xuICBnZXQgc29ja2V0KCkge1xuICAgIF9vdXR2YXJpYW50LmludmFyaWFudC5jYWxsKHZvaWQgMCwgXG4gICAgICB0aGlzLnJlYWxXZWJTb2NrZXQsXG4gICAgICAnQ2Fubm90IGFjY2VzcyBcInNvY2tldFwiIG9uIHRoZSBvcmlnaW5hbCBXZWJTb2NrZXQgc2VydmVyIG9iamVjdDogdGhlIGNvbm5lY3Rpb24gaXMgbm90IG9wZW4uIERpZCB5b3UgZm9yZ2V0IHRvIGNhbGwgYHNlcnZlci5jb25uZWN0KClgPydcbiAgICApO1xuICAgIHJldHVybiB0aGlzLnJlYWxXZWJTb2NrZXQ7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gY29ubmVjdGlvbiB0byB0aGUgb3JpZ2luYWwgV2ViU29ja2V0IHNlcnZlci5cbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgX291dHZhcmlhbnQuaW52YXJpYW50LmNhbGwodm9pZCAwLCBcbiAgICAgICF0aGlzLnJlYWxXZWJTb2NrZXQgfHwgdGhpcy5yZWFsV2ViU29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOLFxuICAgICAgJ0ZhaWxlZCB0byBjYWxsIFwiY29ubmVjdCgpXCIgb24gdGhlIG9yaWdpbmFsIFdlYlNvY2tldCBpbnN0YW5jZTogdGhlIGNvbm5lY3Rpb24gYWxyZWFkeSBvcGVuJ1xuICAgICk7XG4gICAgY29uc3QgcmVhbFdlYlNvY2tldCA9IHRoaXMuY3JlYXRlQ29ubmVjdGlvbigpO1xuICAgIHJlYWxXZWJTb2NrZXQuYmluYXJ5VHlwZSA9IHRoaXMuY2xpZW50LmJpbmFyeVR5cGU7XG4gICAgcmVhbFdlYlNvY2tldC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJvcGVuXCIsXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpc1trRW1pdHRlcjJdLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgYmluZEV2ZW50KHRoaXMucmVhbFdlYlNvY2tldCwgbmV3IEV2ZW50KFwib3BlblwiLCBldmVudCkpXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICApO1xuICAgIHJlYWxXZWJTb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLnRyYW5zcG9ydC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBiaW5kRXZlbnQoXG4gICAgICAgICAgdGhpcy5yZWFsV2ViU29ja2V0LFxuICAgICAgICAgIG5ldyBNZXNzYWdlRXZlbnQoXCJpbmNvbWluZ1wiLCB7XG4gICAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLFxuICAgICAgICAgICAgb3JpZ2luOiBldmVudC5vcmlnaW5cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICAgIHRoaXMuY2xpZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImNsb3NlXCIsXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVNb2NrQ2xvc2UoZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2lnbmFsOiB0aGlzLm1vY2tDbG9zZUNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICB9XG4gICAgKTtcbiAgICByZWFsV2ViU29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImNsb3NlXCIsXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVSZWFsQ2xvc2UoZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2lnbmFsOiB0aGlzLnJlYWxDbG9zZUNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICB9XG4gICAgKTtcbiAgICByZWFsV2ViU29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvckV2ZW50ID0gYmluZEV2ZW50KFxuICAgICAgICByZWFsV2ViU29ja2V0LFxuICAgICAgICBuZXcgRXZlbnQoXCJlcnJvclwiLCB7IGNhbmNlbGFibGU6IHRydWUgfSlcbiAgICAgICk7XG4gICAgICB0aGlzW2tFbWl0dGVyMl0uZGlzcGF0Y2hFdmVudChlcnJvckV2ZW50KTtcbiAgICAgIGlmICghZXJyb3JFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoYmluZEV2ZW50KHRoaXMuY2xpZW50LCBuZXcgRXZlbnQoXCJlcnJvclwiKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVhbFdlYlNvY2tldCA9IHJlYWxXZWJTb2NrZXQ7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgdGhlIGluY29taW5nIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBXZWJTb2NrZXQgc2VydmVyLlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIVJlZmxlY3QuaGFzKGxpc3RlbmVyLCBrQm91bmRMaXN0ZW5lcjIpKSB7XG4gICAgICBjb25zdCBib3VuZExpc3RlbmVyID0gbGlzdGVuZXIuYmluZCh0aGlzLmNsaWVudCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGlzdGVuZXIsIGtCb3VuZExpc3RlbmVyMiwge1xuICAgICAgICB2YWx1ZTogYm91bmRMaXN0ZW5lcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzW2tFbWl0dGVyMl0uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIGV2ZW50LFxuICAgICAgUmVmbGVjdC5nZXQobGlzdGVuZXIsIGtCb3VuZExpc3RlbmVyMiksXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBsaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICB0aGlzW2tFbWl0dGVyMl0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIGV2ZW50LFxuICAgICAgUmVmbGVjdC5nZXQobGlzdGVuZXIsIGtCb3VuZExpc3RlbmVyMiksXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2VuZCBkYXRhIHRvIHRoZSBvcmlnaW5hbCBXZWJTb2NrZXQgc2VydmVyLlxuICAgKiBAZXhhbXBsZVxuICAgKiBzZXJ2ZXIuc2VuZCgnaGVsbG8nKVxuICAgKiBzZXJ2ZXIuc2VuZChuZXcgQmxvYihbJ2hlbGxvJ10pKVxuICAgKiBzZXJ2ZXIuc2VuZChuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ2hlbGxvJykpXG4gICAqL1xuICBzZW5kKGRhdGEpIHtcbiAgICB0aGlzW2tTZW5kXShkYXRhKTtcbiAgfVxuICBbKGtFbWl0dGVyMiwga1NlbmQpXShkYXRhKSB7XG4gICAgY29uc3QgeyByZWFsV2ViU29ja2V0IH0gPSB0aGlzO1xuICAgIF9vdXR2YXJpYW50LmludmFyaWFudC5jYWxsKHZvaWQgMCwgXG4gICAgICByZWFsV2ViU29ja2V0LFxuICAgICAgJ0ZhaWxlZCB0byBjYWxsIFwic2VydmVyLnNlbmQoKVwiIGZvciBcIiVzXCI6IHRoZSBjb25uZWN0aW9uIGlzIG5vdCBvcGVuLiBEaWQgeW91IGZvcmdldCB0byBjYWxsIFwic2VydmVyLmNvbm5lY3QoKVwiPycsXG4gICAgICB0aGlzLmNsaWVudC51cmxcbiAgICApO1xuICAgIGlmIChyZWFsV2ViU29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TSU5HIHx8IHJlYWxXZWJTb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVhbFdlYlNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgcmVhbFdlYlNvY2tldC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm9wZW5cIixcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHJlYWxXZWJTb2NrZXQuc2VuZChkYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlYWxXZWJTb2NrZXQuc2VuZChkYXRhKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgdGhlIGFjdHVhbCBzZXJ2ZXIgY29ubmVjdGlvbi5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGNvbnN0IHsgcmVhbFdlYlNvY2tldCB9ID0gdGhpcztcbiAgICBfb3V0dmFyaWFudC5pbnZhcmlhbnQuY2FsbCh2b2lkIDAsIFxuICAgICAgcmVhbFdlYlNvY2tldCxcbiAgICAgICdGYWlsZWQgdG8gY2xvc2Ugc2VydmVyIGNvbm5lY3Rpb24gZm9yIFwiJXNcIjogdGhlIGNvbm5lY3Rpb24gaXMgbm90IG9wZW4uIERpZCB5b3UgZm9yZ2V0IHRvIGNhbGwgXCJzZXJ2ZXIuY29ubmVjdCgpXCI/JyxcbiAgICAgIHRoaXMuY2xpZW50LnVybFxuICAgICk7XG4gICAgdGhpcy5yZWFsQ2xvc2VDb250cm9sbGVyLmFib3J0KCk7XG4gICAgaWYgKHJlYWxXZWJTb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcgfHwgcmVhbFdlYlNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlYWxXZWJTb2NrZXQuY2xvc2UoKTtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICB0aGlzW2tFbWl0dGVyMl0uZGlzcGF0Y2hFdmVudChcbiAgICAgICAgYmluZEV2ZW50KFxuICAgICAgICAgIHRoaXMucmVhbFdlYlNvY2tldCxcbiAgICAgICAgICBuZXcgQ2FuY2VsYWJsZUNsb3NlRXZlbnQoXCJjbG9zZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBub3RlIGBzZXJ2ZXIuY2xvc2UoKWAgaW4gdGhlIGludGVyY2VwdG9yXG4gICAgICAgICAgICAgKiBhbHdheXMgcmVzdWx0cyBpbiBjbGVhbiBjbG9zdXJlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29kZTogMWUzLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlSW5jb21pbmdNZXNzYWdlKGV2ZW50KSB7XG4gICAgY29uc3QgbWVzc2FnZUV2ZW50ID0gYmluZEV2ZW50KFxuICAgICAgZXZlbnQudGFyZ2V0LFxuICAgICAgbmV3IENhbmNlbGFibGVNZXNzYWdlRXZlbnQoXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgZGF0YTogZXZlbnQuZGF0YSxcbiAgICAgICAgb3JpZ2luOiBldmVudC5vcmlnaW4sXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzW2tFbWl0dGVyMl0uZGlzcGF0Y2hFdmVudChtZXNzYWdlRXZlbnQpO1xuICAgIGlmICghbWVzc2FnZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIGJpbmRFdmVudChcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAbm90ZSBCaW5kIHRoZSBmb3J3YXJkZWQgb3JpZ2luYWwgc2VydmVyIGV2ZW50c1xuICAgICAgICAgICAqIHRvIHRoZSBtb2NrIFdlYlNvY2tldCBpbnN0YW5jZSBzbyBpdCB3b3VsZFxuICAgICAgICAgICAqIGRpc3BhdGNoIHRoZW0gc3RyYWlnaHQgYXdheS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLmNsaWVudCxcbiAgICAgICAgICAvLyBDbG9uZSB0aGUgbWVzc2FnZSBldmVudCBhZ2FpbiB0byBwcmV2ZW50XG4gICAgICAgICAgLy8gdGhlIFwiYWxyZWFkeSBiZWluZyBkaXNwYXRjaGVkXCIgZXhjZXB0aW9uLlxuICAgICAgICAgIG5ldyBNZXNzYWdlRXZlbnQoXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICBvcmlnaW46IGV2ZW50Lm9yaWdpblxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGhhbmRsZU1vY2tDbG9zZShfZXZlbnQpIHtcbiAgICBpZiAodGhpcy5yZWFsV2ViU29ja2V0KSB7XG4gICAgICB0aGlzLnJlYWxXZWJTb2NrZXQuY2xvc2UoKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlUmVhbENsb3NlKGV2ZW50KSB7XG4gICAgdGhpcy5tb2NrQ2xvc2VDb250cm9sbGVyLmFib3J0KCk7XG4gICAgY29uc3QgY2xvc2VFdmVudCA9IGJpbmRFdmVudChcbiAgICAgIHRoaXMucmVhbFdlYlNvY2tldCxcbiAgICAgIG5ldyBDYW5jZWxhYmxlQ2xvc2VFdmVudChcImNsb3NlXCIsIHtcbiAgICAgICAgY29kZTogZXZlbnQuY29kZSxcbiAgICAgICAgcmVhc29uOiBldmVudC5yZWFzb24sXG4gICAgICAgIHdhc0NsZWFuOiBldmVudC53YXNDbGVhbixcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXNba0VtaXR0ZXIyXS5kaXNwYXRjaEV2ZW50KGNsb3NlRXZlbnQpO1xuICAgIGlmICghY2xvc2VFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICB0aGlzLmNsaWVudFtrQ2xvc2VdKGV2ZW50LmNvZGUsIGV2ZW50LnJlYXNvbik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvaW50ZXJjZXB0b3JzL1dlYlNvY2tldC9XZWJTb2NrZXRDbGFzc1RyYW5zcG9ydC50c1xudmFyIFdlYlNvY2tldENsYXNzVHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIGNvbnN0cnVjdG9yKHNvY2tldCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGJpbmRFdmVudCh0aGlzLnNvY2tldCwgbmV3IENsb3NlRXZlbnQoXCJjbG9zZVwiLCBldmVudCkpKTtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldFtrT25TZW5kXSA9IChkYXRhKSA9PiB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIGJpbmRFdmVudChcbiAgICAgICAgICB0aGlzLnNvY2tldCxcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGlzIGFzIGNhbmNlbGFibGUgYmVjYXVzZSBcImNsaWVudFwiIGNvbm5lY3Rpb25cbiAgICAgICAgICAvLyByZS1jcmVhdGVzIHRoaXMgbWVzc2FnZSBldmVudCAoY2Fubm90IGRpc3BhdGNoIHRoZSBzYW1lIGV2ZW50KS5cbiAgICAgICAgICBuZXcgQ2FuY2VsYWJsZU1lc3NhZ2VFdmVudChcIm91dGdvaW5nXCIsIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBvcmlnaW46IHRoaXMuc29ja2V0LnVybCxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHJldHVybiBzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgfVxuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHN1cGVyLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG4gIHNlbmQoZGF0YSkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNvY2tldC5yZWFkeVN0YXRlID09PSB0aGlzLnNvY2tldC5DTE9TSU5HIHx8IHRoaXMuc29ja2V0LnJlYWR5U3RhdGUgPT09IHRoaXMuc29ja2V0LkNMT1NFRCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkaXNwYXRjaEV2ZW50ID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNvY2tldC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgIGJpbmRFdmVudChcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG5vdGUgU2V0dGluZyB0aGlzIGV2ZW50J3MgXCJ0YXJnZXRcIiB0byB0aGVcbiAgICAgICAgICAgICAqIFdlYlNvY2tldCBvdmVycmlkZSBpbnN0YW5jZSBpcyBpbXBvcnRhbnQuXG4gICAgICAgICAgICAgKiBUaGlzIHdheSBpdCBjYW4gdGVsbCBhcGFydCBvcmlnaW5hbCBpbmNvbWluZyBldmVudHNcbiAgICAgICAgICAgICAqIChtdXN0IGJlIGZvcndhcmRlZCB0byB0aGUgdHJhbnNwb3J0KSBmcm9tIHRoZVxuICAgICAgICAgICAgICogbW9ja2VkIG1lc3NhZ2UgZXZlbnRzIGxpa2UgdGhlIG9uZSBiZWxvd1xuICAgICAgICAgICAgICogKG11c3QgYmUgZGlzcGF0Y2hlZCBvbiB0aGUgY2xpZW50IGluc3RhbmNlKS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQsXG4gICAgICAgICAgICBuZXcgTWVzc2FnZUV2ZW50KFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgIG9yaWdpbjogdGhpcy5zb2NrZXQudXJsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5zb2NrZXQucmVhZHlTdGF0ZSA9PT0gdGhpcy5zb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIFwib3BlblwiLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaEV2ZW50KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2xvc2UoY29kZSwgcmVhc29uKSB7XG4gICAgdGhpcy5zb2NrZXRba0Nsb3NlXShjb2RlLCByZWFzb24pO1xuICB9XG59O1xuXG4vLyBzcmMvaW50ZXJjZXB0b3JzL1dlYlNvY2tldC9pbmRleC50c1xudmFyIF9XZWJTb2NrZXRJbnRlcmNlcHRvciA9IGNsYXNzIGV4dGVuZHMgX2NodW5rVElQUjM3M1Jqcy5JbnRlcmNlcHRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKF9XZWJTb2NrZXRJbnRlcmNlcHRvci5zeW1ib2wpO1xuICB9XG4gIGNoZWNrRW52aXJvbm1lbnQoKSB7XG4gICAgcmV0dXJuIF9jaHVua1BGR081QlNNanMuaGFzQ29uZmlndXJhYmxlR2xvYmFsLmNhbGwodm9pZCAwLCBcIldlYlNvY2tldFwiKTtcbiAgfVxuICBzZXR1cCgpIHtcbiAgICBjb25zdCBvcmlnaW5hbFdlYlNvY2tldERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgZ2xvYmFsVGhpcyxcbiAgICAgIFwiV2ViU29ja2V0XCJcbiAgICApO1xuICAgIGNvbnN0IFdlYlNvY2tldFByb3h5ID0gbmV3IFByb3h5KGdsb2JhbFRoaXMuV2ViU29ja2V0LCB7XG4gICAgICBjb25zdHJ1Y3Q6ICh0YXJnZXQsIGFyZ3MsIG5ld1RhcmdldCkgPT4ge1xuICAgICAgICBjb25zdCBbdXJsLCBwcm90b2NvbHNdID0gYXJncztcbiAgICAgICAgY29uc3QgY3JlYXRlQ29ubmVjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgV2ViU29ja2V0T3ZlcnJpZGUodXJsLCBwcm90b2NvbHMpO1xuICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgV2ViU29ja2V0Q2xhc3NUcmFuc3BvcnQoc29ja2V0KTtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXIgPSBuZXcgV2ViU29ja2V0U2VydmVyQ29ubmVjdGlvbihcbiAgICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgICB0cmFuc3BvcnQsXG4gICAgICAgICAgICAgIGNyZWF0ZUNvbm5lY3Rpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBoYXNDb25uZWN0aW9uTGlzdGVuZXJzID0gdGhpcy5lbWl0dGVyLmVtaXQoXCJjb25uZWN0aW9uXCIsIHtcbiAgICAgICAgICAgICAgY2xpZW50OiBuZXcgV2ViU29ja2V0Q2xpZW50Q29ubmVjdGlvbihzb2NrZXQsIHRyYW5zcG9ydCksXG4gICAgICAgICAgICAgIHNlcnZlcixcbiAgICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIHByb3RvY29sc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChoYXNDb25uZWN0aW9uTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIHNvY2tldFtrUGFzc3Rocm91Z2hQcm9taXNlXS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvY2tldFtrUGFzc3Rocm91Z2hQcm9taXNlXS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICBzZXJ2ZXIuY29ubmVjdCgpO1xuICAgICAgICAgICAgICBzZXJ2ZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNvY2tldC5kaXNwYXRjaEV2ZW50KGJpbmRFdmVudChzb2NrZXQsIG5ldyBFdmVudChcIm9wZW5cIikpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyW1wicmVhbFdlYlNvY2tldFwiXSkge1xuICAgICAgICAgICAgICAgICAgc29ja2V0LnByb3RvY29sID0gc2VydmVyW1wicmVhbFdlYlNvY2tldFwiXS5wcm90b2NvbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICBzb2NrZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJlcnJvclwiKSk7XG4gICAgICAgICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNMT1NJTkcgJiYgc29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DTE9TRUQpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXRba0Nsb3NlXSgxMDExLCBlcnJvci5tZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgXCJXZWJTb2NrZXRcIiwge1xuICAgICAgdmFsdWU6IFdlYlNvY2tldFByb3h5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICBnbG9iYWxUaGlzLFxuICAgICAgICBcIldlYlNvY2tldFwiLFxuICAgICAgICBvcmlnaW5hbFdlYlNvY2tldERlc2NyaXB0b3JcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgV2ViU29ja2V0SW50ZXJjZXB0b3IgPSBfV2ViU29ja2V0SW50ZXJjZXB0b3I7XG5XZWJTb2NrZXRJbnRlcmNlcHRvci5zeW1ib2wgPSBTeW1ib2woXCJ3ZWJzb2NrZXRcIik7XG5cblxuXG5cbmV4cG9ydHMuV2ViU29ja2V0Q2xpZW50Q29ubmVjdGlvbiA9IFdlYlNvY2tldENsaWVudENvbm5lY3Rpb247IGV4cG9ydHMuV2ViU29ja2V0SW50ZXJjZXB0b3IgPSBXZWJTb2NrZXRJbnRlcmNlcHRvcjsgZXhwb3J0cy5XZWJTb2NrZXRTZXJ2ZXJDb25uZWN0aW9uID0gV2ViU29ja2V0U2VydmVyQ29ubmVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/@mswjs+interceptors@0.37.1/node_modules/@mswjs/interceptors/lib/browser/interceptors/WebSocket/index.js\n"));

/***/ }),

/***/ "../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/browser/index.js":
/*!************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/browser/index.js ***!
  \************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"../../../node_modules/.pnpm/next@15.0.4_@babel+core@7.26.0_@playwright+test@1.49.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/polyfills/process.js\");\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/browser/index.ts\nvar browser_exports = {};\n__export(browser_exports, {\n  SetupWorkerApi: () => SetupWorkerApi,\n  setupWorker: () => setupWorker\n});\nmodule.exports = __toCommonJS(browser_exports);\n\n// node_modules/.pnpm/outvariant@1.4.3/node_modules/outvariant/lib/index.mjs\nvar POSITIONALS_EXP = /(%?)(%([sdijo]))/g;\nfunction serializePositional(positional, flag) {\n  switch (flag) {\n    case \"s\":\n      return positional;\n    case \"d\":\n    case \"i\":\n      return Number(positional);\n    case \"j\":\n      return JSON.stringify(positional);\n    case \"o\": {\n      if (typeof positional === \"string\") {\n        return positional;\n      }\n      const json = JSON.stringify(positional);\n      if (json === \"{}\" || json === \"[]\" || /^\\[object .+?\\]$/.test(json)) {\n        return positional;\n      }\n      return json;\n    }\n  }\n}\nfunction format(message, ...positionals) {\n  if (positionals.length === 0) {\n    return message;\n  }\n  let positionalIndex = 0;\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex];\n      const value = serializePositional(positional, flag);\n      if (!isEscaped) {\n        positionalIndex++;\n        return value;\n      }\n      return match;\n    }\n  );\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(\" \")}`;\n  }\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, \"%\");\n  return formattedMessage;\n}\nvar STACK_FRAMES_TO_IGNORE = 2;\nfunction cleanErrorStack(error2) {\n  if (!error2.stack) {\n    return;\n  }\n  const nextStack = error2.stack.split(\"\\n\");\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE);\n  error2.stack = nextStack.join(\"\\n\");\n}\nvar InvariantError = class extends Error {\n  constructor(message, ...positionals) {\n    super(message);\n    this.message = message;\n    this.name = \"Invariant Violation\";\n    this.message = format(message, ...positionals);\n    cleanErrorStack(this);\n  }\n};\nvar invariant = (predicate, message, ...positionals) => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals);\n  }\n};\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage = positionals.length === 0 ? message : format(message, ...positionals);\n    let error2;\n    try {\n      error2 = Reflect.construct(ErrorConstructor, [\n        formatMessage\n      ]);\n    } catch (err) {\n      error2 = ErrorConstructor(formatMessage);\n    }\n    throw error2;\n  }\n};\n\n// node_modules/.pnpm/is-node-process@1.2.0/node_modules/is-node-process/lib/index.mjs\nfunction isNodeProcess() {\n  if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    return true;\n  }\n  if (typeof process !== \"undefined\") {\n    const type = process.type;\n    if (type === \"renderer\" || type === \"worker\") {\n      return false;\n    }\n    return !!(process.versions && process.versions.node);\n  }\n  return false;\n}\n\n// src/browser/setupWorker/start/createStartHandler.ts\nvar import_devUtils7 = __webpack_require__(/*! ../core/utils/internal/devUtils.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/devUtils.js\");\n\n// node_modules/.pnpm/@open-draft+until@2.1.0/node_modules/@open-draft/until/lib/index.mjs\nvar until = async (promise) => {\n  try {\n    const data = await promise().catch((error2) => {\n      throw error2;\n    });\n    return { error: null, data };\n  } catch (error2) {\n    return { error: error2, data: null };\n  }\n};\n\n// src/browser/setupWorker/start/utils/getWorkerInstance.ts\nvar import_devUtils = __webpack_require__(/*! ../core/utils/internal/devUtils.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/devUtils.js\");\n\n// src/browser/utils/getAbsoluteWorkerUrl.ts\nfunction getAbsoluteWorkerUrl(workerUrl) {\n  return new URL(workerUrl, location.href).href;\n}\n\n// src/browser/setupWorker/start/utils/getWorkerByRegistration.ts\nfunction getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting\n  ];\n  const relevantStates = allStates.filter((state) => {\n    return state != null;\n  });\n  const worker = relevantStates.find((worker2) => {\n    return findWorker(worker2.scriptURL, absoluteWorkerUrl);\n  });\n  return worker || null;\n}\n\n// src/browser/setupWorker/start/utils/getWorkerInstance.ts\nvar getWorkerInstance = async (url, options = {}, findWorker) => {\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(\n    (registrations) => registrations.filter(\n      (registration) => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)\n    )\n  );\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n  const [existingRegistration] = mockRegistrations;\n  if (existingRegistration) {\n    existingRegistration.update();\n    return [\n      getWorkerByRegistration(\n        existingRegistration,\n        absoluteWorkerUrl,\n        findWorker\n      ),\n      existingRegistration\n    ];\n  }\n  const registrationResult = await until(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options);\n      return [\n        // Compare existing worker registration by its worker URL,\n        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration\n      ];\n    }\n  );\n  if (registrationResult.error) {\n    const isWorkerMissing = registrationResult.error.message.includes(\"(404)\");\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || \"/\", location.href);\n      throw new Error(\n        import_devUtils.devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`)\n      );\n    }\n    throw new Error(\n      import_devUtils.devUtils.formatMessage(\n        \"Failed to register the Service Worker:\\n\\n%s\",\n        registrationResult.error.message\n      )\n    );\n  }\n  return registrationResult.data;\n};\n\n// src/browser/setupWorker/start/utils/enableMocking.ts\nvar import_devUtils3 = __webpack_require__(/*! ../core/utils/internal/devUtils.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/devUtils.js\");\n\n// src/browser/setupWorker/start/utils/printStartMessage.ts\nvar import_devUtils2 = __webpack_require__(/*! ../core/utils/internal/devUtils.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/devUtils.js\");\nfunction printStartMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  const message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(\n    `%c${import_devUtils2.devUtils.formatMessage(message)}`,\n    \"color:orangered;font-weight:bold;\"\n  );\n  console.log(\n    \"%cDocumentation: %chttps://mswjs.io/docs\",\n    \"font-weight:bold\",\n    \"font-weight:normal\"\n  );\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n  if (args.client) {\n    console.log(\"Client ID: %s (%s)\", args.client.id, args.client.frameType);\n  }\n  console.groupEnd();\n}\n\n// src/browser/setupWorker/start/utils/enableMocking.ts\nasync function enableMocking(context, options) {\n  context.workerChannel.send(\"MOCK_ACTIVATE\");\n  const { payload } = await context.events.once(\"MOCKING_ENABLED\");\n  if (context.isMockingEnabled) {\n    import_devUtils3.devUtils.warn(\n      `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`\n    );\n    return;\n  }\n  context.isMockingEnabled = true;\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: context.registration?.scope,\n    workerUrl: context.worker?.scriptURL,\n    client: payload.client\n  });\n}\n\n// src/browser/setupWorker/start/utils/createMessageChannel.ts\nvar WorkerChannel = class {\n  constructor(port) {\n    this.port = port;\n  }\n  postMessage(event, ...rest) {\n    const [data, transfer] = rest;\n    this.port.postMessage({ type: event, data }, { transfer });\n  }\n};\n\n// src/browser/utils/pruneGetRequestBody.ts\nfunction pruneGetRequestBody(request) {\n  if ([\"HEAD\", \"GET\"].includes(request.method)) {\n    return void 0;\n  }\n  return request.body;\n}\n\n// src/browser/utils/parseWorkerRequest.ts\nfunction parseWorkerRequest(incomingRequest) {\n  return new Request(incomingRequest.url, {\n    ...incomingRequest,\n    body: pruneGetRequestBody(incomingRequest)\n  });\n}\n\n// src/browser/setupWorker/start/createRequestListener.ts\nvar import_RequestHandler = __webpack_require__(/*! ../core/handlers/RequestHandler.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/handlers/RequestHandler.js\");\nvar import_handleRequest = __webpack_require__(/*! ../core/utils/handleRequest.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/handleRequest.js\");\nvar import_devUtils4 = __webpack_require__(/*! ../core/utils/internal/devUtils.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/devUtils.js\");\nvar import_toResponseInit = __webpack_require__(/*! ../core/utils/toResponseInit.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/toResponseInit.js\");\nvar import_isHandlerKind = __webpack_require__(/*! ../core/utils/internal/isHandlerKind.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/isHandlerKind.js\");\nvar createRequestListener = (context, options) => {\n  return async (event, message) => {\n    const messageChannel = new WorkerChannel(event.ports[0]);\n    const requestId = message.payload.id;\n    const request = parseWorkerRequest(message.payload);\n    const requestCloneForLogs = request.clone();\n    const requestClone = request.clone();\n    import_RequestHandler.RequestHandler.cache.set(request, requestClone);\n    context.requests.set(requestId, requestClone);\n    try {\n      await (0, import_handleRequest.handleRequest)(\n        request,\n        requestId,\n        context.getRequestHandlers().filter((0, import_isHandlerKind.isHandlerKind)(\"RequestHandler\")),\n        options,\n        context.emitter,\n        {\n          onPassthroughResponse() {\n            messageChannel.postMessage(\"PASSTHROUGH\");\n          },\n          async onMockedResponse(response, { handler, parsedResult }) {\n            const responseClone = response.clone();\n            const responseCloneForLogs = response.clone();\n            const responseInit = (0, import_toResponseInit.toResponseInit)(response);\n            if (context.supports.readableStreamTransfer) {\n              const responseStreamOrNull = response.body;\n              messageChannel.postMessage(\n                \"MOCK_RESPONSE\",\n                {\n                  ...responseInit,\n                  body: responseStreamOrNull\n                },\n                responseStreamOrNull ? [responseStreamOrNull] : void 0\n              );\n            } else {\n              const responseBufferOrNull = response.body === null ? null : await responseClone.arrayBuffer();\n              messageChannel.postMessage(\"MOCK_RESPONSE\", {\n                ...responseInit,\n                body: responseBufferOrNull\n              });\n            }\n            if (!options.quiet) {\n              context.emitter.once(\"response:mocked\", () => {\n                handler.log({\n                  request: requestCloneForLogs,\n                  response: responseCloneForLogs,\n                  parsedResult\n                });\n              });\n            }\n          }\n        }\n      );\n    } catch (error2) {\n      if (error2 instanceof Error) {\n        import_devUtils4.devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,\n          request.method,\n          request.url,\n          error2.stack ?? error2\n        );\n        messageChannel.postMessage(\"MOCK_RESPONSE\", {\n          status: 500,\n          statusText: \"Request Handler Error\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            name: error2.name,\n            message: error2.message,\n            stack: error2.stack\n          })\n        });\n      }\n    }\n  };\n};\n\n// src/browser/utils/checkWorkerIntegrity.ts\nvar import_devUtils5 = __webpack_require__(/*! ../core/utils/internal/devUtils.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/devUtils.js\");\nasync function checkWorkerIntegrity(context) {\n  context.workerChannel.send(\"INTEGRITY_CHECK_REQUEST\");\n  const { payload } = await context.events.once(\"INTEGRITY_CHECK_RESPONSE\");\n  if (payload.checksum !== \"ca7800994cc8bfb5eb961e037c877074\") {\n    import_devUtils5.devUtils.warn(\n      `The currently registered Service Worker has been generated by a different version of MSW (${payload.packageVersion}) and may not be fully compatible with the installed version.\n\nIt's recommended you update your worker script by running this command:\n\n  \\u2022 npx msw init <PUBLIC_DIR>\n\nYou can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`\n    );\n  }\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.37.0/node_modules/@mswjs/interceptors/lib/browser/chunk-6HYIRFX2.mjs\nvar encoder = new TextEncoder();\nfunction encodeBuffer(text) {\n  return encoder.encode(text);\n}\nfunction decodeBuffer(buffer, encoding) {\n  const decoder = new TextDecoder(encoding);\n  return decoder.decode(buffer);\n}\nfunction toArrayBuffer(array) {\n  return array.buffer.slice(\n    array.byteOffset,\n    array.byteOffset + array.byteLength\n  );\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.37.0/node_modules/@mswjs/interceptors/lib/browser/chunk-F4BN745U.mjs\nvar IS_PATCHED_MODULE = Symbol(\"isPatchedModule\");\nvar _FetchResponse = class extends Response {\n  static isConfigurableStatusCode(status) {\n    return status >= 200 && status <= 599;\n  }\n  static isRedirectResponse(status) {\n    return _FetchResponse.STATUS_CODES_WITH_REDIRECT.includes(status);\n  }\n  /**\n   * Returns a boolean indicating whether the given response status\n   * code represents a response that can have a body.\n   */\n  static isResponseWithBody(status) {\n    return !_FetchResponse.STATUS_CODES_WITHOUT_BODY.includes(status);\n  }\n  static setUrl(url, response) {\n    if (!url) {\n      return;\n    }\n    if (response.url != \"\") {\n      return;\n    }\n    Object.defineProperty(response, \"url\", {\n      value: url,\n      enumerable: true,\n      configurable: true,\n      writable: false\n    });\n  }\n  constructor(body, init = {}) {\n    var _a;\n    const status = (_a = init.status) != null ? _a : 200;\n    const safeStatus = _FetchResponse.isConfigurableStatusCode(status) ? status : 200;\n    const finalBody = _FetchResponse.isResponseWithBody(status) ? body : null;\n    super(finalBody, {\n      ...init,\n      status: safeStatus\n    });\n    if (status !== safeStatus) {\n      const stateSymbol = Object.getOwnPropertySymbols(this).find(\n        (symbol) => symbol.description === \"state\"\n      );\n      if (stateSymbol) {\n        const state = Reflect.get(this, stateSymbol);\n        Reflect.set(state, \"status\", status);\n      } else {\n        Object.defineProperty(this, \"status\", {\n          value: status,\n          enumerable: true,\n          configurable: true,\n          writable: false\n        });\n      }\n    }\n    _FetchResponse.setUrl(init.url, this);\n  }\n};\nvar FetchResponse = _FetchResponse;\nFetchResponse.STATUS_CODES_WITHOUT_BODY = [101, 103, 204, 205, 304];\nFetchResponse.STATUS_CODES_WITH_REDIRECT = [301, 302, 303, 307, 308];\n\n// node_modules/.pnpm/@open-draft+logger@0.3.0/node_modules/@open-draft/logger/lib/index.mjs\nvar __defProp2 = Object.defineProperty;\nvar __export2 = (target, all) => {\n  for (var name in all)\n    __defProp2(target, name, { get: all[name], enumerable: true });\n};\nvar colors_exports = {};\n__export2(colors_exports, {\n  blue: () => blue,\n  gray: () => gray,\n  green: () => green,\n  red: () => red,\n  yellow: () => yellow\n});\nfunction yellow(text) {\n  return `\\x1B[33m${text}\\x1B[0m`;\n}\nfunction blue(text) {\n  return `\\x1B[34m${text}\\x1B[0m`;\n}\nfunction gray(text) {\n  return `\\x1B[90m${text}\\x1B[0m`;\n}\nfunction red(text) {\n  return `\\x1B[31m${text}\\x1B[0m`;\n}\nfunction green(text) {\n  return `\\x1B[32m${text}\\x1B[0m`;\n}\nvar IS_NODE = isNodeProcess();\nvar Logger = class {\n  constructor(name) {\n    this.name = name;\n    this.prefix = `[${this.name}]`;\n    const LOGGER_NAME = getVariable(\"DEBUG\");\n    const LOGGER_LEVEL = getVariable(\"LOG_LEVEL\");\n    const isLoggingEnabled = LOGGER_NAME === \"1\" || LOGGER_NAME === \"true\" || typeof LOGGER_NAME !== \"undefined\" && this.name.startsWith(LOGGER_NAME);\n    if (isLoggingEnabled) {\n      this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, \"debug\") ? noop : this.debug;\n      this.info = isDefinedAndNotEquals(LOGGER_LEVEL, \"info\") ? noop : this.info;\n      this.success = isDefinedAndNotEquals(LOGGER_LEVEL, \"success\") ? noop : this.success;\n      this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, \"warning\") ? noop : this.warning;\n      this.error = isDefinedAndNotEquals(LOGGER_LEVEL, \"error\") ? noop : this.error;\n    } else {\n      this.info = noop;\n      this.success = noop;\n      this.warning = noop;\n      this.error = noop;\n      this.only = noop;\n    }\n  }\n  prefix;\n  extend(domain) {\n    return new Logger(`${this.name}:${domain}`);\n  }\n  /**\n   * Print a debug message.\n   * @example\n   * logger.debug('no duplicates found, creating a document...')\n   */\n  debug(message, ...positionals) {\n    this.logEntry({\n      level: \"debug\",\n      message: gray(message),\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"gray\"\n      }\n    });\n  }\n  /**\n   * Print an info message.\n   * @example\n   * logger.info('start parsing...')\n   */\n  info(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"blue\"\n      }\n    });\n    const performance2 = new PerformanceEntry();\n    return (message2, ...positionals2) => {\n      performance2.measure();\n      this.logEntry({\n        level: \"info\",\n        message: `${message2} ${gray(`${performance2.deltaTime}ms`)}`,\n        positionals: positionals2,\n        prefix: this.prefix,\n        colors: {\n          prefix: \"blue\"\n        }\n      });\n    };\n  }\n  /**\n   * Print a success message.\n   * @example\n   * logger.success('successfully created document')\n   */\n  success(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: `\\u2714 ${this.prefix}`,\n      colors: {\n        timestamp: \"green\",\n        prefix: \"green\"\n      }\n    });\n  }\n  /**\n   * Print a warning.\n   * @example\n   * logger.warning('found legacy document format')\n   */\n  warning(message, ...positionals) {\n    this.logEntry({\n      level: \"warning\",\n      message,\n      positionals,\n      prefix: `\\u26A0 ${this.prefix}`,\n      colors: {\n        timestamp: \"yellow\",\n        prefix: \"yellow\"\n      }\n    });\n  }\n  /**\n   * Print an error message.\n   * @example\n   * logger.error('something went wrong')\n   */\n  error(message, ...positionals) {\n    this.logEntry({\n      level: \"error\",\n      message,\n      positionals,\n      prefix: `\\u2716 ${this.prefix}`,\n      colors: {\n        timestamp: \"red\",\n        prefix: \"red\"\n      }\n    });\n  }\n  /**\n   * Execute the given callback only when the logging is enabled.\n   * This is skipped in its entirety and has no runtime cost otherwise.\n   * This executes regardless of the log level.\n   * @example\n   * logger.only(() => {\n   *   logger.info('additional info')\n   * })\n   */\n  only(callback) {\n    callback();\n  }\n  createEntry(level, message) {\n    return {\n      timestamp: /* @__PURE__ */ new Date(),\n      level,\n      message\n    };\n  }\n  logEntry(args) {\n    const {\n      level,\n      message,\n      prefix,\n      colors: customColors,\n      positionals = []\n    } = args;\n    const entry = this.createEntry(level, message);\n    const timestampColor = customColors?.timestamp || \"gray\";\n    const prefixColor = customColors?.prefix || \"gray\";\n    const colorize = {\n      timestamp: colors_exports[timestampColor],\n      prefix: colors_exports[prefixColor]\n    };\n    const write = this.getWriter(level);\n    write(\n      [colorize.timestamp(this.formatTimestamp(entry.timestamp))].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(\" \"),\n      ...positionals.map(serializeInput)\n    );\n  }\n  formatTimestamp(timestamp) {\n    return `${timestamp.toLocaleTimeString(\n      \"en-GB\"\n    )}:${timestamp.getMilliseconds()}`;\n  }\n  getWriter(level) {\n    switch (level) {\n      case \"debug\":\n      case \"success\":\n      case \"info\": {\n        return log;\n      }\n      case \"warning\": {\n        return warn;\n      }\n      case \"error\": {\n        return error;\n      }\n    }\n  }\n};\nvar PerformanceEntry = class {\n  startTime;\n  endTime;\n  deltaTime;\n  constructor() {\n    this.startTime = performance.now();\n  }\n  measure() {\n    this.endTime = performance.now();\n    const deltaTime = this.endTime - this.startTime;\n    this.deltaTime = deltaTime.toFixed(2);\n  }\n};\nvar noop = () => void 0;\nfunction log(message, ...positionals) {\n  if (IS_NODE) {\n    process.stdout.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.log(message, ...positionals);\n}\nfunction warn(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.warn(message, ...positionals);\n}\nfunction error(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.error(message, ...positionals);\n}\nfunction getVariable(variableName) {\n  if (IS_NODE) {\n    return process.env[variableName];\n  }\n  return globalThis[variableName]?.toString();\n}\nfunction isDefinedAndNotEquals(value, expected) {\n  return value !== void 0 && value !== expected;\n}\nfunction serializeInput(message) {\n  if (typeof message === \"undefined\") {\n    return \"undefined\";\n  }\n  if (message === null) {\n    return \"null\";\n  }\n  if (typeof message === \"string\") {\n    return message;\n  }\n  if (typeof message === \"object\") {\n    return JSON.stringify(message);\n  }\n  return message.toString();\n}\n\n// node_modules/.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/lib/index.mjs\nvar MemoryLeakError = class extends Error {\n  constructor(emitter, type, count) {\n    super(\n      `Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`\n    );\n    this.emitter = emitter;\n    this.type = type;\n    this.count = count;\n    this.name = \"MaxListenersExceededWarning\";\n  }\n};\nvar _Emitter = class {\n  static listenerCount(emitter, eventName) {\n    return emitter.listenerCount(eventName);\n  }\n  constructor() {\n    this.events = /* @__PURE__ */ new Map();\n    this.maxListeners = _Emitter.defaultMaxListeners;\n    this.hasWarnedAboutPotentialMemoryLeak = false;\n  }\n  _emitInternalEvent(internalEventName, eventName, listener) {\n    this.emit(\n      internalEventName,\n      ...[eventName, listener]\n    );\n  }\n  _getListeners(eventName) {\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || [];\n  }\n  _removeListener(listeners, listener) {\n    const index = listeners.indexOf(listener);\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n    return [];\n  }\n  _wrapOnceListener(eventName, listener) {\n    const onceListener = (...data) => {\n      this.removeListener(eventName, onceListener);\n      return listener.apply(this, data);\n    };\n    Object.defineProperty(onceListener, \"name\", { value: listener.name });\n    return onceListener;\n  }\n  setMaxListeners(maxListeners) {\n    this.maxListeners = maxListeners;\n    return this;\n  }\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  getMaxListeners() {\n    return this.maxListeners;\n  }\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  eventNames() {\n    return Array.from(this.events.keys());\n  }\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  emit(eventName, ...data) {\n    const listeners = this._getListeners(eventName);\n    listeners.forEach((listener) => {\n      listener.apply(this, data);\n    });\n    return listeners.length > 0;\n  }\n  addListener(eventName, listener) {\n    this._emitInternalEvent(\"newListener\", eventName, listener);\n    const nextListeners = this._getListeners(eventName).concat(listener);\n    this.events.set(eventName, nextListeners);\n    if (this.maxListeners > 0 && this.listenerCount(eventName) > this.maxListeners && !this.hasWarnedAboutPotentialMemoryLeak) {\n      this.hasWarnedAboutPotentialMemoryLeak = true;\n      const memoryLeakWarning = new MemoryLeakError(\n        this,\n        eventName,\n        this.listenerCount(eventName)\n      );\n      console.warn(memoryLeakWarning);\n    }\n    return this;\n  }\n  on(eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n  once(eventName, listener) {\n    return this.addListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    );\n  }\n  prependListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners);\n      this.events.set(eventName, nextListeners);\n    } else {\n      this.events.set(eventName, listeners.concat(listener));\n    }\n    return this;\n  }\n  prependOnceListener(eventName, listener) {\n    return this.prependListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    );\n  }\n  removeListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener);\n      this.events.set(eventName, listeners);\n      this._emitInternalEvent(\"removeListener\", eventName, listener);\n    }\n    return this;\n  }\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  off(eventName, listener) {\n    return this.removeListener(eventName, listener);\n  }\n  removeAllListeners(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n    return this;\n  }\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  listeners(eventName) {\n    return Array.from(this._getListeners(eventName));\n  }\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  listenerCount(eventName) {\n    return this._getListeners(eventName).length;\n  }\n  rawListeners(eventName) {\n    return this.listeners(eventName);\n  }\n};\nvar Emitter = _Emitter;\nEmitter.defaultMaxListeners = 10;\n\n// node_modules/.pnpm/@mswjs+interceptors@0.37.0/node_modules/@mswjs/interceptors/lib/browser/chunk-QED3Q6Z2.mjs\nvar INTERNAL_REQUEST_ID_HEADER_NAME = \"x-interceptors-internal-request-id\";\nfunction getGlobalSymbol(symbol) {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || void 0\n  );\n}\nfunction setGlobalSymbol(symbol, value) {\n  globalThis[symbol] = value;\n}\nfunction deleteGlobalSymbol(symbol) {\n  delete globalThis[symbol];\n}\nvar Interceptor = class {\n  constructor(symbol) {\n    this.symbol = symbol;\n    this.readyState = \"INACTIVE\";\n    this.emitter = new Emitter();\n    this.subscriptions = [];\n    this.logger = new Logger(symbol.description);\n    this.emitter.setMaxListeners(0);\n    this.logger.info(\"constructing the interceptor...\");\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  checkEnvironment() {\n    return true;\n  }\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  apply() {\n    const logger = this.logger.extend(\"apply\");\n    logger.info(\"applying the interceptor...\");\n    if (this.readyState === \"APPLIED\") {\n      logger.info(\"intercepted already applied!\");\n      return;\n    }\n    const shouldApply = this.checkEnvironment();\n    if (!shouldApply) {\n      logger.info(\"the interceptor cannot be applied in this environment!\");\n      return;\n    }\n    this.readyState = \"APPLYING\";\n    const runningInstance = this.getInstance();\n    if (runningInstance) {\n      logger.info(\"found a running instance, reusing...\");\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event);\n        runningInstance.emitter.addListener(event, listener);\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener);\n          logger.info('removed proxied \"%s\" listener!', event);\n        });\n        return this;\n      };\n      this.readyState = \"APPLIED\";\n      return;\n    }\n    logger.info(\"no running instance found, setting up a new instance...\");\n    this.setup();\n    this.setInstance();\n    this.readyState = \"APPLIED\";\n  }\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  setup() {\n  }\n  /**\n   * Listen to the interceptor's public events.\n   */\n  on(event, listener) {\n    const logger = this.logger.extend(\"on\");\n    if (this.readyState === \"DISPOSING\" || this.readyState === \"DISPOSED\") {\n      logger.info(\"cannot listen to events, already disposed!\");\n      return this;\n    }\n    logger.info('adding \"%s\" event listener:', event, listener);\n    this.emitter.on(event, listener);\n    return this;\n  }\n  once(event, listener) {\n    this.emitter.once(event, listener);\n    return this;\n  }\n  off(event, listener) {\n    this.emitter.off(event, listener);\n    return this;\n  }\n  removeAllListeners(event) {\n    this.emitter.removeAllListeners(event);\n    return this;\n  }\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  dispose() {\n    const logger = this.logger.extend(\"dispose\");\n    if (this.readyState === \"DISPOSED\") {\n      logger.info(\"cannot dispose, already disposed!\");\n      return;\n    }\n    logger.info(\"disposing the interceptor...\");\n    this.readyState = \"DISPOSING\";\n    if (!this.getInstance()) {\n      logger.info(\"no interceptors running, skipping dispose...\");\n      return;\n    }\n    this.clearInstance();\n    logger.info(\"global symbol deleted:\", getGlobalSymbol(this.symbol));\n    if (this.subscriptions.length > 0) {\n      logger.info(\"disposing of %d subscriptions...\", this.subscriptions.length);\n      for (const dispose of this.subscriptions) {\n        dispose();\n      }\n      this.subscriptions = [];\n      logger.info(\"disposed of all subscriptions!\", this.subscriptions.length);\n    }\n    this.emitter.removeAllListeners();\n    logger.info(\"destroyed the listener!\");\n    this.readyState = \"DISPOSED\";\n  }\n  getInstance() {\n    var _a;\n    const instance = getGlobalSymbol(this.symbol);\n    this.logger.info(\"retrieved global instance:\", (_a = instance == null ? void 0 : instance.constructor) == null ? void 0 : _a.name);\n    return instance;\n  }\n  setInstance() {\n    setGlobalSymbol(this.symbol, this);\n    this.logger.info(\"set global instance!\", this.symbol.description);\n  }\n  clearInstance() {\n    deleteGlobalSymbol(this.symbol);\n    this.logger.info(\"cleared global instance!\", this.symbol.description);\n  }\n};\nfunction createRequestId() {\n  return Math.random().toString(16).slice(2);\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.37.0/node_modules/@mswjs/interceptors/lib/browser/index.mjs\nvar BatchInterceptor = class extends Interceptor {\n  constructor(options) {\n    BatchInterceptor.symbol = Symbol(options.name);\n    super(BatchInterceptor.symbol);\n    this.interceptors = options.interceptors;\n  }\n  setup() {\n    const logger = this.logger.extend(\"setup\");\n    logger.info(\"applying all %d interceptors...\", this.interceptors.length);\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name);\n      interceptor.apply();\n      logger.info(\"adding interceptor dispose subscription\");\n      this.subscriptions.push(() => interceptor.dispose());\n    }\n  }\n  on(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener);\n    }\n    return this;\n  }\n  once(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener);\n    }\n    return this;\n  }\n  off(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener);\n    }\n    return this;\n  }\n  removeAllListeners(event) {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event);\n    }\n    return this;\n  }\n};\n\n// src/browser/setupWorker/start/createResponseListener.ts\nfunction createResponseListener(context) {\n  return (_, message) => {\n    const { payload: responseJson } = message;\n    const { requestId } = responseJson;\n    const request = context.requests.get(requestId);\n    context.requests.delete(requestId);\n    if (responseJson.type?.includes(\"opaque\")) {\n      return;\n    }\n    const response = responseJson.status === 0 ? Response.error() : new FetchResponse(\n      /**\n       * Responses may be streams here, but when we create a response object\n       * with null-body status codes, like 204, 205, 304 Response will\n       * throw when passed a non-null body, so ensure it's null here\n       * for those codes\n       */\n      FetchResponse.isResponseWithBody(responseJson.status) ? responseJson.body : null,\n      {\n        ...responseJson,\n        /**\n         * Set response URL if it's not set already.\n         * @see https://github.com/mswjs/msw/issues/2030\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Response/url\n         */\n        url: request.url\n      }\n    );\n    context.emitter.emit(\n      responseJson.isMockedResponse ? \"response:mocked\" : \"response:bypass\",\n      {\n        response,\n        request,\n        requestId: responseJson.requestId\n      }\n    );\n  };\n}\n\n// src/browser/setupWorker/start/utils/validateWorkerScope.ts\nvar import_devUtils6 = __webpack_require__(/*! ../core/utils/internal/devUtils.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/devUtils.js\");\nfunction validateWorkerScope(registration, options) {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    import_devUtils6.devUtils.warn(\n      `Cannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.`\n    );\n  }\n}\n\n// src/browser/setupWorker/start/createStartHandler.ts\nvar createStartHandler = (context) => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      context.events.removeAllListeners();\n      context.workerChannel.on(\n        \"REQUEST\",\n        createRequestListener(context, options)\n      );\n      context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker\n      );\n      const [worker, registration] = instance;\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker ? import_devUtils7.devUtils.formatMessage(\n          `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n          options.serviceWorker.url\n        ) : import_devUtils7.devUtils.formatMessage(\n          `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n          options.serviceWorker.url,\n          location.host\n        );\n        throw new Error(missingWorkerMessage);\n      }\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, \"beforeunload\", () => {\n        if (worker.state !== \"redundant\") {\n          context.workerChannel.send(\"CLIENT_CLOSED\");\n        }\n        window.clearInterval(context.keepAliveInterval);\n        window.postMessage({ type: \"msw/worker:stop\" });\n      });\n      await checkWorkerIntegrity(context).catch((error2) => {\n        import_devUtils7.devUtils.error(\n          \"Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues), including the original error below.\"\n        );\n        console.error(error2);\n      });\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send(\"KEEPALIVE_REQUEST\"),\n        5e3\n      );\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    };\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting;\n        if (pendingInstance) {\n          await new Promise((resolve) => {\n            pendingInstance.addEventListener(\"statechange\", () => {\n              if (pendingInstance.state === \"activated\") {\n                return resolve();\n              }\n            });\n          });\n        }\n        await enableMocking(context, options).catch((error2) => {\n          throw new Error(`Failed to enable mocking: ${error2?.message}`);\n        });\n        return registration;\n      }\n    );\n    return workerRegistration;\n  };\n};\n\n// src/browser/setupWorker/stop/createStop.ts\nvar import_devUtils9 = __webpack_require__(/*! ../core/utils/internal/devUtils.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/devUtils.js\");\n\n// src/browser/setupWorker/stop/utils/printStopMessage.ts\nvar import_devUtils8 = __webpack_require__(/*! ../core/utils/internal/devUtils.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/devUtils.js\");\nfunction printStopMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  console.log(\n    `%c${import_devUtils8.devUtils.formatMessage(\"Mocking disabled.\")}`,\n    \"color:orangered;font-weight:bold;\"\n  );\n}\n\n// src/browser/setupWorker/stop/createStop.ts\nvar createStop = (context) => {\n  return function stop() {\n    if (!context.isMockingEnabled) {\n      import_devUtils9.devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.'\n      );\n      return;\n    }\n    context.workerChannel.send(\"MOCK_DEACTIVATE\");\n    context.isMockingEnabled = false;\n    window.clearInterval(context.keepAliveInterval);\n    window.postMessage({ type: \"msw/worker:stop\" });\n    printStopMessage({ quiet: context.startOptions?.quiet });\n  };\n};\n\n// src/browser/setupWorker/start/utils/prepareStartHandler.ts\nvar import_mergeRight = __webpack_require__(/*! ../core/utils/internal/mergeRight.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/mergeRight.js\");\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n\n// node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/build/index.mjs\nfunction createDeferredExecutor() {\n  const executor = (resolve, reject) => {\n    executor.state = \"pending\";\n    executor.resolve = (data) => {\n      if (executor.state !== \"pending\") {\n        return;\n      }\n      executor.result = data;\n      const onFulfilled = (value) => {\n        executor.state = \"fulfilled\";\n        return value;\n      };\n      return resolve(\n        data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled)\n      );\n    };\n    executor.reject = (reason) => {\n      if (executor.state !== \"pending\") {\n        return;\n      }\n      queueMicrotask(() => {\n        executor.state = \"rejected\";\n      });\n      return reject(executor.rejectionReason = reason);\n    };\n  };\n  return executor;\n}\nvar DeferredPromise = class extends Promise {\n  #executor;\n  resolve;\n  reject;\n  constructor(executor = null) {\n    const deferredExecutor = createDeferredExecutor();\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject);\n      executor?.(deferredExecutor.resolve, deferredExecutor.reject);\n    });\n    this.#executor = deferredExecutor;\n    this.resolve = this.#executor.resolve;\n    this.reject = this.#executor.reject;\n  }\n  get state() {\n    return this.#executor.state;\n  }\n  get rejectionReason() {\n    return this.#executor.rejectionReason;\n  }\n  then(onFulfilled, onRejected) {\n    return this.#decorate(super.then(onFulfilled, onRejected));\n  }\n  catch(onRejected) {\n    return this.#decorate(super.catch(onRejected));\n  }\n  finally(onfinally) {\n    return this.#decorate(super.finally(onfinally));\n  }\n  #decorate(promise) {\n    return Object.defineProperties(promise, {\n      resolve: { configurable: true, value: this.resolve },\n      reject: { configurable: true, value: this.reject }\n    });\n  }\n};\n\n// node_modules/.pnpm/@mswjs+interceptors@0.37.0/node_modules/@mswjs/interceptors/lib/browser/chunk-H5O73WD2.mjs\nvar InterceptorError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"InterceptorError\";\n    Object.setPrototypeOf(this, InterceptorError.prototype);\n  }\n};\nvar kRequestHandled = Symbol(\"kRequestHandled\");\nvar kResponsePromise = Symbol(\"kResponsePromise\");\nvar RequestController = class {\n  constructor(request) {\n    this.request = request;\n    this[kRequestHandled] = false;\n    this[kResponsePromise] = new DeferredPromise();\n  }\n  /**\n   * Respond to this request with the given `Response` instance.\n   * @example\n   * controller.respondWith(new Response())\n   * controller.respondWith(Response.json({ id }))\n   * controller.respondWith(Response.error())\n   */\n  respondWith(response) {\n    invariant.as(\n      InterceptorError,\n      !this[kRequestHandled],\n      'Failed to respond to the \"%s %s\" request: the \"request\" event has already been handled.',\n      this.request.method,\n      this.request.url\n    );\n    this[kRequestHandled] = true;\n    this[kResponsePromise].resolve(response);\n  }\n  /**\n   * Error this request with the given error.\n   * @example\n   * controller.errorWith()\n   * controller.errorWith(new Error('Oops!'))\n   */\n  errorWith(error2) {\n    invariant.as(\n      InterceptorError,\n      !this[kRequestHandled],\n      'Failed to error the \"%s %s\" request: the \"request\" event has already been handled.',\n      this.request.method,\n      this.request.url\n    );\n    this[kRequestHandled] = true;\n    this[kResponsePromise].resolve(error2);\n  }\n};\nasync function emitAsync(emitter, eventName, ...data) {\n  const listners = emitter.listeners(eventName);\n  if (listners.length === 0) {\n    return;\n  }\n  for (const listener of listners) {\n    await listener.apply(emitter, data);\n  }\n}\nfunction isPropertyAccessible(obj, key) {\n  try {\n    obj[key];\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction createServerErrorResponse(body) {\n  return new Response(\n    JSON.stringify(\n      body instanceof Error ? {\n        name: body.name,\n        message: body.message,\n        stack: body.stack\n      } : body\n    ),\n    {\n      status: 500,\n      statusText: \"Unhandled Exception\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }\n  );\n}\nfunction isResponseError(response) {\n  return isPropertyAccessible(response, \"type\") && response.type === \"error\";\n}\nfunction isNodeLikeError(error2) {\n  if (error2 == null) {\n    return false;\n  }\n  if (!(error2 instanceof Error)) {\n    return false;\n  }\n  return \"code\" in error2 && \"errno\" in error2;\n}\nasync function handleRequest2(options) {\n  const handleResponse = async (response) => {\n    if (response instanceof Error) {\n      options.onError(response);\n    } else if (isResponseError(response)) {\n      options.onRequestError(response);\n    } else {\n      await options.onResponse(response);\n    }\n    return true;\n  };\n  const handleResponseError = async (error2) => {\n    if (error2 instanceof InterceptorError) {\n      throw result.error;\n    }\n    if (isNodeLikeError(error2)) {\n      options.onError(error2);\n      return true;\n    }\n    if (error2 instanceof Response) {\n      return await handleResponse(error2);\n    }\n    return false;\n  };\n  options.emitter.once(\"request\", ({ requestId: pendingRequestId }) => {\n    if (pendingRequestId !== options.requestId) {\n      return;\n    }\n    if (options.controller[kResponsePromise].state === \"pending\") {\n      options.controller[kResponsePromise].resolve(void 0);\n    }\n  });\n  const requestAbortPromise = new DeferredPromise();\n  if (options.request.signal) {\n    if (options.request.signal.aborted) {\n      requestAbortPromise.reject(options.request.signal.reason);\n    } else {\n      options.request.signal.addEventListener(\n        \"abort\",\n        () => {\n          requestAbortPromise.reject(options.request.signal.reason);\n        },\n        { once: true }\n      );\n    }\n  }\n  const result = await until(async () => {\n    const requestListtenersPromise = emitAsync(options.emitter, \"request\", {\n      requestId: options.requestId,\n      request: options.request,\n      controller: options.controller\n    });\n    await Promise.race([\n      // Short-circuit the request handling promise if the request gets aborted.\n      requestAbortPromise,\n      requestListtenersPromise,\n      options.controller[kResponsePromise]\n    ]);\n    const mockedResponse = await options.controller[kResponsePromise];\n    return mockedResponse;\n  });\n  if (requestAbortPromise.state === \"rejected\") {\n    options.onError(requestAbortPromise.rejectionReason);\n    return true;\n  }\n  if (result.error) {\n    if (await handleResponseError(result.error)) {\n      return true;\n    }\n    if (options.emitter.listenerCount(\"unhandledException\") > 0) {\n      const unhandledExceptionController = new RequestController(\n        options.request\n      );\n      await emitAsync(options.emitter, \"unhandledException\", {\n        error: result.error,\n        request: options.request,\n        requestId: options.requestId,\n        controller: unhandledExceptionController\n      }).then(() => {\n        if (unhandledExceptionController[kResponsePromise].state === \"pending\") {\n          unhandledExceptionController[kResponsePromise].resolve(void 0);\n        }\n      });\n      const nextResult = await until(\n        () => unhandledExceptionController[kResponsePromise]\n      );\n      if (nextResult.error) {\n        return handleResponseError(nextResult.error);\n      }\n      if (nextResult.data) {\n        return handleResponse(nextResult.data);\n      }\n    }\n    options.onResponse(createServerErrorResponse(result.error));\n    return true;\n  }\n  if (result.data) {\n    return handleResponse(result.data);\n  }\n  return false;\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.37.0/node_modules/@mswjs/interceptors/lib/browser/chunk-TX5GBTFY.mjs\nfunction hasConfigurableGlobal(propertyName) {\n  const descriptor = Object.getOwnPropertyDescriptor(globalThis, propertyName);\n  if (typeof descriptor === \"undefined\") {\n    return false;\n  }\n  if (typeof descriptor.get === \"function\" && typeof descriptor.get() === \"undefined\") {\n    return false;\n  }\n  if (typeof descriptor.get === \"undefined\" && descriptor.value == null) {\n    return false;\n  }\n  if (typeof descriptor.set === \"undefined\" && !descriptor.configurable) {\n    console.error(\n      `[MSW] Failed to apply interceptor: the global \\`${propertyName}\\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`\n    );\n    return false;\n  }\n  return true;\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.37.0/node_modules/@mswjs/interceptors/lib/browser/chunk-HER3NHBG.mjs\nfunction canParseUrl(url) {\n  try {\n    new URL(url);\n    return true;\n  } catch (_error) {\n    return false;\n  }\n}\nfunction createNetworkError(cause) {\n  return Object.assign(new TypeError(\"Failed to fetch\"), {\n    cause\n  });\n}\nvar REQUEST_BODY_HEADERS = [\n  \"content-encoding\",\n  \"content-language\",\n  \"content-location\",\n  \"content-type\",\n  \"content-length\"\n];\nvar kRedirectCount = Symbol(\"kRedirectCount\");\nasync function followFetchRedirect(request, response) {\n  if (response.status !== 303 && request.body != null) {\n    return Promise.reject(createNetworkError());\n  }\n  const requestUrl = new URL(request.url);\n  let locationUrl;\n  try {\n    locationUrl = new URL(response.headers.get(\"location\"), request.url);\n  } catch (error2) {\n    return Promise.reject(createNetworkError(error2));\n  }\n  if (!(locationUrl.protocol === \"http:\" || locationUrl.protocol === \"https:\")) {\n    return Promise.reject(\n      createNetworkError(\"URL scheme must be a HTTP(S) scheme\")\n    );\n  }\n  if (Reflect.get(request, kRedirectCount) > 20) {\n    return Promise.reject(createNetworkError(\"redirect count exceeded\"));\n  }\n  Object.defineProperty(request, kRedirectCount, {\n    value: (Reflect.get(request, kRedirectCount) || 0) + 1\n  });\n  if (request.mode === \"cors\" && (locationUrl.username || locationUrl.password) && !sameOrigin(requestUrl, locationUrl)) {\n    return Promise.reject(\n      createNetworkError('cross origin not allowed for request mode \"cors\"')\n    );\n  }\n  const requestInit = {};\n  if ([301, 302].includes(response.status) && request.method === \"POST\" || response.status === 303 && ![\"HEAD\", \"GET\"].includes(request.method)) {\n    requestInit.method = \"GET\";\n    requestInit.body = null;\n    REQUEST_BODY_HEADERS.forEach((headerName) => {\n      request.headers.delete(headerName);\n    });\n  }\n  if (!sameOrigin(requestUrl, locationUrl)) {\n    request.headers.delete(\"authorization\");\n    request.headers.delete(\"proxy-authorization\");\n    request.headers.delete(\"cookie\");\n    request.headers.delete(\"host\");\n  }\n  requestInit.headers = request.headers;\n  return fetch(new Request(locationUrl, requestInit));\n}\nfunction sameOrigin(left, right) {\n  if (left.origin === right.origin && left.origin === \"null\") {\n    return true;\n  }\n  if (left.protocol === right.protocol && left.hostname === right.hostname && left.port === right.port) {\n    return true;\n  }\n  return false;\n}\nvar BrotliDecompressionStream = class extends TransformStream {\n  constructor() {\n    console.warn(\n      \"[Interceptors]: Brotli decompression of response streams is not supported in the browser\"\n    );\n    super({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n};\nvar PipelineStream = class extends TransformStream {\n  constructor(transformStreams, ...strategies) {\n    super({}, ...strategies);\n    const readable = [super.readable, ...transformStreams].reduce(\n      (readable2, transform) => readable2.pipeThrough(transform)\n    );\n    Object.defineProperty(this, \"readable\", {\n      get() {\n        return readable;\n      }\n    });\n  }\n};\nfunction parseContentEncoding(contentEncoding) {\n  return contentEncoding.toLowerCase().split(\",\").map((coding) => coding.trim());\n}\nfunction createDecompressionStream(contentEncoding) {\n  if (contentEncoding === \"\") {\n    return null;\n  }\n  const codings = parseContentEncoding(contentEncoding);\n  if (codings.length === 0) {\n    return null;\n  }\n  const transformers = codings.reduceRight(\n    (transformers2, coding) => {\n      if (coding === \"gzip\" || coding === \"x-gzip\") {\n        return transformers2.concat(new DecompressionStream(\"gzip\"));\n      } else if (coding === \"deflate\") {\n        return transformers2.concat(new DecompressionStream(\"deflate\"));\n      } else if (coding === \"br\") {\n        return transformers2.concat(new BrotliDecompressionStream());\n      } else {\n        transformers2.length = 0;\n      }\n      return transformers2;\n    },\n    []\n  );\n  return new PipelineStream(transformers);\n}\nfunction decompressResponse(response) {\n  if (response.body === null) {\n    return null;\n  }\n  const decompressionStream = createDecompressionStream(\n    response.headers.get(\"content-encoding\") || \"\"\n  );\n  if (!decompressionStream) {\n    return null;\n  }\n  response.body.pipeTo(decompressionStream.writable);\n  return decompressionStream.readable;\n}\nvar _FetchInterceptor = class extends Interceptor {\n  constructor() {\n    super(_FetchInterceptor.symbol);\n  }\n  checkEnvironment() {\n    return hasConfigurableGlobal(\"fetch\");\n  }\n  async setup() {\n    const pureFetch = globalThis.fetch;\n    invariant(\n      !pureFetch[IS_PATCHED_MODULE],\n      'Failed to patch the \"fetch\" module: already patched.'\n    );\n    globalThis.fetch = async (input, init) => {\n      const requestId = createRequestId();\n      const resolvedInput = typeof input === \"string\" && typeof location !== \"undefined\" && !canParseUrl(input) ? new URL(input, location.origin) : input;\n      const request = new Request(resolvedInput, init);\n      const responsePromise = new DeferredPromise();\n      const controller = new RequestController(request);\n      this.logger.info(\"[%s] %s\", request.method, request.url);\n      this.logger.info(\"awaiting for the mocked response...\");\n      this.logger.info(\n        'emitting the \"request\" event for %s listener(s)...',\n        this.emitter.listenerCount(\"request\")\n      );\n      const isRequestHandled = await handleRequest2({\n        request,\n        requestId,\n        emitter: this.emitter,\n        controller,\n        onResponse: async (rawResponse) => {\n          this.logger.info(\"received mocked response!\", {\n            rawResponse\n          });\n          const decompressedStream = decompressResponse(rawResponse);\n          const response = decompressedStream === null ? rawResponse : new FetchResponse(decompressedStream, rawResponse);\n          FetchResponse.setUrl(request.url, response);\n          if (FetchResponse.isRedirectResponse(response.status)) {\n            if (request.redirect === \"error\") {\n              responsePromise.reject(createNetworkError(\"unexpected redirect\"));\n              return;\n            }\n            if (request.redirect === \"follow\") {\n              followFetchRedirect(request, response).then(\n                (response2) => {\n                  responsePromise.resolve(response2);\n                },\n                (reason) => {\n                  responsePromise.reject(reason);\n                }\n              );\n              return;\n            }\n          }\n          if (this.emitter.listenerCount(\"response\") > 0) {\n            this.logger.info('emitting the \"response\" event...');\n            await emitAsync(this.emitter, \"response\", {\n              // Clone the mocked response for the \"response\" event listener.\n              // This way, the listener can read the response and not lock its body\n              // for the actual fetch consumer.\n              response: response.clone(),\n              isMockedResponse: true,\n              request,\n              requestId\n            });\n          }\n          responsePromise.resolve(response);\n        },\n        onRequestError: (response) => {\n          this.logger.info(\"request has errored!\", { response });\n          responsePromise.reject(createNetworkError(response));\n        },\n        onError: (error2) => {\n          this.logger.info(\"request has been aborted!\", { error: error2 });\n          responsePromise.reject(error2);\n        }\n      });\n      if (isRequestHandled) {\n        this.logger.info(\"request has been handled, returning mock promise...\");\n        return responsePromise;\n      }\n      this.logger.info(\n        \"no mocked response received, performing request as-is...\"\n      );\n      return pureFetch(request).then(async (response) => {\n        this.logger.info(\"original fetch performed\", response);\n        if (this.emitter.listenerCount(\"response\") > 0) {\n          this.logger.info('emitting the \"response\" event...');\n          const responseClone = response.clone();\n          await emitAsync(this.emitter, \"response\", {\n            response: responseClone,\n            isMockedResponse: false,\n            request,\n            requestId\n          });\n        }\n        return response;\n      });\n    };\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: void 0\n      });\n      globalThis.fetch = pureFetch;\n      this.logger.info(\n        'restored native \"globalThis.fetch\"!',\n        globalThis.fetch.name\n      );\n    });\n  }\n};\nvar FetchInterceptor = _FetchInterceptor;\nFetchInterceptor.symbol = Symbol(\"fetch\");\n\n// node_modules/.pnpm/@mswjs+interceptors@0.37.0/node_modules/@mswjs/interceptors/lib/browser/chunk-4SRQFK76.mjs\nfunction concatArrayBuffer(left, right) {\n  const result = new Uint8Array(left.byteLength + right.byteLength);\n  result.set(left, 0);\n  result.set(right, left.byteLength);\n  return result;\n}\nvar EventPolyfill = class {\n  constructor(type, options) {\n    this.NONE = 0;\n    this.CAPTURING_PHASE = 1;\n    this.AT_TARGET = 2;\n    this.BUBBLING_PHASE = 3;\n    this.type = \"\";\n    this.srcElement = null;\n    this.currentTarget = null;\n    this.eventPhase = 0;\n    this.isTrusted = true;\n    this.composed = false;\n    this.cancelable = true;\n    this.defaultPrevented = false;\n    this.bubbles = true;\n    this.lengthComputable = true;\n    this.loaded = 0;\n    this.total = 0;\n    this.cancelBubble = false;\n    this.returnValue = true;\n    this.type = type;\n    this.target = (options == null ? void 0 : options.target) || null;\n    this.currentTarget = (options == null ? void 0 : options.currentTarget) || null;\n    this.timeStamp = Date.now();\n  }\n  composedPath() {\n    return [];\n  }\n  initEvent(type, bubbles, cancelable) {\n    this.type = type;\n    this.bubbles = !!bubbles;\n    this.cancelable = !!cancelable;\n  }\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n  stopPropagation() {\n  }\n  stopImmediatePropagation() {\n  }\n};\nvar ProgressEventPolyfill = class extends EventPolyfill {\n  constructor(type, init) {\n    super(type);\n    this.lengthComputable = (init == null ? void 0 : init.lengthComputable) || false;\n    this.composed = (init == null ? void 0 : init.composed) || false;\n    this.loaded = (init == null ? void 0 : init.loaded) || 0;\n    this.total = (init == null ? void 0 : init.total) || 0;\n  }\n};\nvar SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== \"undefined\";\nfunction createEvent(target, type, init) {\n  const progressEvents = [\n    \"error\",\n    \"progress\",\n    \"loadstart\",\n    \"loadend\",\n    \"load\",\n    \"timeout\",\n    \"abort\"\n  ];\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT ? ProgressEvent : ProgressEventPolyfill;\n  const event = progressEvents.includes(type) ? new ProgressEventClass(type, {\n    lengthComputable: true,\n    loaded: (init == null ? void 0 : init.loaded) || 0,\n    total: (init == null ? void 0 : init.total) || 0\n  }) : new EventPolyfill(type, {\n    target,\n    currentTarget: target\n  });\n  return event;\n}\nfunction findPropertySource(target, propertyName) {\n  if (!(propertyName in target)) {\n    return null;\n  }\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName);\n  if (hasProperty) {\n    return target;\n  }\n  const prototype = Reflect.getPrototypeOf(target);\n  return prototype ? findPropertySource(prototype, propertyName) : null;\n}\nfunction createProxy(target, options) {\n  const proxy = new Proxy(target, optionsToProxyHandler(options));\n  return proxy;\n}\nfunction optionsToProxyHandler(options) {\n  const { constructorCall, methodCall, getProperty, setProperty } = options;\n  const handler = {};\n  if (typeof constructorCall !== \"undefined\") {\n    handler.construct = function(target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target, args, newTarget);\n      return constructorCall.call(newTarget, args, next);\n    };\n  }\n  handler.set = function(target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target;\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(\n        propertySource,\n        propertyName\n      );\n      if (typeof (ownDescriptors == null ? void 0 : ownDescriptors.set) !== \"undefined\") {\n        ownDescriptors.set.apply(target, [nextValue]);\n        return true;\n      }\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue\n      });\n    };\n    if (typeof setProperty !== \"undefined\") {\n      return setProperty.call(target, [propertyName, nextValue], next);\n    }\n    return next();\n  };\n  handler.get = function(target, propertyName, receiver) {\n    const next = () => target[propertyName];\n    const value = typeof getProperty !== \"undefined\" ? getProperty.call(target, [propertyName, receiver], next) : next();\n    if (typeof value === \"function\") {\n      return (...args) => {\n        const next2 = value.bind(target, ...args);\n        if (typeof methodCall !== \"undefined\") {\n          return methodCall.call(target, [propertyName, args], next2);\n        }\n        return next2();\n      };\n    }\n    return value;\n  };\n  return handler;\n}\nfunction isDomParserSupportedType(type) {\n  const supportedTypes = [\n    \"application/xhtml+xml\",\n    \"application/xml\",\n    \"image/svg+xml\",\n    \"text/html\",\n    \"text/xml\"\n  ];\n  return supportedTypes.some((supportedType) => {\n    return type.startsWith(supportedType);\n  });\n}\nfunction parseJson(data) {\n  try {\n    const json = JSON.parse(data);\n    return json;\n  } catch (_) {\n    return null;\n  }\n}\nfunction createResponse(request, body) {\n  const responseBodyOrNull = FetchResponse.isResponseWithBody(request.status) ? body : null;\n  return new FetchResponse(responseBodyOrNull, {\n    url: request.responseURL,\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpReqestHeaders(\n      request.getAllResponseHeaders()\n    )\n  });\n}\nfunction createHeadersFromXMLHttpReqestHeaders(headersString) {\n  const headers = new Headers();\n  const lines = headersString.split(/[\\r\\n]+/);\n  for (const line of lines) {\n    if (line.trim() === \"\") {\n      continue;\n    }\n    const [name, ...parts] = line.split(\": \");\n    const value = parts.join(\": \");\n    headers.append(name, value);\n  }\n  return headers;\n}\nasync function getBodyByteLength(input) {\n  const explicitContentLength = input.headers.get(\"content-length\");\n  if (explicitContentLength != null && explicitContentLength !== \"\") {\n    return Number(explicitContentLength);\n  }\n  const buffer = await input.arrayBuffer();\n  return buffer.byteLength;\n}\nvar kIsRequestHandled = Symbol(\"kIsRequestHandled\");\nvar IS_NODE2 = isNodeProcess();\nvar kFetchRequest = Symbol(\"kFetchRequest\");\nvar XMLHttpRequestController = class {\n  constructor(initialRequest, logger) {\n    this.initialRequest = initialRequest;\n    this.logger = logger;\n    this.method = \"GET\";\n    this.url = null;\n    this[kIsRequestHandled] = false;\n    this.events = /* @__PURE__ */ new Map();\n    this.uploadEvents = /* @__PURE__ */ new Map();\n    this.requestId = createRequestId();\n    this.requestHeaders = new Headers();\n    this.responseBuffer = new Uint8Array();\n    this.request = createProxy(initialRequest, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case \"ontimeout\": {\n            const eventName = propertyName.slice(\n              2\n            );\n            this.request.addEventListener(eventName, nextValue);\n            return invoke();\n          }\n          default: {\n            return invoke();\n          }\n        }\n      },\n      methodCall: ([methodName, args], invoke) => {\n        var _a;\n        switch (methodName) {\n          case \"open\": {\n            const [method, url] = args;\n            if (typeof url === \"undefined\") {\n              this.method = \"GET\";\n              this.url = toAbsoluteUrl(method);\n            } else {\n              this.method = method;\n              this.url = toAbsoluteUrl(url);\n            }\n            this.logger = this.logger.extend(`${this.method} ${this.url.href}`);\n            this.logger.info(\"open\", this.method, this.url.href);\n            return invoke();\n          }\n          case \"addEventListener\": {\n            const [eventName, listener] = args;\n            this.registerEvent(eventName, listener);\n            this.logger.info(\"addEventListener\", eventName, listener);\n            return invoke();\n          }\n          case \"setRequestHeader\": {\n            const [name, value] = args;\n            this.requestHeaders.set(name, value);\n            this.logger.info(\"setRequestHeader\", name, value);\n            return invoke();\n          }\n          case \"send\": {\n            const [body] = args;\n            this.request.addEventListener(\"load\", () => {\n              if (typeof this.onResponse !== \"undefined\") {\n                const fetchResponse = createResponse(\n                  this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request's \"responseType\" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response\n                );\n                this.onResponse.call(this, {\n                  response: fetchResponse,\n                  isMockedResponse: this[kIsRequestHandled],\n                  request: fetchRequest,\n                  requestId: this.requestId\n                });\n              }\n            });\n            const requestBody = typeof body === \"string\" ? encodeBuffer(body) : body;\n            const fetchRequest = this.toFetchApiRequest(requestBody);\n            this[kFetchRequest] = fetchRequest.clone();\n            const onceRequestSettled = ((_a = this.onRequest) == null ? void 0 : _a.call(this, {\n              request: fetchRequest,\n              requestId: this.requestId\n            })) || Promise.resolve();\n            onceRequestSettled.finally(() => {\n              if (!this[kIsRequestHandled]) {\n                this.logger.info(\n                  \"request callback settled but request has not been handled (readystate %d), performing as-is...\",\n                  this.request.readyState\n                );\n                if (IS_NODE2) {\n                  this.request.setRequestHeader(\n                    INTERNAL_REQUEST_ID_HEADER_NAME,\n                    this.requestId\n                  );\n                }\n                return invoke();\n              }\n            });\n            break;\n          }\n          default: {\n            return invoke();\n          }\n        }\n      }\n    });\n    define(\n      this.request,\n      \"upload\",\n      createProxy(this.request.upload, {\n        setProperty: ([propertyName, nextValue], invoke) => {\n          switch (propertyName) {\n            case \"onloadstart\":\n            case \"onprogress\":\n            case \"onaboart\":\n            case \"onerror\":\n            case \"onload\":\n            case \"ontimeout\":\n            case \"onloadend\": {\n              const eventName = propertyName.slice(\n                2\n              );\n              this.registerUploadEvent(eventName, nextValue);\n            }\n          }\n          return invoke();\n        },\n        methodCall: ([methodName, args], invoke) => {\n          switch (methodName) {\n            case \"addEventListener\": {\n              const [eventName, listener] = args;\n              this.registerUploadEvent(eventName, listener);\n              this.logger.info(\"upload.addEventListener\", eventName, listener);\n              return invoke();\n            }\n          }\n        }\n      })\n    );\n  }\n  registerEvent(eventName, listener) {\n    const prevEvents = this.events.get(eventName) || [];\n    const nextEvents = prevEvents.concat(listener);\n    this.events.set(eventName, nextEvents);\n    this.logger.info('registered event \"%s\"', eventName, listener);\n  }\n  registerUploadEvent(eventName, listener) {\n    const prevEvents = this.uploadEvents.get(eventName) || [];\n    const nextEvents = prevEvents.concat(listener);\n    this.uploadEvents.set(eventName, nextEvents);\n    this.logger.info('registered upload event \"%s\"', eventName, listener);\n  }\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n  async respondWith(response) {\n    this[kIsRequestHandled] = true;\n    if (this[kFetchRequest]) {\n      const totalRequestBodyLength = await getBodyByteLength(\n        this[kFetchRequest]\n      );\n      this.trigger(\"loadstart\", this.request.upload, {\n        loaded: 0,\n        total: totalRequestBodyLength\n      });\n      this.trigger(\"progress\", this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength\n      });\n      this.trigger(\"load\", this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength\n      });\n      this.trigger(\"loadend\", this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength\n      });\n    }\n    this.logger.info(\n      \"responding with a mocked response: %d %s\",\n      response.status,\n      response.statusText\n    );\n    define(this.request, \"status\", response.status);\n    define(this.request, \"statusText\", response.statusText);\n    define(this.request, \"responseURL\", this.url.href);\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args) => {\n        this.logger.info(\"getResponseHeader\", args[0]);\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info(\"headers not received yet, returning null\");\n          return null;\n        }\n        const headerValue = response.headers.get(args[0]);\n        this.logger.info(\n          'resolved response header \"%s\" to',\n          args[0],\n          headerValue\n        );\n        return headerValue;\n      }\n    });\n    this.request.getAllResponseHeaders = new Proxy(\n      this.request.getAllResponseHeaders,\n      {\n        apply: () => {\n          this.logger.info(\"getAllResponseHeaders\");\n          if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n            this.logger.info(\"headers not received yet, returning empty string\");\n            return \"\";\n          }\n          const headersList = Array.from(response.headers.entries());\n          const allHeaders = headersList.map(([headerName, headerValue]) => {\n            return `${headerName}: ${headerValue}`;\n          }).join(\"\\r\\n\");\n          this.logger.info(\"resolved all response headers to\", allHeaders);\n          return allHeaders;\n        }\n      }\n    );\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML\n      }\n    });\n    const totalResponseBodyLength = await getBodyByteLength(response.clone());\n    this.logger.info(\"calculated response body length\", totalResponseBodyLength);\n    this.trigger(\"loadstart\", this.request, {\n      loaded: 0,\n      total: totalResponseBodyLength\n    });\n    this.setReadyState(this.request.HEADERS_RECEIVED);\n    this.setReadyState(this.request.LOADING);\n    const finalizeResponse = () => {\n      this.logger.info(\"finalizing the mocked response...\");\n      this.setReadyState(this.request.DONE);\n      this.trigger(\"load\", this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength\n      });\n      this.trigger(\"loadend\", this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength\n      });\n    };\n    if (response.body) {\n      this.logger.info(\"mocked response has body, streaming...\");\n      const reader = response.body.getReader();\n      const readNextResponseBodyChunk = async () => {\n        const { value, done } = await reader.read();\n        if (done) {\n          this.logger.info(\"response body stream done!\");\n          finalizeResponse();\n          return;\n        }\n        if (value) {\n          this.logger.info(\"read response body chunk:\", value);\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value);\n          this.trigger(\"progress\", this.request, {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength\n          });\n        }\n        readNextResponseBodyChunk();\n      };\n      readNextResponseBodyChunk();\n    } else {\n      finalizeResponse();\n    }\n  }\n  responseBufferToText() {\n    return decodeBuffer(this.responseBuffer);\n  }\n  get response() {\n    this.logger.info(\n      \"getResponse (responseType: %s)\",\n      this.request.responseType\n    );\n    if (this.request.readyState !== this.request.DONE) {\n      return null;\n    }\n    switch (this.request.responseType) {\n      case \"json\": {\n        const responseJson = parseJson(this.responseBufferToText());\n        this.logger.info(\"resolved response JSON\", responseJson);\n        return responseJson;\n      }\n      case \"arraybuffer\": {\n        const arrayBuffer = toArrayBuffer(this.responseBuffer);\n        this.logger.info(\"resolved response ArrayBuffer\", arrayBuffer);\n        return arrayBuffer;\n      }\n      case \"blob\": {\n        const mimeType = this.request.getResponseHeader(\"Content-Type\") || \"text/plain\";\n        const responseBlob = new Blob([this.responseBufferToText()], {\n          type: mimeType\n        });\n        this.logger.info(\n          \"resolved response Blob (mime type: %s)\",\n          responseBlob,\n          mimeType\n        );\n        return responseBlob;\n      }\n      default: {\n        const responseText = this.responseBufferToText();\n        this.logger.info(\n          'resolving \"%s\" response type as text',\n          this.request.responseType,\n          responseText\n        );\n        return responseText;\n      }\n    }\n  }\n  get responseText() {\n    invariant(\n      this.request.responseType === \"\" || this.request.responseType === \"text\",\n      \"InvalidStateError: The object is in invalid state.\"\n    );\n    if (this.request.readyState !== this.request.LOADING && this.request.readyState !== this.request.DONE) {\n      return \"\";\n    }\n    const responseText = this.responseBufferToText();\n    this.logger.info('getResponseText: \"%s\"', responseText);\n    return responseText;\n  }\n  get responseXML() {\n    invariant(\n      this.request.responseType === \"\" || this.request.responseType === \"document\",\n      \"InvalidStateError: The object is in invalid state.\"\n    );\n    if (this.request.readyState !== this.request.DONE) {\n      return null;\n    }\n    const contentType = this.request.getResponseHeader(\"Content-Type\") || \"\";\n    if (typeof DOMParser === \"undefined\") {\n      console.warn(\n        \"Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.\"\n      );\n      return null;\n    }\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(\n        this.responseBufferToText(),\n        contentType\n      );\n    }\n    return null;\n  }\n  errorWith(error2) {\n    this[kIsRequestHandled] = true;\n    this.logger.info(\"responding with an error\");\n    this.setReadyState(this.request.DONE);\n    this.trigger(\"error\", this.request);\n    this.trigger(\"loadend\", this.request);\n  }\n  /**\n   * Transitions this request's `readyState` to the given one.\n   */\n  setReadyState(nextReadyState) {\n    this.logger.info(\n      \"setReadyState: %d -> %d\",\n      this.request.readyState,\n      nextReadyState\n    );\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info(\"ready state identical, skipping transition...\");\n      return;\n    }\n    define(this.request, \"readyState\", nextReadyState);\n    this.logger.info(\"set readyState to: %d\", nextReadyState);\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggerring \"readystatechange\" event...');\n      this.trigger(\"readystatechange\", this.request);\n    }\n  }\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n  trigger(eventName, target, options) {\n    const callback = target[`on${eventName}`];\n    const event = createEvent(target, eventName, options);\n    this.logger.info('trigger \"%s\"', eventName, options || \"\");\n    if (typeof callback === \"function\") {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName);\n      callback.call(target, event);\n    }\n    const events = target instanceof XMLHttpRequestUpload ? this.uploadEvents : this.events;\n    for (const [registeredEventName, listeners] of events) {\n      if (registeredEventName === eventName) {\n        this.logger.info(\n          'found %d listener(s) for \"%s\" event, calling...',\n          listeners.length,\n          eventName\n        );\n        listeners.forEach((listener) => listener.call(target, event));\n      }\n    }\n  }\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n  toFetchApiRequest(body) {\n    this.logger.info(\"converting request to a Fetch API Request...\");\n    const resolvedBody = body instanceof Document ? body.documentElement.innerText : body;\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? \"include\" : \"same-origin\",\n      body: [\"GET\", \"HEAD\"].includes(this.method.toUpperCase()) ? null : resolvedBody\n    });\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case \"append\":\n          case \"set\": {\n            const [headerName, headerValue] = args;\n            this.request.setRequestHeader(headerName, headerValue);\n            break;\n          }\n          case \"delete\": {\n            const [headerName] = args;\n            console.warn(\n              `XMLHttpRequest: Cannot remove a \"${headerName}\" header from the Fetch API representation of the \"${fetchRequest.method} ${fetchRequest.url}\" request. XMLHttpRequest headers cannot be removed.`\n            );\n            break;\n          }\n        }\n        return invoke();\n      }\n    });\n    define(fetchRequest, \"headers\", proxyHeaders);\n    this.logger.info(\"converted request to a Fetch API Request!\", fetchRequest);\n    return fetchRequest;\n  }\n};\nfunction toAbsoluteUrl(url) {\n  if (typeof location === \"undefined\") {\n    return new URL(url);\n  }\n  return new URL(url.toString(), location.href);\n}\nfunction define(target, property, value) {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value\n  });\n}\nfunction createXMLHttpRequestProxy({\n  emitter,\n  logger\n}) {\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info(\"constructed new XMLHttpRequest\");\n      const originalRequest = Reflect.construct(\n        target,\n        args,\n        newTarget\n      );\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(\n        target.prototype\n      );\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(\n          originalRequest,\n          propertyName,\n          prototypeDescriptors[propertyName]\n        );\n      }\n      const xhrRequestController = new XMLHttpRequestController(\n        originalRequest,\n        logger\n      );\n      xhrRequestController.onRequest = async function({ request, requestId }) {\n        const controller = new RequestController(request);\n        this.logger.info(\"awaiting mocked response...\");\n        this.logger.info(\n          'emitting the \"request\" event for %s listener(s)...',\n          emitter.listenerCount(\"request\")\n        );\n        const isRequestHandled = await handleRequest2({\n          request,\n          requestId,\n          controller,\n          emitter,\n          onResponse: async (response) => {\n            await this.respondWith(response);\n          },\n          onRequestError: () => {\n            this.errorWith(new TypeError(\"Network error\"));\n          },\n          onError: (error2) => {\n            this.logger.info(\"request errored!\", { error: error2 });\n            if (error2 instanceof Error) {\n              this.errorWith(error2);\n            }\n          }\n        });\n        if (!isRequestHandled) {\n          this.logger.info(\n            \"no mocked response received, performing request as-is...\"\n          );\n        }\n      };\n      xhrRequestController.onResponse = async function({\n        response,\n        isMockedResponse,\n        request,\n        requestId\n      }) {\n        this.logger.info(\n          'emitting the \"response\" event for %s listener(s)...',\n          emitter.listenerCount(\"response\")\n        );\n        emitter.emit(\"response\", {\n          response,\n          isMockedResponse,\n          request,\n          requestId\n        });\n      };\n      return xhrRequestController.request;\n    }\n  });\n  return XMLHttpRequestProxy;\n}\nvar _XMLHttpRequestInterceptor = class extends Interceptor {\n  constructor() {\n    super(_XMLHttpRequestInterceptor.interceptorSymbol);\n  }\n  checkEnvironment() {\n    return hasConfigurableGlobal(\"XMLHttpRequest\");\n  }\n  setup() {\n    const logger = this.logger.extend(\"setup\");\n    logger.info('patching \"XMLHttpRequest\" module...');\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest;\n    invariant(\n      !PureXMLHttpRequest[IS_PATCHED_MODULE],\n      'Failed to patch the \"XMLHttpRequest\" module: already patched.'\n    );\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger\n    });\n    logger.info(\n      'native \"XMLHttpRequest\" module patched!',\n      globalThis.XMLHttpRequest.name\n    );\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: void 0\n      });\n      globalThis.XMLHttpRequest = PureXMLHttpRequest;\n      logger.info(\n        'native \"XMLHttpRequest\" module restored!',\n        globalThis.XMLHttpRequest.name\n      );\n    });\n  }\n};\nvar XMLHttpRequestInterceptor = _XMLHttpRequestInterceptor;\nXMLHttpRequestInterceptor.interceptorSymbol = Symbol(\"xhr\");\n\n// src/browser/setupWorker/start/createFallbackRequestListener.ts\nvar import_handleRequest2 = __webpack_require__(/*! ../core/utils/handleRequest.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/handleRequest.js\");\nvar import_isHandlerKind2 = __webpack_require__(/*! ../core/utils/internal/isHandlerKind.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/isHandlerKind.js\");\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", async ({ request, requestId, controller }) => {\n    const requestCloneForLogs = request.clone();\n    const response = await (0, import_handleRequest2.handleRequest)(\n      request,\n      requestId,\n      context.getRequestHandlers().filter((0, import_isHandlerKind2.isHandlerKind)(\"RequestHandler\")),\n      options,\n      context.emitter,\n      {\n        onMockedResponse(_, { handler, parsedResult }) {\n          if (!options.quiet) {\n            context.emitter.once(\"response:mocked\", ({ response: response2 }) => {\n              handler.log({\n                request: requestCloneForLogs,\n                response: response2,\n                parsedResult\n              });\n            });\n          }\n        }\n      }\n    );\n    if (response) {\n      controller.respondWith(response);\n    }\n  });\n  interceptor.on(\n    \"response\",\n    ({ response, isMockedResponse, request, requestId }) => {\n      context.emitter.emit(\n        isMockedResponse ? \"response:mocked\" : \"response:bypass\",\n        {\n          response,\n          request,\n          requestId\n        }\n      );\n    }\n  );\n  interceptor.apply();\n  return interceptor;\n}\n\n// src/browser/setupWorker/start/createFallbackStart.ts\nfunction createFallbackStart(context) {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options\n    );\n    printStartMessage({\n      message: \"Mocking enabled (fallback mode).\",\n      quiet: options.quiet\n    });\n    return void 0;\n  };\n}\n\n// src/browser/setupWorker/stop/createFallbackStop.ts\nfunction createFallbackStop(context) {\n  return function stop() {\n    context.fallbackInterceptor?.dispose();\n    printStopMessage({ quiet: context.startOptions?.quiet });\n  };\n}\n\n// src/browser/setupWorker/setupWorker.ts\nvar import_devUtils10 = __webpack_require__(/*! ../core/utils/internal/devUtils.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/devUtils.js\");\nvar import_SetupApi = __webpack_require__(/*! ../core/SetupApi.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/SetupApi.js\");\nvar import_mergeRight2 = __webpack_require__(/*! ../core/utils/internal/mergeRight.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/mergeRight.js\");\n\n// src/browser/utils/supportsReadableStreamTransfer.ts\nfunction supportsReadableStreamTransfer() {\n  try {\n    const stream = new ReadableStream({\n      start: (controller) => controller.close()\n    });\n    const message = new MessageChannel();\n    message.port1.postMessage(stream, [stream]);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// src/browser/setupWorker/setupWorker.ts\nvar import_webSocketInterceptor = __webpack_require__(/*! ../core/ws/webSocketInterceptor.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/webSocketInterceptor.js\");\nvar import_handleWebSocketEvent = __webpack_require__(/*! ../core/ws/handleWebSocketEvent.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/handleWebSocketEvent.js\");\nvar import_attachWebSocketLogger = __webpack_require__(/*! ../core/ws/utils/attachWebSocketLogger.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/attachWebSocketLogger.js\");\nvar SetupWorkerApi = class extends import_SetupApi.SetupApi {\n  context;\n  startHandler = null;\n  stopHandler = null;\n  listeners;\n  constructor(...handlers) {\n    super(...handlers);\n    invariant(\n      !isNodeProcess(),\n      import_devUtils10.devUtils.formatMessage(\n        \"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"\n      )\n    );\n    this.listeners = [];\n    this.context = this.createWorkerContext();\n  }\n  createWorkerContext() {\n    const context = {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null,\n      worker: null,\n      getRequestHandlers: () => {\n        return this.handlersController.currentHandlers();\n      },\n      registration: null,\n      requests: /* @__PURE__ */ new Map(),\n      emitter: this.emitter,\n      workerChannel: {\n        on: (eventType, callback) => {\n          this.context.events.addListener(navigator.serviceWorker, \"message\", (event) => {\n            if (event.source !== this.context.worker) {\n              return;\n            }\n            const message = event.data;\n            if (!message) {\n              return;\n            }\n            if (message.type === eventType) {\n              callback(event, message);\n            }\n          });\n        },\n        send: (type) => {\n          this.context.worker?.postMessage(type);\n        }\n      },\n      events: {\n        addListener: (target, eventType, callback) => {\n          target.addEventListener(eventType, callback);\n          this.listeners.push({\n            eventType,\n            target,\n            callback\n          });\n          return () => {\n            target.removeEventListener(eventType, callback);\n          };\n        },\n        removeAllListeners: () => {\n          for (const { target, eventType, callback } of this.listeners) {\n            target.removeEventListener(eventType, callback);\n          }\n          this.listeners = [];\n        },\n        once: (eventType) => {\n          const bindings = [];\n          return new Promise((resolve, reject) => {\n            const handleIncomingMessage = (event) => {\n              try {\n                const message = event.data;\n                if (message.type === eventType) {\n                  resolve(message);\n                }\n              } catch (error2) {\n                reject(error2);\n              }\n            };\n            bindings.push(\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                \"message\",\n                handleIncomingMessage\n              ),\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                \"messageerror\",\n                reject\n              )\n            );\n          }).finally(() => {\n            bindings.forEach((unbind) => unbind());\n          });\n        }\n      },\n      supports: {\n        serviceWorkerApi: !(\"serviceWorker\" in navigator) || location.protocol === \"file:\",\n        readableStreamTransfer: supportsReadableStreamTransfer()\n      }\n    };\n    this.startHandler = context.supports.serviceWorkerApi ? createFallbackStart(context) : createStartHandler(context);\n    this.stopHandler = context.supports.serviceWorkerApi ? createFallbackStop(context) : createStop(context);\n    return context;\n  }\n  async start(options = {}) {\n    if (options.waitUntilReady === true) {\n      import_devUtils10.devUtils.warn(\n        'The \"waitUntilReady\" option has been deprecated. Please remove it from this \"worker.start()\" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.'\n      );\n    }\n    this.context.startOptions = (0, import_mergeRight2.mergeRight)(\n      DEFAULT_START_OPTIONS,\n      options\n    );\n    (0, import_handleWebSocketEvent.handleWebSocketEvent)({\n      getUnhandledRequestStrategy: () => {\n        return this.context.startOptions.onUnhandledRequest;\n      },\n      getHandlers: () => {\n        return this.handlersController.currentHandlers();\n      },\n      onMockedConnection: (connection) => {\n        if (!this.context.startOptions.quiet) {\n          (0, import_attachWebSocketLogger.attachWebSocketLogger)(connection);\n        }\n      },\n      onPassthroughConnection() {\n      }\n    });\n    import_webSocketInterceptor.webSocketInterceptor.apply();\n    this.subscriptions.push(() => {\n      import_webSocketInterceptor.webSocketInterceptor.dispose();\n    });\n    return await this.startHandler(this.context.startOptions, options);\n  }\n  stop() {\n    super.dispose();\n    this.context.events.removeAllListeners();\n    this.context.emitter.removeAllListeners();\n    this.stopHandler();\n  }\n};\nfunction setupWorker(...handlers) {\n  return new SetupWorkerApi(...handlers);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvYnJvd3Nlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkNBQTZDO0FBQ3pFO0FBQ0EsaURBQWlELElBQUk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU8sYUFBYSxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJLQUFvQzs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2IsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsMktBQW9DOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLGNBQWMsbUJBQW1CLGtCQUFrQjs7QUFFcko7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsMktBQW9DOztBQUVuRTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJLQUFvQztBQUNuRSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaURBQWlEO0FBQzFELHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CLElBQUksVUFBVTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSw0QkFBNEIsbUJBQU8sQ0FBQywyS0FBb0M7QUFDeEUsMkJBQTJCLG1CQUFPLENBQUMsbUtBQWdDO0FBQ25FLHVCQUF1QixtQkFBTyxDQUFDLDJLQUFvQztBQUNuRSw0QkFBNEIsbUJBQU8sQ0FBQyxxS0FBaUM7QUFDckUsMkJBQTJCLG1CQUFPLENBQUMscUxBQXlDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLDZDQUE2Qyx1QkFBdUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJLQUFvQztBQUNuRTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQSxtR0FBbUcsdUJBQXVCOztBQUUxSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtDQUFrQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVUsR0FBRyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVLEVBQUUsUUFBUSx1QkFBdUIsS0FBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLE1BQU0sR0FBRyw0QkFBNEI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPLEVBQUUsaUJBQWlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEMsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJLQUFvQztBQUNuRTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsbUJBQW1COztBQUVoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQywyS0FBb0M7O0FBRW5FO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsMktBQW9DO0FBQ25FLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkRBQTZEO0FBQ3RFLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xELHVCQUF1QixvQ0FBb0M7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLCtLQUFzQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlDQUF5QztBQUMxRCxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDZCQUE2QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxhQUFhO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxREFBcUQsVUFBVTtBQUMvRDtBQUNBLFNBQVM7QUFDVDtBQUNBLDBEQUEwRCxlQUFlO0FBQ3pFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUF3RDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWEsRUFBRSxjQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXLElBQUksWUFBWTtBQUNqRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVyxxREFBcUQscUJBQXFCLEVBQUUsaUJBQWlCO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG9CQUFvQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsbURBQW1ELGVBQWU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixtQkFBTyxDQUFDLG1LQUFnQztBQUNwRSw0QkFBNEIsbUJBQU8sQ0FBQyxxTEFBeUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDLGdDQUFnQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBLHVEQUF1RCxxQkFBcUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxPQUFPLGdEQUFnRDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQywyS0FBb0M7QUFDcEUsc0JBQXNCLG1CQUFPLENBQUMsNklBQXFCO0FBQ25ELHlCQUF5QixtQkFBTyxDQUFDLCtLQUFzQzs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsMktBQW9DO0FBQzlFLGtDQUFrQyxtQkFBTyxDQUFDLDJLQUFvQztBQUM5RSxtQ0FBbUMsbUJBQU8sQ0FBQyx5TEFBMkM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUIsOEJBQThCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2h5ZW9uam9uZy9Eb2N1bWVudHMvR2l0SHViL21zdy1zY2VuYXJpb3Mvbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvYnJvd3Nlci9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9icm93c2VyL2luZGV4LnRzXG52YXIgYnJvd3Nlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChicm93c2VyX2V4cG9ydHMsIHtcbiAgU2V0dXBXb3JrZXJBcGk6ICgpID0+IFNldHVwV29ya2VyQXBpLFxuICBzZXR1cFdvcmtlcjogKCkgPT4gc2V0dXBXb3JrZXJcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoYnJvd3Nlcl9leHBvcnRzKTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL291dHZhcmlhbnRAMS40LjMvbm9kZV9tb2R1bGVzL291dHZhcmlhbnQvbGliL2luZGV4Lm1qc1xudmFyIFBPU0lUSU9OQUxTX0VYUCA9IC8oJT8pKCUoW3NkaWpvXSkpL2c7XG5mdW5jdGlvbiBzZXJpYWxpemVQb3NpdGlvbmFsKHBvc2l0aW9uYWwsIGZsYWcpIHtcbiAgc3dpdGNoIChmbGFnKSB7XG4gICAgY2FzZSBcInNcIjpcbiAgICAgIHJldHVybiBwb3NpdGlvbmFsO1xuICAgIGNhc2UgXCJkXCI6XG4gICAgY2FzZSBcImlcIjpcbiAgICAgIHJldHVybiBOdW1iZXIocG9zaXRpb25hbCk7XG4gICAgY2FzZSBcImpcIjpcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwb3NpdGlvbmFsKTtcbiAgICBjYXNlIFwib1wiOiB7XG4gICAgICBpZiAodHlwZW9mIHBvc2l0aW9uYWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uYWw7XG4gICAgICB9XG4gICAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkocG9zaXRpb25hbCk7XG4gICAgICBpZiAoanNvbiA9PT0gXCJ7fVwiIHx8IGpzb24gPT09IFwiW11cIiB8fCAvXlxcW29iamVjdCAuKz9cXF0kLy50ZXN0KGpzb24pKSB7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmb3JtYXQobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpIHtcbiAgaWYgKHBvc2l0aW9uYWxzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGxldCBwb3NpdGlvbmFsSW5kZXggPSAwO1xuICBsZXQgZm9ybWF0dGVkTWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICBQT1NJVElPTkFMU19FWFAsXG4gICAgKG1hdGNoLCBpc0VzY2FwZWQsIF8sIGZsYWcpID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uYWwgPSBwb3NpdGlvbmFsc1twb3NpdGlvbmFsSW5kZXhdO1xuICAgICAgY29uc3QgdmFsdWUgPSBzZXJpYWxpemVQb3NpdGlvbmFsKHBvc2l0aW9uYWwsIGZsYWcpO1xuICAgICAgaWYgKCFpc0VzY2FwZWQpIHtcbiAgICAgICAgcG9zaXRpb25hbEluZGV4Kys7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICk7XG4gIGlmIChwb3NpdGlvbmFsSW5kZXggPCBwb3NpdGlvbmFscy5sZW5ndGgpIHtcbiAgICBmb3JtYXR0ZWRNZXNzYWdlICs9IGAgJHtwb3NpdGlvbmFscy5zbGljZShwb3NpdGlvbmFsSW5kZXgpLmpvaW4oXCIgXCIpfWA7XG4gIH1cbiAgZm9ybWF0dGVkTWVzc2FnZSA9IGZvcm1hdHRlZE1lc3NhZ2UucmVwbGFjZSgvJXsyLDJ9L2csIFwiJVwiKTtcbiAgcmV0dXJuIGZvcm1hdHRlZE1lc3NhZ2U7XG59XG52YXIgU1RBQ0tfRlJBTUVTX1RPX0lHTk9SRSA9IDI7XG5mdW5jdGlvbiBjbGVhbkVycm9yU3RhY2soZXJyb3IyKSB7XG4gIGlmICghZXJyb3IyLnN0YWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5leHRTdGFjayA9IGVycm9yMi5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgbmV4dFN0YWNrLnNwbGljZSgxLCBTVEFDS19GUkFNRVNfVE9fSUdOT1JFKTtcbiAgZXJyb3IyLnN0YWNrID0gbmV4dFN0YWNrLmpvaW4oXCJcXG5cIik7XG59XG52YXIgSW52YXJpYW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiO1xuICAgIHRoaXMubWVzc2FnZSA9IGZvcm1hdChtZXNzYWdlLCAuLi5wb3NpdGlvbmFscyk7XG4gICAgY2xlYW5FcnJvclN0YWNrKHRoaXMpO1xuICB9XG59O1xudmFyIGludmFyaWFudCA9IChwcmVkaWNhdGUsIG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSA9PiB7XG4gIGlmICghcHJlZGljYXRlKSB7XG4gICAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKTtcbiAgfVxufTtcbmludmFyaWFudC5hcyA9IChFcnJvckNvbnN0cnVjdG9yLCBwcmVkaWNhdGUsIG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSA9PiB7XG4gIGlmICghcHJlZGljYXRlKSB7XG4gICAgY29uc3QgZm9ybWF0TWVzc2FnZSA9IHBvc2l0aW9uYWxzLmxlbmd0aCA9PT0gMCA/IG1lc3NhZ2UgOiBmb3JtYXQobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpO1xuICAgIGxldCBlcnJvcjI7XG4gICAgdHJ5IHtcbiAgICAgIGVycm9yMiA9IFJlZmxlY3QuY29uc3RydWN0KEVycm9yQ29uc3RydWN0b3IsIFtcbiAgICAgICAgZm9ybWF0TWVzc2FnZVxuICAgICAgXSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJvcjIgPSBFcnJvckNvbnN0cnVjdG9yKGZvcm1hdE1lc3NhZ2UpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjI7XG4gIH1cbn07XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9pcy1ub2RlLXByb2Nlc3NAMS4yLjAvbm9kZV9tb2R1bGVzL2lzLW5vZGUtcHJvY2Vzcy9saWIvaW5kZXgubWpzXG5mdW5jdGlvbiBpc05vZGVQcm9jZXNzKCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgdHlwZSA9IHByb2Nlc3MudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gXCJyZW5kZXJlclwiIHx8IHR5cGUgPT09IFwid29ya2VyXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICEhKHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9icm93c2VyL3NldHVwV29ya2VyL3N0YXJ0L2NyZWF0ZVN0YXJ0SGFuZGxlci50c1xudmFyIGltcG9ydF9kZXZVdGlsczcgPSByZXF1aXJlKFwiLi4vY29yZS91dGlscy9pbnRlcm5hbC9kZXZVdGlscy5qc1wiKTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVuLWRyYWZ0K3VudGlsQDIuMS4wL25vZGVfbW9kdWxlcy9Ab3Blbi1kcmFmdC91bnRpbC9saWIvaW5kZXgubWpzXG52YXIgdW50aWwgPSBhc3luYyAocHJvbWlzZSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwcm9taXNlKCkuY2F0Y2goKGVycm9yMikgPT4ge1xuICAgICAgdGhyb3cgZXJyb3IyO1xuICAgIH0pO1xuICAgIHJldHVybiB7IGVycm9yOiBudWxsLCBkYXRhIH07XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIHJldHVybiB7IGVycm9yOiBlcnJvcjIsIGRhdGE6IG51bGwgfTtcbiAgfVxufTtcblxuLy8gc3JjL2Jyb3dzZXIvc2V0dXBXb3JrZXIvc3RhcnQvdXRpbHMvZ2V0V29ya2VySW5zdGFuY2UudHNcbnZhciBpbXBvcnRfZGV2VXRpbHMgPSByZXF1aXJlKFwiLi4vY29yZS91dGlscy9pbnRlcm5hbC9kZXZVdGlscy5qc1wiKTtcblxuLy8gc3JjL2Jyb3dzZXIvdXRpbHMvZ2V0QWJzb2x1dGVXb3JrZXJVcmwudHNcbmZ1bmN0aW9uIGdldEFic29sdXRlV29ya2VyVXJsKHdvcmtlclVybCkge1xuICByZXR1cm4gbmV3IFVSTCh3b3JrZXJVcmwsIGxvY2F0aW9uLmhyZWYpLmhyZWY7XG59XG5cbi8vIHNyYy9icm93c2VyL3NldHVwV29ya2VyL3N0YXJ0L3V0aWxzL2dldFdvcmtlckJ5UmVnaXN0cmF0aW9uLnRzXG5mdW5jdGlvbiBnZXRXb3JrZXJCeVJlZ2lzdHJhdGlvbihyZWdpc3RyYXRpb24sIGFic29sdXRlV29ya2VyVXJsLCBmaW5kV29ya2VyKSB7XG4gIGNvbnN0IGFsbFN0YXRlcyA9IFtcbiAgICByZWdpc3RyYXRpb24uYWN0aXZlLFxuICAgIHJlZ2lzdHJhdGlvbi5pbnN0YWxsaW5nLFxuICAgIHJlZ2lzdHJhdGlvbi53YWl0aW5nXG4gIF07XG4gIGNvbnN0IHJlbGV2YW50U3RhdGVzID0gYWxsU3RhdGVzLmZpbHRlcigoc3RhdGUpID0+IHtcbiAgICByZXR1cm4gc3RhdGUgIT0gbnVsbDtcbiAgfSk7XG4gIGNvbnN0IHdvcmtlciA9IHJlbGV2YW50U3RhdGVzLmZpbmQoKHdvcmtlcjIpID0+IHtcbiAgICByZXR1cm4gZmluZFdvcmtlcih3b3JrZXIyLnNjcmlwdFVSTCwgYWJzb2x1dGVXb3JrZXJVcmwpO1xuICB9KTtcbiAgcmV0dXJuIHdvcmtlciB8fCBudWxsO1xufVxuXG4vLyBzcmMvYnJvd3Nlci9zZXR1cFdvcmtlci9zdGFydC91dGlscy9nZXRXb3JrZXJJbnN0YW5jZS50c1xudmFyIGdldFdvcmtlckluc3RhbmNlID0gYXN5bmMgKHVybCwgb3B0aW9ucyA9IHt9LCBmaW5kV29ya2VyKSA9PiB7XG4gIGNvbnN0IGFic29sdXRlV29ya2VyVXJsID0gZ2V0QWJzb2x1dGVXb3JrZXJVcmwodXJsKTtcbiAgY29uc3QgbW9ja1JlZ2lzdHJhdGlvbnMgPSBhd2FpdCBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5nZXRSZWdpc3RyYXRpb25zKCkudGhlbihcbiAgICAocmVnaXN0cmF0aW9ucykgPT4gcmVnaXN0cmF0aW9ucy5maWx0ZXIoXG4gICAgICAocmVnaXN0cmF0aW9uKSA9PiBnZXRXb3JrZXJCeVJlZ2lzdHJhdGlvbihyZWdpc3RyYXRpb24sIGFic29sdXRlV29ya2VyVXJsLCBmaW5kV29ya2VyKVxuICAgIClcbiAgKTtcbiAgaWYgKCFuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyICYmIG1vY2tSZWdpc3RyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxuICBjb25zdCBbZXhpc3RpbmdSZWdpc3RyYXRpb25dID0gbW9ja1JlZ2lzdHJhdGlvbnM7XG4gIGlmIChleGlzdGluZ1JlZ2lzdHJhdGlvbikge1xuICAgIGV4aXN0aW5nUmVnaXN0cmF0aW9uLnVwZGF0ZSgpO1xuICAgIHJldHVybiBbXG4gICAgICBnZXRXb3JrZXJCeVJlZ2lzdHJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdSZWdpc3RyYXRpb24sXG4gICAgICAgIGFic29sdXRlV29ya2VyVXJsLFxuICAgICAgICBmaW5kV29ya2VyXG4gICAgICApLFxuICAgICAgZXhpc3RpbmdSZWdpc3RyYXRpb25cbiAgICBdO1xuICB9XG4gIGNvbnN0IHJlZ2lzdHJhdGlvblJlc3VsdCA9IGF3YWl0IHVudGlsKFxuICAgIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IGF3YWl0IG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKHVybCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAvLyBDb21wYXJlIGV4aXN0aW5nIHdvcmtlciByZWdpc3RyYXRpb24gYnkgaXRzIHdvcmtlciBVUkwsXG4gICAgICAgIC8vIHRvIHByZXZlbnQgaXJyZWxldmFudCB3b3JrZXJzIHRvIHJlc29sdmUgaGVyZSAoc3VjaCBhcyBDb2Rlc2FuZGJveCB3b3JrZXIpLlxuICAgICAgICBnZXRXb3JrZXJCeVJlZ2lzdHJhdGlvbihyZWdpc3RyYXRpb24sIGFic29sdXRlV29ya2VyVXJsLCBmaW5kV29ya2VyKSxcbiAgICAgICAgcmVnaXN0cmF0aW9uXG4gICAgICBdO1xuICAgIH1cbiAgKTtcbiAgaWYgKHJlZ2lzdHJhdGlvblJlc3VsdC5lcnJvcikge1xuICAgIGNvbnN0IGlzV29ya2VyTWlzc2luZyA9IHJlZ2lzdHJhdGlvblJlc3VsdC5lcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiKDQwNClcIik7XG4gICAgaWYgKGlzV29ya2VyTWlzc2luZykge1xuICAgICAgY29uc3Qgc2NvcGVVcmwgPSBuZXcgVVJMKG9wdGlvbnM/LnNjb3BlIHx8IFwiL1wiLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgaW1wb3J0X2RldlV0aWxzLmRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoYEZhaWxlZCB0byByZWdpc3RlciBhIFNlcnZpY2UgV29ya2VyIGZvciBzY29wZSAoJyR7c2NvcGVVcmwuaHJlZn0nKSB3aXRoIHNjcmlwdCAoJyR7YWJzb2x1dGVXb3JrZXJVcmx9Jyk6IFNlcnZpY2UgV29ya2VyIHNjcmlwdCBkb2VzIG5vdCBleGlzdCBhdCB0aGUgZ2l2ZW4gcGF0aC5cblxuRGlkIHlvdSBmb3JnZXQgdG8gcnVuIFwibnB4IG1zdyBpbml0IDxQVUJMSUNfRElSPlwiP1xuXG5MZWFybiBtb3JlIGFib3V0IGNyZWF0aW5nIHRoZSBTZXJ2aWNlIFdvcmtlciBzY3JpcHQ6IGh0dHBzOi8vbXN3anMuaW8vZG9jcy9jbGkvaW5pdGApXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBpbXBvcnRfZGV2VXRpbHMuZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVnaXN0ZXIgdGhlIFNlcnZpY2UgV29ya2VyOlxcblxcbiVzXCIsXG4gICAgICAgIHJlZ2lzdHJhdGlvblJlc3VsdC5lcnJvci5tZXNzYWdlXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVnaXN0cmF0aW9uUmVzdWx0LmRhdGE7XG59O1xuXG4vLyBzcmMvYnJvd3Nlci9zZXR1cFdvcmtlci9zdGFydC91dGlscy9lbmFibGVNb2NraW5nLnRzXG52YXIgaW1wb3J0X2RldlV0aWxzMyA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxzL2ludGVybmFsL2RldlV0aWxzLmpzXCIpO1xuXG4vLyBzcmMvYnJvd3Nlci9zZXR1cFdvcmtlci9zdGFydC91dGlscy9wcmludFN0YXJ0TWVzc2FnZS50c1xudmFyIGltcG9ydF9kZXZVdGlsczIgPSByZXF1aXJlKFwiLi4vY29yZS91dGlscy9pbnRlcm5hbC9kZXZVdGlscy5qc1wiKTtcbmZ1bmN0aW9uIHByaW50U3RhcnRNZXNzYWdlKGFyZ3MgPSB7fSkge1xuICBpZiAoYXJncy5xdWlldCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBtZXNzYWdlID0gYXJncy5tZXNzYWdlIHx8IFwiTW9ja2luZyBlbmFibGVkLlwiO1xuICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgIGAlYyR7aW1wb3J0X2RldlV0aWxzMi5kZXZVdGlscy5mb3JtYXRNZXNzYWdlKG1lc3NhZ2UpfWAsXG4gICAgXCJjb2xvcjpvcmFuZ2VyZWQ7Zm9udC13ZWlnaHQ6Ym9sZDtcIlxuICApO1xuICBjb25zb2xlLmxvZyhcbiAgICBcIiVjRG9jdW1lbnRhdGlvbjogJWNodHRwczovL21zd2pzLmlvL2RvY3NcIixcbiAgICBcImZvbnQtd2VpZ2h0OmJvbGRcIixcbiAgICBcImZvbnQtd2VpZ2h0Om5vcm1hbFwiXG4gICk7XG4gIGNvbnNvbGUubG9nKFwiRm91bmQgYW4gaXNzdWU/IGh0dHBzOi8vZ2l0aHViLmNvbS9tc3dqcy9tc3cvaXNzdWVzXCIpO1xuICBpZiAoYXJncy53b3JrZXJVcmwpIHtcbiAgICBjb25zb2xlLmxvZyhcIldvcmtlciBzY3JpcHQgVVJMOlwiLCBhcmdzLndvcmtlclVybCk7XG4gIH1cbiAgaWYgKGFyZ3Mud29ya2VyU2NvcGUpIHtcbiAgICBjb25zb2xlLmxvZyhcIldvcmtlciBzY29wZTpcIiwgYXJncy53b3JrZXJTY29wZSk7XG4gIH1cbiAgaWYgKGFyZ3MuY2xpZW50KSB7XG4gICAgY29uc29sZS5sb2coXCJDbGllbnQgSUQ6ICVzICglcylcIiwgYXJncy5jbGllbnQuaWQsIGFyZ3MuY2xpZW50LmZyYW1lVHlwZSk7XG4gIH1cbiAgY29uc29sZS5ncm91cEVuZCgpO1xufVxuXG4vLyBzcmMvYnJvd3Nlci9zZXR1cFdvcmtlci9zdGFydC91dGlscy9lbmFibGVNb2NraW5nLnRzXG5hc3luYyBmdW5jdGlvbiBlbmFibGVNb2NraW5nKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgY29udGV4dC53b3JrZXJDaGFubmVsLnNlbmQoXCJNT0NLX0FDVElWQVRFXCIpO1xuICBjb25zdCB7IHBheWxvYWQgfSA9IGF3YWl0IGNvbnRleHQuZXZlbnRzLm9uY2UoXCJNT0NLSU5HX0VOQUJMRURcIik7XG4gIGlmIChjb250ZXh0LmlzTW9ja2luZ0VuYWJsZWQpIHtcbiAgICBpbXBvcnRfZGV2VXRpbHMzLmRldlV0aWxzLndhcm4oXG4gICAgICBgRm91bmQgYSByZWR1bmRhbnQgXCJ3b3JrZXIuc3RhcnQoKVwiIGNhbGwuIE5vdGUgdGhhdCBzdGFydGluZyB0aGUgd29ya2VyIHdoaWxlIG1vY2tpbmcgaXMgYWxyZWFkeSBlbmFibGVkIHdpbGwgaGF2ZSBubyBlZmZlY3QuIENvbnNpZGVyIHJlbW92aW5nIHRoaXMgXCJ3b3JrZXIuc3RhcnQoKVwiIGNhbGwuYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnRleHQuaXNNb2NraW5nRW5hYmxlZCA9IHRydWU7XG4gIHByaW50U3RhcnRNZXNzYWdlKHtcbiAgICBxdWlldDogb3B0aW9ucy5xdWlldCxcbiAgICB3b3JrZXJTY29wZTogY29udGV4dC5yZWdpc3RyYXRpb24/LnNjb3BlLFxuICAgIHdvcmtlclVybDogY29udGV4dC53b3JrZXI/LnNjcmlwdFVSTCxcbiAgICBjbGllbnQ6IHBheWxvYWQuY2xpZW50XG4gIH0pO1xufVxuXG4vLyBzcmMvYnJvd3Nlci9zZXR1cFdvcmtlci9zdGFydC91dGlscy9jcmVhdGVNZXNzYWdlQ2hhbm5lbC50c1xudmFyIFdvcmtlckNoYW5uZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICB9XG4gIHBvc3RNZXNzYWdlKGV2ZW50LCAuLi5yZXN0KSB7XG4gICAgY29uc3QgW2RhdGEsIHRyYW5zZmVyXSA9IHJlc3Q7XG4gICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKHsgdHlwZTogZXZlbnQsIGRhdGEgfSwgeyB0cmFuc2ZlciB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2Jyb3dzZXIvdXRpbHMvcHJ1bmVHZXRSZXF1ZXN0Qm9keS50c1xuZnVuY3Rpb24gcHJ1bmVHZXRSZXF1ZXN0Qm9keShyZXF1ZXN0KSB7XG4gIGlmIChbXCJIRUFEXCIsIFwiR0VUXCJdLmluY2x1ZGVzKHJlcXVlc3QubWV0aG9kKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3QuYm9keTtcbn1cblxuLy8gc3JjL2Jyb3dzZXIvdXRpbHMvcGFyc2VXb3JrZXJSZXF1ZXN0LnRzXG5mdW5jdGlvbiBwYXJzZVdvcmtlclJlcXVlc3QoaW5jb21pbmdSZXF1ZXN0KSB7XG4gIHJldHVybiBuZXcgUmVxdWVzdChpbmNvbWluZ1JlcXVlc3QudXJsLCB7XG4gICAgLi4uaW5jb21pbmdSZXF1ZXN0LFxuICAgIGJvZHk6IHBydW5lR2V0UmVxdWVzdEJvZHkoaW5jb21pbmdSZXF1ZXN0KVxuICB9KTtcbn1cblxuLy8gc3JjL2Jyb3dzZXIvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlUmVxdWVzdExpc3RlbmVyLnRzXG52YXIgaW1wb3J0X1JlcXVlc3RIYW5kbGVyID0gcmVxdWlyZShcIi4uL2NvcmUvaGFuZGxlcnMvUmVxdWVzdEhhbmRsZXIuanNcIik7XG52YXIgaW1wb3J0X2hhbmRsZVJlcXVlc3QgPSByZXF1aXJlKFwiLi4vY29yZS91dGlscy9oYW5kbGVSZXF1ZXN0LmpzXCIpO1xudmFyIGltcG9ydF9kZXZVdGlsczQgPSByZXF1aXJlKFwiLi4vY29yZS91dGlscy9pbnRlcm5hbC9kZXZVdGlscy5qc1wiKTtcbnZhciBpbXBvcnRfdG9SZXNwb25zZUluaXQgPSByZXF1aXJlKFwiLi4vY29yZS91dGlscy90b1Jlc3BvbnNlSW5pdC5qc1wiKTtcbnZhciBpbXBvcnRfaXNIYW5kbGVyS2luZCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxzL2ludGVybmFsL2lzSGFuZGxlcktpbmQuanNcIik7XG52YXIgY3JlYXRlUmVxdWVzdExpc3RlbmVyID0gKGNvbnRleHQsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGFzeW5jIChldmVudCwgbWVzc2FnZSkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2VDaGFubmVsID0gbmV3IFdvcmtlckNoYW5uZWwoZXZlbnQucG9ydHNbMF0pO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IG1lc3NhZ2UucGF5bG9hZC5pZDtcbiAgICBjb25zdCByZXF1ZXN0ID0gcGFyc2VXb3JrZXJSZXF1ZXN0KG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgY29uc3QgcmVxdWVzdENsb25lRm9yTG9ncyA9IHJlcXVlc3QuY2xvbmUoKTtcbiAgICBjb25zdCByZXF1ZXN0Q2xvbmUgPSByZXF1ZXN0LmNsb25lKCk7XG4gICAgaW1wb3J0X1JlcXVlc3RIYW5kbGVyLlJlcXVlc3RIYW5kbGVyLmNhY2hlLnNldChyZXF1ZXN0LCByZXF1ZXN0Q2xvbmUpO1xuICAgIGNvbnRleHQucmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwgcmVxdWVzdENsb25lKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgKDAsIGltcG9ydF9oYW5kbGVSZXF1ZXN0LmhhbmRsZVJlcXVlc3QpKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIGNvbnRleHQuZ2V0UmVxdWVzdEhhbmRsZXJzKCkuZmlsdGVyKCgwLCBpbXBvcnRfaXNIYW5kbGVyS2luZC5pc0hhbmRsZXJLaW5kKShcIlJlcXVlc3RIYW5kbGVyXCIpKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLFxuICAgICAgICB7XG4gICAgICAgICAgb25QYXNzdGhyb3VnaFJlc3BvbnNlKCkge1xuICAgICAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9zdE1lc3NhZ2UoXCJQQVNTVEhST1VHSFwiKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFzeW5jIG9uTW9ja2VkUmVzcG9uc2UocmVzcG9uc2UsIHsgaGFuZGxlciwgcGFyc2VkUmVzdWx0IH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ2xvbmUgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VDbG9uZUZvckxvZ3MgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VJbml0ID0gKDAsIGltcG9ydF90b1Jlc3BvbnNlSW5pdC50b1Jlc3BvbnNlSW5pdCkocmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuc3VwcG9ydHMucmVhZGFibGVTdHJlYW1UcmFuc2Zlcikge1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVN0cmVhbU9yTnVsbCA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgICAgIFwiTU9DS19SRVNQT05TRVwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlSW5pdCxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHJlc3BvbnNlU3RyZWFtT3JOdWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXNwb25zZVN0cmVhbU9yTnVsbCA/IFtyZXNwb25zZVN0cmVhbU9yTnVsbF0gOiB2b2lkIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQnVmZmVyT3JOdWxsID0gcmVzcG9uc2UuYm9keSA9PT0gbnVsbCA/IG51bGwgOiBhd2FpdCByZXNwb25zZUNsb25lLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvc3RNZXNzYWdlKFwiTU9DS19SRVNQT05TRVwiLCB7XG4gICAgICAgICAgICAgICAgLi4ucmVzcG9uc2VJbml0LFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlc3BvbnNlQnVmZmVyT3JOdWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnF1aWV0KSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci5vbmNlKFwicmVzcG9uc2U6bW9ja2VkXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmxvZyh7XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0Q2xvbmVGb3JMb2dzLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlQ2xvbmVGb3JMb2dzLFxuICAgICAgICAgICAgICAgICAgcGFyc2VkUmVzdWx0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIGlmIChlcnJvcjIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpbXBvcnRfZGV2VXRpbHM0LmRldlV0aWxzLmVycm9yKFxuICAgICAgICAgIGBVbmNhdWdodCBleGNlcHRpb24gaW4gdGhlIHJlcXVlc3QgaGFuZGxlciBmb3IgXCIlcyAlc1wiOlxuXG4lc1xuXG5UaGlzIGV4Y2VwdGlvbiBoYXMgYmVlbiBncmFjZWZ1bGx5IGhhbmRsZWQgYXMgYSA1MDAgcmVzcG9uc2UsIGhvd2V2ZXIsIGl0J3Mgc3Ryb25nbHkgcmVjb21tZW5kZWQgdG8gcmVzb2x2ZSB0aGlzIGVycm9yLCBhcyBpdCBpbmRpY2F0ZXMgYSBtaXN0YWtlIGluIHlvdXIgY29kZS4gSWYgeW91IHdpc2ggdG8gbW9jayBhbiBlcnJvciByZXNwb25zZSwgcGxlYXNlIHNlZSB0aGlzIGd1aWRlOiBodHRwczovL21zd2pzLmlvL2RvY3MvcmVjaXBlcy9tb2NraW5nLWVycm9yLXJlc3BvbnNlc2AsXG4gICAgICAgICAgcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgcmVxdWVzdC51cmwsXG4gICAgICAgICAgZXJyb3IyLnN0YWNrID8/IGVycm9yMlxuICAgICAgICApO1xuICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3N0TWVzc2FnZShcIk1PQ0tfUkVTUE9OU0VcIiwge1xuICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IFwiUmVxdWVzdCBIYW5kbGVyIEVycm9yXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG5hbWU6IGVycm9yMi5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IyLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjazogZXJyb3IyLnN0YWNrXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2Jyb3dzZXIvdXRpbHMvY2hlY2tXb3JrZXJJbnRlZ3JpdHkudHNcbnZhciBpbXBvcnRfZGV2VXRpbHM1ID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbHMvaW50ZXJuYWwvZGV2VXRpbHMuanNcIik7XG5hc3luYyBmdW5jdGlvbiBjaGVja1dvcmtlckludGVncml0eShjb250ZXh0KSB7XG4gIGNvbnRleHQud29ya2VyQ2hhbm5lbC5zZW5kKFwiSU5URUdSSVRZX0NIRUNLX1JFUVVFU1RcIik7XG4gIGNvbnN0IHsgcGF5bG9hZCB9ID0gYXdhaXQgY29udGV4dC5ldmVudHMub25jZShcIklOVEVHUklUWV9DSEVDS19SRVNQT05TRVwiKTtcbiAgaWYgKHBheWxvYWQuY2hlY2tzdW0gIT09IFwiY2E3ODAwOTk0Y2M4YmZiNWViOTYxZTAzN2M4NzcwNzRcIikge1xuICAgIGltcG9ydF9kZXZVdGlsczUuZGV2VXRpbHMud2FybihcbiAgICAgIGBUaGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgU2VydmljZSBXb3JrZXIgaGFzIGJlZW4gZ2VuZXJhdGVkIGJ5IGEgZGlmZmVyZW50IHZlcnNpb24gb2YgTVNXICgke3BheWxvYWQucGFja2FnZVZlcnNpb259KSBhbmQgbWF5IG5vdCBiZSBmdWxseSBjb21wYXRpYmxlIHdpdGggdGhlIGluc3RhbGxlZCB2ZXJzaW9uLlxuXG5JdCdzIHJlY29tbWVuZGVkIHlvdSB1cGRhdGUgeW91ciB3b3JrZXIgc2NyaXB0IGJ5IHJ1bm5pbmcgdGhpcyBjb21tYW5kOlxuXG4gIFxcdTIwMjIgbnB4IG1zdyBpbml0IDxQVUJMSUNfRElSPlxuXG5Zb3UgY2FuIGFsc28gYXV0b21hdGUgdGhpcyBwcm9jZXNzIGFuZCBtYWtlIHRoZSB3b3JrZXIgc2NyaXB0IHVwZGF0ZSBhdXRvbWF0aWNhbGx5IHVwb24gdGhlIGxpYnJhcnkgaW5zdGFsbGF0aW9ucy4gUmVhZCBtb3JlOiBodHRwczovL21zd2pzLmlvL2RvY3MvY2xpL2luaXQuYFxuICAgICk7XG4gIH1cbn1cblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0Btc3dqcytpbnRlcmNlcHRvcnNAMC4zNy4wL25vZGVfbW9kdWxlcy9AbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9icm93c2VyL2NodW5rLTZIWUlSRlgyLm1qc1xudmFyIGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGVuY29kZUJ1ZmZlcih0ZXh0KSB7XG4gIHJldHVybiBlbmNvZGVyLmVuY29kZSh0ZXh0KTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJ1ZmZlcihidWZmZXIsIGVuY29kaW5nKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcpO1xuICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LmJ1ZmZlci5zbGljZShcbiAgICBhcnJheS5ieXRlT2Zmc2V0LFxuICAgIGFycmF5LmJ5dGVPZmZzZXQgKyBhcnJheS5ieXRlTGVuZ3RoXG4gICk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AbXN3anMraW50ZXJjZXB0b3JzQDAuMzcuMC9ub2RlX21vZHVsZXMvQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvYnJvd3Nlci9jaHVuay1GNEJONzQ1VS5tanNcbnZhciBJU19QQVRDSEVEX01PRFVMRSA9IFN5bWJvbChcImlzUGF0Y2hlZE1vZHVsZVwiKTtcbnZhciBfRmV0Y2hSZXNwb25zZSA9IGNsYXNzIGV4dGVuZHMgUmVzcG9uc2Uge1xuICBzdGF0aWMgaXNDb25maWd1cmFibGVTdGF0dXNDb2RlKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8PSA1OTk7XG4gIH1cbiAgc3RhdGljIGlzUmVkaXJlY3RSZXNwb25zZShzdGF0dXMpIHtcbiAgICByZXR1cm4gX0ZldGNoUmVzcG9uc2UuU1RBVFVTX0NPREVTX1dJVEhfUkVESVJFQ1QuaW5jbHVkZXMoc3RhdHVzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBnaXZlbiByZXNwb25zZSBzdGF0dXNcbiAgICogY29kZSByZXByZXNlbnRzIGEgcmVzcG9uc2UgdGhhdCBjYW4gaGF2ZSBhIGJvZHkuXG4gICAqL1xuICBzdGF0aWMgaXNSZXNwb25zZVdpdGhCb2R5KHN0YXR1cykge1xuICAgIHJldHVybiAhX0ZldGNoUmVzcG9uc2UuU1RBVFVTX0NPREVTX1dJVEhPVVRfQk9EWS5pbmNsdWRlcyhzdGF0dXMpO1xuICB9XG4gIHN0YXRpYyBzZXRVcmwodXJsLCByZXNwb25zZSkge1xuICAgIGlmICghdXJsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS51cmwgIT0gXCJcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsIFwidXJsXCIsIHtcbiAgICAgIHZhbHVlOiB1cmwsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgY29uc3RydWN0b3IoYm9keSwgaW5pdCA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHN0YXR1cyA9IChfYSA9IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2EgOiAyMDA7XG4gICAgY29uc3Qgc2FmZVN0YXR1cyA9IF9GZXRjaFJlc3BvbnNlLmlzQ29uZmlndXJhYmxlU3RhdHVzQ29kZShzdGF0dXMpID8gc3RhdHVzIDogMjAwO1xuICAgIGNvbnN0IGZpbmFsQm9keSA9IF9GZXRjaFJlc3BvbnNlLmlzUmVzcG9uc2VXaXRoQm9keShzdGF0dXMpID8gYm9keSA6IG51bGw7XG4gICAgc3VwZXIoZmluYWxCb2R5LCB7XG4gICAgICAuLi5pbml0LFxuICAgICAgc3RhdHVzOiBzYWZlU3RhdHVzXG4gICAgfSk7XG4gICAgaWYgKHN0YXR1cyAhPT0gc2FmZVN0YXR1cykge1xuICAgICAgY29uc3Qgc3RhdGVTeW1ib2wgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRoaXMpLmZpbmQoXG4gICAgICAgIChzeW1ib2wpID0+IHN5bWJvbC5kZXNjcmlwdGlvbiA9PT0gXCJzdGF0ZVwiXG4gICAgICApO1xuICAgICAgaWYgKHN0YXRlU3ltYm9sKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gUmVmbGVjdC5nZXQodGhpcywgc3RhdGVTeW1ib2wpO1xuICAgICAgICBSZWZsZWN0LnNldChzdGF0ZSwgXCJzdGF0dXNcIiwgc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgdmFsdWU6IHN0YXR1cyxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9GZXRjaFJlc3BvbnNlLnNldFVybChpbml0LnVybCwgdGhpcyk7XG4gIH1cbn07XG52YXIgRmV0Y2hSZXNwb25zZSA9IF9GZXRjaFJlc3BvbnNlO1xuRmV0Y2hSZXNwb25zZS5TVEFUVVNfQ09ERVNfV0lUSE9VVF9CT0RZID0gWzEwMSwgMTAzLCAyMDQsIDIwNSwgMzA0XTtcbkZldGNoUmVzcG9uc2UuU1RBVFVTX0NPREVTX1dJVEhfUkVESVJFQ1QgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vQG9wZW4tZHJhZnQrbG9nZ2VyQDAuMy4wL25vZGVfbW9kdWxlcy9Ab3Blbi1kcmFmdC9sb2dnZXIvbGliL2luZGV4Lm1qc1xudmFyIF9fZGVmUHJvcDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQyID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcDIodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBjb2xvcnNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQyKGNvbG9yc19leHBvcnRzLCB7XG4gIGJsdWU6ICgpID0+IGJsdWUsXG4gIGdyYXk6ICgpID0+IGdyYXksXG4gIGdyZWVuOiAoKSA9PiBncmVlbixcbiAgcmVkOiAoKSA9PiByZWQsXG4gIHllbGxvdzogKCkgPT4geWVsbG93XG59KTtcbmZ1bmN0aW9uIHllbGxvdyh0ZXh0KSB7XG4gIHJldHVybiBgXFx4MUJbMzNtJHt0ZXh0fVxceDFCWzBtYDtcbn1cbmZ1bmN0aW9uIGJsdWUodGV4dCkge1xuICByZXR1cm4gYFxceDFCWzM0bSR7dGV4dH1cXHgxQlswbWA7XG59XG5mdW5jdGlvbiBncmF5KHRleHQpIHtcbiAgcmV0dXJuIGBcXHgxQls5MG0ke3RleHR9XFx4MUJbMG1gO1xufVxuZnVuY3Rpb24gcmVkKHRleHQpIHtcbiAgcmV0dXJuIGBcXHgxQlszMW0ke3RleHR9XFx4MUJbMG1gO1xufVxuZnVuY3Rpb24gZ3JlZW4odGV4dCkge1xuICByZXR1cm4gYFxceDFCWzMybSR7dGV4dH1cXHgxQlswbWA7XG59XG52YXIgSVNfTk9ERSA9IGlzTm9kZVByb2Nlc3MoKTtcbnZhciBMb2dnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucHJlZml4ID0gYFske3RoaXMubmFtZX1dYDtcbiAgICBjb25zdCBMT0dHRVJfTkFNRSA9IGdldFZhcmlhYmxlKFwiREVCVUdcIik7XG4gICAgY29uc3QgTE9HR0VSX0xFVkVMID0gZ2V0VmFyaWFibGUoXCJMT0dfTEVWRUxcIik7XG4gICAgY29uc3QgaXNMb2dnaW5nRW5hYmxlZCA9IExPR0dFUl9OQU1FID09PSBcIjFcIiB8fCBMT0dHRVJfTkFNRSA9PT0gXCJ0cnVlXCIgfHwgdHlwZW9mIExPR0dFUl9OQU1FICE9PSBcInVuZGVmaW5lZFwiICYmIHRoaXMubmFtZS5zdGFydHNXaXRoKExPR0dFUl9OQU1FKTtcbiAgICBpZiAoaXNMb2dnaW5nRW5hYmxlZCkge1xuICAgICAgdGhpcy5kZWJ1ZyA9IGlzRGVmaW5lZEFuZE5vdEVxdWFscyhMT0dHRVJfTEVWRUwsIFwiZGVidWdcIikgPyBub29wIDogdGhpcy5kZWJ1ZztcbiAgICAgIHRoaXMuaW5mbyA9IGlzRGVmaW5lZEFuZE5vdEVxdWFscyhMT0dHRVJfTEVWRUwsIFwiaW5mb1wiKSA/IG5vb3AgOiB0aGlzLmluZm87XG4gICAgICB0aGlzLnN1Y2Nlc3MgPSBpc0RlZmluZWRBbmROb3RFcXVhbHMoTE9HR0VSX0xFVkVMLCBcInN1Y2Nlc3NcIikgPyBub29wIDogdGhpcy5zdWNjZXNzO1xuICAgICAgdGhpcy53YXJuaW5nID0gaXNEZWZpbmVkQW5kTm90RXF1YWxzKExPR0dFUl9MRVZFTCwgXCJ3YXJuaW5nXCIpID8gbm9vcCA6IHRoaXMud2FybmluZztcbiAgICAgIHRoaXMuZXJyb3IgPSBpc0RlZmluZWRBbmROb3RFcXVhbHMoTE9HR0VSX0xFVkVMLCBcImVycm9yXCIpID8gbm9vcCA6IHRoaXMuZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5mbyA9IG5vb3A7XG4gICAgICB0aGlzLnN1Y2Nlc3MgPSBub29wO1xuICAgICAgdGhpcy53YXJuaW5nID0gbm9vcDtcbiAgICAgIHRoaXMuZXJyb3IgPSBub29wO1xuICAgICAgdGhpcy5vbmx5ID0gbm9vcDtcbiAgICB9XG4gIH1cbiAgcHJlZml4O1xuICBleHRlbmQoZG9tYWluKSB7XG4gICAgcmV0dXJuIG5ldyBMb2dnZXIoYCR7dGhpcy5uYW1lfToke2RvbWFpbn1gKTtcbiAgfVxuICAvKipcbiAgICogUHJpbnQgYSBkZWJ1ZyBtZXNzYWdlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBsb2dnZXIuZGVidWcoJ25vIGR1cGxpY2F0ZXMgZm91bmQsIGNyZWF0aW5nIGEgZG9jdW1lbnQuLi4nKVxuICAgKi9cbiAgZGVidWcobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpIHtcbiAgICB0aGlzLmxvZ0VudHJ5KHtcbiAgICAgIGxldmVsOiBcImRlYnVnXCIsXG4gICAgICBtZXNzYWdlOiBncmF5KG1lc3NhZ2UpLFxuICAgICAgcG9zaXRpb25hbHMsXG4gICAgICBwcmVmaXg6IHRoaXMucHJlZml4LFxuICAgICAgY29sb3JzOiB7XG4gICAgICAgIHByZWZpeDogXCJncmF5XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJpbnQgYW4gaW5mbyBtZXNzYWdlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBsb2dnZXIuaW5mbygnc3RhcnQgcGFyc2luZy4uLicpXG4gICAqL1xuICBpbmZvKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gICAgdGhpcy5sb2dFbnRyeSh7XG4gICAgICBsZXZlbDogXCJpbmZvXCIsXG4gICAgICBtZXNzYWdlLFxuICAgICAgcG9zaXRpb25hbHMsXG4gICAgICBwcmVmaXg6IHRoaXMucHJlZml4LFxuICAgICAgY29sb3JzOiB7XG4gICAgICAgIHByZWZpeDogXCJibHVlXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBwZXJmb3JtYW5jZTIgPSBuZXcgUGVyZm9ybWFuY2VFbnRyeSgpO1xuICAgIHJldHVybiAobWVzc2FnZTIsIC4uLnBvc2l0aW9uYWxzMikgPT4ge1xuICAgICAgcGVyZm9ybWFuY2UyLm1lYXN1cmUoKTtcbiAgICAgIHRoaXMubG9nRW50cnkoe1xuICAgICAgICBsZXZlbDogXCJpbmZvXCIsXG4gICAgICAgIG1lc3NhZ2U6IGAke21lc3NhZ2UyfSAke2dyYXkoYCR7cGVyZm9ybWFuY2UyLmRlbHRhVGltZX1tc2ApfWAsXG4gICAgICAgIHBvc2l0aW9uYWxzOiBwb3NpdGlvbmFsczIsXG4gICAgICAgIHByZWZpeDogdGhpcy5wcmVmaXgsXG4gICAgICAgIGNvbG9yczoge1xuICAgICAgICAgIHByZWZpeDogXCJibHVlXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUHJpbnQgYSBzdWNjZXNzIG1lc3NhZ2UuXG4gICAqIEBleGFtcGxlXG4gICAqIGxvZ2dlci5zdWNjZXNzKCdzdWNjZXNzZnVsbHkgY3JlYXRlZCBkb2N1bWVudCcpXG4gICAqL1xuICBzdWNjZXNzKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gICAgdGhpcy5sb2dFbnRyeSh7XG4gICAgICBsZXZlbDogXCJpbmZvXCIsXG4gICAgICBtZXNzYWdlLFxuICAgICAgcG9zaXRpb25hbHMsXG4gICAgICBwcmVmaXg6IGBcXHUyNzE0ICR7dGhpcy5wcmVmaXh9YCxcbiAgICAgIGNvbG9yczoge1xuICAgICAgICB0aW1lc3RhbXA6IFwiZ3JlZW5cIixcbiAgICAgICAgcHJlZml4OiBcImdyZWVuXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJpbnQgYSB3YXJuaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKiBsb2dnZXIud2FybmluZygnZm91bmQgbGVnYWN5IGRvY3VtZW50IGZvcm1hdCcpXG4gICAqL1xuICB3YXJuaW5nKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gICAgdGhpcy5sb2dFbnRyeSh7XG4gICAgICBsZXZlbDogXCJ3YXJuaW5nXCIsXG4gICAgICBtZXNzYWdlLFxuICAgICAgcG9zaXRpb25hbHMsXG4gICAgICBwcmVmaXg6IGBcXHUyNkEwICR7dGhpcy5wcmVmaXh9YCxcbiAgICAgIGNvbG9yczoge1xuICAgICAgICB0aW1lc3RhbXA6IFwieWVsbG93XCIsXG4gICAgICAgIHByZWZpeDogXCJ5ZWxsb3dcIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcmludCBhbiBlcnJvciBtZXNzYWdlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBsb2dnZXIuZXJyb3IoJ3NvbWV0aGluZyB3ZW50IHdyb25nJylcbiAgICovXG4gIGVycm9yKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gICAgdGhpcy5sb2dFbnRyeSh7XG4gICAgICBsZXZlbDogXCJlcnJvclwiLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHBvc2l0aW9uYWxzLFxuICAgICAgcHJlZml4OiBgXFx1MjcxNiAke3RoaXMucHJlZml4fWAsXG4gICAgICBjb2xvcnM6IHtcbiAgICAgICAgdGltZXN0YW1wOiBcInJlZFwiLFxuICAgICAgICBwcmVmaXg6IFwicmVkXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgb25seSB3aGVuIHRoZSBsb2dnaW5nIGlzIGVuYWJsZWQuXG4gICAqIFRoaXMgaXMgc2tpcHBlZCBpbiBpdHMgZW50aXJldHkgYW5kIGhhcyBubyBydW50aW1lIGNvc3Qgb3RoZXJ3aXNlLlxuICAgKiBUaGlzIGV4ZWN1dGVzIHJlZ2FyZGxlc3Mgb2YgdGhlIGxvZyBsZXZlbC5cbiAgICogQGV4YW1wbGVcbiAgICogbG9nZ2VyLm9ubHkoKCkgPT4ge1xuICAgKiAgIGxvZ2dlci5pbmZvKCdhZGRpdGlvbmFsIGluZm8nKVxuICAgKiB9KVxuICAgKi9cbiAgb25seShjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbiAgY3JlYXRlRW50cnkobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgIGxldmVsLFxuICAgICAgbWVzc2FnZVxuICAgIH07XG4gIH1cbiAgbG9nRW50cnkoYXJncykge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIGNvbG9yczogY3VzdG9tQ29sb3JzLFxuICAgICAgcG9zaXRpb25hbHMgPSBbXVxuICAgIH0gPSBhcmdzO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5jcmVhdGVFbnRyeShsZXZlbCwgbWVzc2FnZSk7XG4gICAgY29uc3QgdGltZXN0YW1wQ29sb3IgPSBjdXN0b21Db2xvcnM/LnRpbWVzdGFtcCB8fCBcImdyYXlcIjtcbiAgICBjb25zdCBwcmVmaXhDb2xvciA9IGN1c3RvbUNvbG9ycz8ucHJlZml4IHx8IFwiZ3JheVwiO1xuICAgIGNvbnN0IGNvbG9yaXplID0ge1xuICAgICAgdGltZXN0YW1wOiBjb2xvcnNfZXhwb3J0c1t0aW1lc3RhbXBDb2xvcl0sXG4gICAgICBwcmVmaXg6IGNvbG9yc19leHBvcnRzW3ByZWZpeENvbG9yXVxuICAgIH07XG4gICAgY29uc3Qgd3JpdGUgPSB0aGlzLmdldFdyaXRlcihsZXZlbCk7XG4gICAgd3JpdGUoXG4gICAgICBbY29sb3JpemUudGltZXN0YW1wKHRoaXMuZm9ybWF0VGltZXN0YW1wKGVudHJ5LnRpbWVzdGFtcCkpXS5jb25jYXQocHJlZml4ICE9IG51bGwgPyBjb2xvcml6ZS5wcmVmaXgocHJlZml4KSA6IFtdKS5jb25jYXQoc2VyaWFsaXplSW5wdXQobWVzc2FnZSkpLmpvaW4oXCIgXCIpLFxuICAgICAgLi4ucG9zaXRpb25hbHMubWFwKHNlcmlhbGl6ZUlucHV0KVxuICAgICk7XG4gIH1cbiAgZm9ybWF0VGltZXN0YW1wKHRpbWVzdGFtcCkge1xuICAgIHJldHVybiBgJHt0aW1lc3RhbXAudG9Mb2NhbGVUaW1lU3RyaW5nKFxuICAgICAgXCJlbi1HQlwiXG4gICAgKX06JHt0aW1lc3RhbXAuZ2V0TWlsbGlzZWNvbmRzKCl9YDtcbiAgfVxuICBnZXRXcml0ZXIobGV2ZWwpIHtcbiAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICBjYXNlIFwiaW5mb1wiOiB7XG4gICAgICAgIHJldHVybiBsb2c7XG4gICAgICB9XG4gICAgICBjYXNlIFwid2FybmluZ1wiOiB7XG4gICAgICAgIHJldHVybiB3YXJuO1xuICAgICAgfVxuICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBQZXJmb3JtYW5jZUVudHJ5ID0gY2xhc3Mge1xuICBzdGFydFRpbWU7XG4gIGVuZFRpbWU7XG4gIGRlbHRhVGltZTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfVxuICBtZWFzdXJlKCkge1xuICAgIHRoaXMuZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGRlbHRhVGltZSA9IHRoaXMuZW5kVGltZSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgIHRoaXMuZGVsdGFUaW1lID0gZGVsdGFUaW1lLnRvRml4ZWQoMik7XG4gIH1cbn07XG52YXIgbm9vcCA9ICgpID0+IHZvaWQgMDtcbmZ1bmN0aW9uIGxvZyhtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykge1xuICBpZiAoSVNfTk9ERSkge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGZvcm1hdChtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykgKyBcIlxcblwiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS5sb2cobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpO1xufVxuZnVuY3Rpb24gd2FybihtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykge1xuICBpZiAoSVNfTk9ERSkge1xuICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKGZvcm1hdChtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykgKyBcIlxcblwiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS53YXJuKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKTtcbn1cbmZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gIGlmIChJU19OT0RFKSB7XG4gICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoZm9ybWF0KG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSArIFwiXFxuXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKTtcbn1cbmZ1bmN0aW9uIGdldFZhcmlhYmxlKHZhcmlhYmxlTmFtZSkge1xuICBpZiAoSVNfTk9ERSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudlt2YXJpYWJsZU5hbWVdO1xuICB9XG4gIHJldHVybiBnbG9iYWxUaGlzW3ZhcmlhYmxlTmFtZV0/LnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBpc0RlZmluZWRBbmROb3RFcXVhbHModmFsdWUsIGV4cGVjdGVkKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdm9pZCAwICYmIHZhbHVlICE9PSBleHBlY3RlZDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUlucHV0KG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gIH1cbiAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiBtZXNzYWdlLnRvU3RyaW5nKCk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9zdHJpY3QtZXZlbnQtZW1pdHRlckAwLjUuMS9ub2RlX21vZHVsZXMvc3RyaWN0LWV2ZW50LWVtaXR0ZXIvbGliL2luZGV4Lm1qc1xudmFyIE1lbW9yeUxlYWtFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlbWl0dGVyLCB0eXBlLCBjb3VudCkge1xuICAgIHN1cGVyKFxuICAgICAgYFBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJHtjb3VudH0gJHt0eXBlLnRvU3RyaW5nKCl9IGxpc3RlbmVycyBhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXRgXG4gICAgKTtcbiAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIHRoaXMubmFtZSA9IFwiTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nXCI7XG4gIH1cbn07XG52YXIgX0VtaXR0ZXIgPSBjbGFzcyB7XG4gIHN0YXRpYyBsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIGV2ZW50TmFtZSkge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5tYXhMaXN0ZW5lcnMgPSBfRW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIHRoaXMuaGFzV2FybmVkQWJvdXRQb3RlbnRpYWxNZW1vcnlMZWFrID0gZmFsc2U7XG4gIH1cbiAgX2VtaXRJbnRlcm5hbEV2ZW50KGludGVybmFsRXZlbnROYW1lLCBldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5lbWl0KFxuICAgICAgaW50ZXJuYWxFdmVudE5hbWUsXG4gICAgICAuLi5bZXZlbnROYW1lLCBsaXN0ZW5lcl1cbiAgICApO1xuICB9XG4gIF9nZXRMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHRoaXMuZXZlbnRzLmdldChldmVudE5hbWUpKSB8fCBbXTtcbiAgfVxuICBfcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIF93cmFwT25jZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBvbmNlTGlzdGVuZXIgPSAoLi4uZGF0YSkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIG9uY2VMaXN0ZW5lcik7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhpcywgZGF0YSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob25jZUxpc3RlbmVyLCBcIm5hbWVcIiwgeyB2YWx1ZTogbGlzdGVuZXIubmFtZSB9KTtcbiAgICByZXR1cm4gb25jZUxpc3RlbmVyO1xuICB9XG4gIHNldE1heExpc3RlbmVycyhtYXhMaXN0ZW5lcnMpIHtcbiAgICB0aGlzLm1heExpc3RlbmVycyA9IG1heExpc3RlbmVycztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBtYXggbGlzdGVuZXIgdmFsdWUgZm9yIHRoZSBgRW1pdHRlcmAgd2hpY2ggaXNcbiAgICogZWl0aGVyIHNldCBieSBgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMobilgIG9yIGRlZmF1bHRzIHRvXG4gICAqIGBFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnNgLlxuICAgKi9cbiAgZ2V0TWF4TGlzdGVuZXJzKCkge1xuICAgIHJldHVybiB0aGlzLm1heExpc3RlbmVycztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAgICogVGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgd2lsbCBiZSBzdHJpbmdzIG9yIFN5bWJvbHMuXG4gICAqL1xuICBldmVudE5hbWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZXZlbnRzLmtleXMoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzbHkgY2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIHRoZSBldmVudCBuYW1lZCBgZXZlbnROYW1lYCxcbiAgICogaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSByZWdpc3RlcmVkLCBwYXNzaW5nIHRoZSBzdXBwbGllZCBhcmd1bWVudHMgdG8gZWFjaC5cbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhcyBsaXN0ZW5lcnMsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBlbWl0dGVyID0gbmV3IEVtaXR0ZXI8eyBoZWxsbzogW3N0cmluZ10gfT4oKVxuICAgKiBlbWl0dGVyLmVtaXQoJ2hlbGxvJywgJ0pvaG4nKVxuICAgKi9cbiAgZW1pdChldmVudE5hbWUsIC4uLmRhdGEpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9nZXRMaXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGRhdGEpO1xuICAgIH0pO1xuICAgIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoID4gMDtcbiAgfVxuICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fZW1pdEludGVybmFsRXZlbnQoXCJuZXdMaXN0ZW5lclwiLCBldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICBjb25zdCBuZXh0TGlzdGVuZXJzID0gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50TmFtZSkuY29uY2F0KGxpc3RlbmVyKTtcbiAgICB0aGlzLmV2ZW50cy5zZXQoZXZlbnROYW1lLCBuZXh0TGlzdGVuZXJzKTtcbiAgICBpZiAodGhpcy5tYXhMaXN0ZW5lcnMgPiAwICYmIHRoaXMubGlzdGVuZXJDb3VudChldmVudE5hbWUpID4gdGhpcy5tYXhMaXN0ZW5lcnMgJiYgIXRoaXMuaGFzV2FybmVkQWJvdXRQb3RlbnRpYWxNZW1vcnlMZWFrKSB7XG4gICAgICB0aGlzLmhhc1dhcm5lZEFib3V0UG90ZW50aWFsTWVtb3J5TGVhayA9IHRydWU7XG4gICAgICBjb25zdCBtZW1vcnlMZWFrV2FybmluZyA9IG5ldyBNZW1vcnlMZWFrRXJyb3IoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgdGhpcy5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSlcbiAgICAgICk7XG4gICAgICBjb25zb2xlLndhcm4obWVtb3J5TGVha1dhcm5pbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cbiAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoXG4gICAgICBldmVudE5hbWUsXG4gICAgICB0aGlzLl93cmFwT25jZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpXG4gICAgKTtcbiAgfVxuICBwcmVwZW5kTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2dldExpc3RlbmVycyhldmVudE5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbmV4dExpc3RlbmVycyA9IFtsaXN0ZW5lcl0uY29uY2F0KGxpc3RlbmVycyk7XG4gICAgICB0aGlzLmV2ZW50cy5zZXQoZXZlbnROYW1lLCBuZXh0TGlzdGVuZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ldmVudHMuc2V0KGV2ZW50TmFtZSwgbGlzdGVuZXJzLmNvbmNhdChsaXN0ZW5lcikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwcmVwZW5kT25jZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVwZW5kTGlzdGVuZXIoXG4gICAgICBldmVudE5hbWUsXG4gICAgICB0aGlzLl93cmFwT25jZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpXG4gICAgKTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIHRoaXMuZXZlbnRzLnNldChldmVudE5hbWUsIGxpc3RlbmVycyk7XG4gICAgICB0aGlzLl9lbWl0SW50ZXJuYWxFdmVudChcInJlbW92ZUxpc3RlbmVyXCIsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWxpYXMgZm9yIGBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKClgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlbWl0dGVyLm9mZignaGVsbG8nLCBsaXN0ZW5lcilcbiAgICovXG4gIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgIHRoaXMuZXZlbnRzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50cy5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGFycmF5IG9mIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50IG5hbWVkIGBldmVudE5hbWVgLlxuICAgKi9cbiAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2dldExpc3RlbmVycyhldmVudE5hbWUpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gdGhlIGV2ZW50IG5hbWVkIGBldmVudE5hbWVgLlxuICAgKi9cbiAgbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50TmFtZSkubGVuZ3RoO1xuICB9XG4gIHJhd0xpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgfVxufTtcbnZhciBFbWl0dGVyID0gX0VtaXR0ZXI7XG5FbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0Btc3dqcytpbnRlcmNlcHRvcnNAMC4zNy4wL25vZGVfbW9kdWxlcy9AbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9icm93c2VyL2NodW5rLVFFRDNRNloyLm1qc1xudmFyIElOVEVSTkFMX1JFUVVFU1RfSURfSEVBREVSX05BTUUgPSBcIngtaW50ZXJjZXB0b3JzLWludGVybmFsLXJlcXVlc3QtaWRcIjtcbmZ1bmN0aW9uIGdldEdsb2JhbFN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjQ1ODdcbiAgICBnbG9iYWxUaGlzW3N5bWJvbF0gfHwgdm9pZCAwXG4gICk7XG59XG5mdW5jdGlvbiBzZXRHbG9iYWxTeW1ib2woc3ltYm9sLCB2YWx1ZSkge1xuICBnbG9iYWxUaGlzW3N5bWJvbF0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUdsb2JhbFN5bWJvbChzeW1ib2wpIHtcbiAgZGVsZXRlIGdsb2JhbFRoaXNbc3ltYm9sXTtcbn1cbnZhciBJbnRlcmNlcHRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3ltYm9sKSB7XG4gICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gXCJJTkFDVElWRVwiO1xuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgdGhpcy5sb2dnZXIgPSBuZXcgTG9nZ2VyKHN5bWJvbC5kZXNjcmlwdGlvbik7XG4gICAgdGhpcy5lbWl0dGVyLnNldE1heExpc3RlbmVycygwKTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKFwiY29uc3RydWN0aW5nIHRoZSBpbnRlcmNlcHRvci4uLlwiKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoaXMgaW50ZXJjZXB0b3IgY2FuIGJlIGFwcGxpZWRcbiAgICogaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gICAqL1xuICBjaGVja0Vudmlyb25tZW50KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBBcHBseSB0aGlzIGludGVyY2VwdG9yIHRvIHRoZSBjdXJyZW50IHByb2Nlc3MuXG4gICAqIFJldHVybnMgYW4gYWxyZWFkeSBydW5uaW5nIGludGVyY2VwdG9yIGluc3RhbmNlIGlmIGl0J3MgcHJlc2VudC5cbiAgICovXG4gIGFwcGx5KCkge1xuICAgIGNvbnN0IGxvZ2dlciA9IHRoaXMubG9nZ2VyLmV4dGVuZChcImFwcGx5XCIpO1xuICAgIGxvZ2dlci5pbmZvKFwiYXBwbHlpbmcgdGhlIGludGVyY2VwdG9yLi4uXCIpO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwiQVBQTElFRFwiKSB7XG4gICAgICBsb2dnZXIuaW5mbyhcImludGVyY2VwdGVkIGFscmVhZHkgYXBwbGllZCFcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZEFwcGx5ID0gdGhpcy5jaGVja0Vudmlyb25tZW50KCk7XG4gICAgaWYgKCFzaG91bGRBcHBseSkge1xuICAgICAgbG9nZ2VyLmluZm8oXCJ0aGUgaW50ZXJjZXB0b3IgY2Fubm90IGJlIGFwcGxpZWQgaW4gdGhpcyBlbnZpcm9ubWVudCFcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiQVBQTFlJTkdcIjtcbiAgICBjb25zdCBydW5uaW5nSW5zdGFuY2UgPSB0aGlzLmdldEluc3RhbmNlKCk7XG4gICAgaWYgKHJ1bm5pbmdJbnN0YW5jZSkge1xuICAgICAgbG9nZ2VyLmluZm8oXCJmb3VuZCBhIHJ1bm5pbmcgaW5zdGFuY2UsIHJldXNpbmcuLi5cIik7XG4gICAgICB0aGlzLm9uID0gKGV2ZW50LCBsaXN0ZW5lcikgPT4ge1xuICAgICAgICBsb2dnZXIuaW5mbygncHJveHlpbmcgdGhlIFwiJXNcIiBsaXN0ZW5lcicsIGV2ZW50KTtcbiAgICAgICAgcnVubmluZ0luc3RhbmNlLmVtaXR0ZXIuYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgICAgICAgIHJ1bm5pbmdJbnN0YW5jZS5lbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oJ3JlbW92ZWQgcHJveGllZCBcIiVzXCIgbGlzdGVuZXIhJywgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJBUFBMSUVEXCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlci5pbmZvKFwibm8gcnVubmluZyBpbnN0YW5jZSBmb3VuZCwgc2V0dGluZyB1cCBhIG5ldyBpbnN0YW5jZS4uLlwiKTtcbiAgICB0aGlzLnNldHVwKCk7XG4gICAgdGhpcy5zZXRJbnN0YW5jZSgpO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiQVBQTElFRFwiO1xuICB9XG4gIC8qKlxuICAgKiBTZXR1cCB0aGUgbW9kdWxlIGF1Z21lbnRzIGFuZCBzdHVicyBuZWNlc3NhcnkgZm9yIHRoaXMgaW50ZXJjZXB0b3IuXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBydW4gaWYgdGhlcmUncyBhIHJ1bm5pbmcgaW50ZXJjZXB0b3IgaW5zdGFuY2VcbiAgICogdG8gcHJldmVudCBpbnN0YW50aWF0aW5nIGFuIGludGVyY2VwdG9yIG11bHRpcGxlIHRpbWVzLlxuICAgKi9cbiAgc2V0dXAoKSB7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RlbiB0byB0aGUgaW50ZXJjZXB0b3IncyBwdWJsaWMgZXZlbnRzLlxuICAgKi9cbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbG9nZ2VyID0gdGhpcy5sb2dnZXIuZXh0ZW5kKFwib25cIik7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJESVNQT1NJTkdcIiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFwiRElTUE9TRURcIikge1xuICAgICAgbG9nZ2VyLmluZm8oXCJjYW5ub3QgbGlzdGVuIHRvIGV2ZW50cywgYWxyZWFkeSBkaXNwb3NlZCFcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbG9nZ2VyLmluZm8oJ2FkZGluZyBcIiVzXCIgZXZlbnQgbGlzdGVuZXI6JywgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB0aGlzLmVtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHRoaXMuZW1pdHRlci5vbmNlKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHRoaXMuZW1pdHRlci5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICB0aGlzLmVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGlzcG9zZXMgb2YgYW55IHNpZGUtZWZmZWN0cyB0aGlzIGludGVyY2VwdG9yIGhhcyBpbnRyb2R1Y2VkLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICBjb25zdCBsb2dnZXIgPSB0aGlzLmxvZ2dlci5leHRlbmQoXCJkaXNwb3NlXCIpO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwiRElTUE9TRURcIikge1xuICAgICAgbG9nZ2VyLmluZm8oXCJjYW5ub3QgZGlzcG9zZSwgYWxyZWFkeSBkaXNwb3NlZCFcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlci5pbmZvKFwiZGlzcG9zaW5nIHRoZSBpbnRlcmNlcHRvci4uLlwiKTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBcIkRJU1BPU0lOR1wiO1xuICAgIGlmICghdGhpcy5nZXRJbnN0YW5jZSgpKSB7XG4gICAgICBsb2dnZXIuaW5mbyhcIm5vIGludGVyY2VwdG9ycyBydW5uaW5nLCBza2lwcGluZyBkaXNwb3NlLi4uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNsZWFySW5zdGFuY2UoKTtcbiAgICBsb2dnZXIuaW5mbyhcImdsb2JhbCBzeW1ib2wgZGVsZXRlZDpcIiwgZ2V0R2xvYmFsU3ltYm9sKHRoaXMuc3ltYm9sKSk7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBsb2dnZXIuaW5mbyhcImRpc3Bvc2luZyBvZiAlZCBzdWJzY3JpcHRpb25zLi4uXCIsIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGgpO1xuICAgICAgZm9yIChjb25zdCBkaXNwb3NlIG9mIHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgIGxvZ2dlci5pbmZvKFwiZGlzcG9zZWQgb2YgYWxsIHN1YnNjcmlwdGlvbnMhXCIsIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGgpO1xuICAgIH1cbiAgICB0aGlzLmVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgbG9nZ2VyLmluZm8oXCJkZXN0cm95ZWQgdGhlIGxpc3RlbmVyIVwiKTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBcIkRJU1BPU0VEXCI7XG4gIH1cbiAgZ2V0SW5zdGFuY2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0R2xvYmFsU3ltYm9sKHRoaXMuc3ltYm9sKTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKFwicmV0cmlldmVkIGdsb2JhbCBpbnN0YW5jZTpcIiwgKF9hID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHNldEluc3RhbmNlKCkge1xuICAgIHNldEdsb2JhbFN5bWJvbCh0aGlzLnN5bWJvbCwgdGhpcyk7XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcInNldCBnbG9iYWwgaW5zdGFuY2UhXCIsIHRoaXMuc3ltYm9sLmRlc2NyaXB0aW9uKTtcbiAgfVxuICBjbGVhckluc3RhbmNlKCkge1xuICAgIGRlbGV0ZUdsb2JhbFN5bWJvbCh0aGlzLnN5bWJvbCk7XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcImNsZWFyZWQgZ2xvYmFsIGluc3RhbmNlIVwiLCB0aGlzLnN5bWJvbC5kZXNjcmlwdGlvbik7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0SWQoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5zbGljZSgyKTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0Btc3dqcytpbnRlcmNlcHRvcnNAMC4zNy4wL25vZGVfbW9kdWxlcy9AbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9icm93c2VyL2luZGV4Lm1qc1xudmFyIEJhdGNoSW50ZXJjZXB0b3IgPSBjbGFzcyBleHRlbmRzIEludGVyY2VwdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIEJhdGNoSW50ZXJjZXB0b3Iuc3ltYm9sID0gU3ltYm9sKG9wdGlvbnMubmFtZSk7XG4gICAgc3VwZXIoQmF0Y2hJbnRlcmNlcHRvci5zeW1ib2wpO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzID0gb3B0aW9ucy5pbnRlcmNlcHRvcnM7XG4gIH1cbiAgc2V0dXAoKSB7XG4gICAgY29uc3QgbG9nZ2VyID0gdGhpcy5sb2dnZXIuZXh0ZW5kKFwic2V0dXBcIik7XG4gICAgbG9nZ2VyLmluZm8oXCJhcHBseWluZyBhbGwgJWQgaW50ZXJjZXB0b3JzLi4uXCIsIHRoaXMuaW50ZXJjZXB0b3JzLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBpbnRlcmNlcHRvciBvZiB0aGlzLmludGVyY2VwdG9ycykge1xuICAgICAgbG9nZ2VyLmluZm8oJ2FwcGx5aW5nIFwiJXNcIiBpbnRlcmNlcHRvci4uLicsIGludGVyY2VwdG9yLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgaW50ZXJjZXB0b3IuYXBwbHkoKTtcbiAgICAgIGxvZ2dlci5pbmZvKFwiYWRkaW5nIGludGVyY2VwdG9yIGRpc3Bvc2Ugc3Vic2NyaXB0aW9uXCIpO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4gaW50ZXJjZXB0b3IuZGlzcG9zZSgpKTtcbiAgICB9XG4gIH1cbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgZm9yIChjb25zdCBpbnRlcmNlcHRvciBvZiB0aGlzLmludGVyY2VwdG9ycykge1xuICAgICAgaW50ZXJjZXB0b3Iub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICBmb3IgKGNvbnN0IGludGVyY2VwdG9yIG9mIHRoaXMuaW50ZXJjZXB0b3JzKSB7XG4gICAgICBpbnRlcmNlcHRvci5vbmNlKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBmb3IgKGNvbnN0IGludGVyY2VwdG9yIG9mIHRoaXMuaW50ZXJjZXB0b3JzKSB7XG4gICAgICBpbnRlcmNlcHRvci5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCBpbnRlcmNlcHRvcnMgb2YgdGhpcy5pbnRlcmNlcHRvcnMpIHtcbiAgICAgIGludGVyY2VwdG9ycy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuLy8gc3JjL2Jyb3dzZXIvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlUmVzcG9uc2VMaXN0ZW5lci50c1xuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VMaXN0ZW5lcihjb250ZXh0KSB7XG4gIHJldHVybiAoXywgbWVzc2FnZSkgPT4ge1xuICAgIGNvbnN0IHsgcGF5bG9hZDogcmVzcG9uc2VKc29uIH0gPSBtZXNzYWdlO1xuICAgIGNvbnN0IHsgcmVxdWVzdElkIH0gPSByZXNwb25zZUpzb247XG4gICAgY29uc3QgcmVxdWVzdCA9IGNvbnRleHQucmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgY29udGV4dC5yZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICBpZiAocmVzcG9uc2VKc29uLnR5cGU/LmluY2x1ZGVzKFwib3BhcXVlXCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gcmVzcG9uc2VKc29uLnN0YXR1cyA9PT0gMCA/IFJlc3BvbnNlLmVycm9yKCkgOiBuZXcgRmV0Y2hSZXNwb25zZShcbiAgICAgIC8qKlxuICAgICAgICogUmVzcG9uc2VzIG1heSBiZSBzdHJlYW1zIGhlcmUsIGJ1dCB3aGVuIHdlIGNyZWF0ZSBhIHJlc3BvbnNlIG9iamVjdFxuICAgICAgICogd2l0aCBudWxsLWJvZHkgc3RhdHVzIGNvZGVzLCBsaWtlIDIwNCwgMjA1LCAzMDQgUmVzcG9uc2Ugd2lsbFxuICAgICAgICogdGhyb3cgd2hlbiBwYXNzZWQgYSBub24tbnVsbCBib2R5LCBzbyBlbnN1cmUgaXQncyBudWxsIGhlcmVcbiAgICAgICAqIGZvciB0aG9zZSBjb2Rlc1xuICAgICAgICovXG4gICAgICBGZXRjaFJlc3BvbnNlLmlzUmVzcG9uc2VXaXRoQm9keShyZXNwb25zZUpzb24uc3RhdHVzKSA/IHJlc3BvbnNlSnNvbi5ib2R5IDogbnVsbCxcbiAgICAgIHtcbiAgICAgICAgLi4ucmVzcG9uc2VKc29uLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHJlc3BvbnNlIFVSTCBpZiBpdCdzIG5vdCBzZXQgYWxyZWFkeS5cbiAgICAgICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbXN3anMvbXN3L2lzc3Vlcy8yMDMwXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Jlc3BvbnNlL3VybFxuICAgICAgICAgKi9cbiAgICAgICAgdXJsOiByZXF1ZXN0LnVybFxuICAgICAgfVxuICAgICk7XG4gICAgY29udGV4dC5lbWl0dGVyLmVtaXQoXG4gICAgICByZXNwb25zZUpzb24uaXNNb2NrZWRSZXNwb25zZSA/IFwicmVzcG9uc2U6bW9ja2VkXCIgOiBcInJlc3BvbnNlOmJ5cGFzc1wiLFxuICAgICAge1xuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgcmVxdWVzdElkOiByZXNwb25zZUpzb24ucmVxdWVzdElkXG4gICAgICB9XG4gICAgKTtcbiAgfTtcbn1cblxuLy8gc3JjL2Jyb3dzZXIvc2V0dXBXb3JrZXIvc3RhcnQvdXRpbHMvdmFsaWRhdGVXb3JrZXJTY29wZS50c1xudmFyIGltcG9ydF9kZXZVdGlsczYgPSByZXF1aXJlKFwiLi4vY29yZS91dGlscy9pbnRlcm5hbC9kZXZVdGlscy5qc1wiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlV29ya2VyU2NvcGUocmVnaXN0cmF0aW9uLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucz8ucXVpZXQgJiYgIWxvY2F0aW9uLmhyZWYuc3RhcnRzV2l0aChyZWdpc3RyYXRpb24uc2NvcGUpKSB7XG4gICAgaW1wb3J0X2RldlV0aWxzNi5kZXZVdGlscy53YXJuKFxuICAgICAgYENhbm5vdCBpbnRlcmNlcHQgcmVxdWVzdHMgb24gdGhpcyBwYWdlIGJlY2F1c2UgaXQncyBvdXRzaWRlIG9mIHRoZSB3b3JrZXIncyBzY29wZSAoXCIke3JlZ2lzdHJhdGlvbi5zY29wZX1cIikuIElmIHlvdSB3aXNoIHRvIG1vY2sgQVBJIHJlcXVlc3RzIG9uIHRoaXMgcGFnZSwgeW91IG11c3QgcmVzb2x2ZSB0aGlzIHNjb3BlIGlzc3VlLlxuXG4tIChSZWNvbW1lbmRlZCkgUmVnaXN0ZXIgdGhlIHdvcmtlciBhdCB0aGUgcm9vdCBsZXZlbCAoXCIvXCIpIG9mIHlvdXIgYXBwbGljYXRpb24uXG4tIFNldCB0aGUgXCJTZXJ2aWNlLVdvcmtlci1BbGxvd2VkXCIgcmVzcG9uc2UgaGVhZGVyIHRvIGFsbG93IG91dC1vZi1zY29wZSB3b3JrZXJzLmBcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9icm93c2VyL3NldHVwV29ya2VyL3N0YXJ0L2NyZWF0ZVN0YXJ0SGFuZGxlci50c1xudmFyIGNyZWF0ZVN0YXJ0SGFuZGxlciA9IChjb250ZXh0KSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiBzdGFydChvcHRpb25zLCBjdXN0b21PcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhcnRXb3JrZXJJbnN0YW5jZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnRleHQuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgY29udGV4dC53b3JrZXJDaGFubmVsLm9uKFxuICAgICAgICBcIlJFUVVFU1RcIixcbiAgICAgICAgY3JlYXRlUmVxdWVzdExpc3RlbmVyKGNvbnRleHQsIG9wdGlvbnMpXG4gICAgICApO1xuICAgICAgY29udGV4dC53b3JrZXJDaGFubmVsLm9uKFwiUkVTUE9OU0VcIiwgY3JlYXRlUmVzcG9uc2VMaXN0ZW5lcihjb250ZXh0KSk7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IGdldFdvcmtlckluc3RhbmNlKFxuICAgICAgICBvcHRpb25zLnNlcnZpY2VXb3JrZXIudXJsLFxuICAgICAgICBvcHRpb25zLnNlcnZpY2VXb3JrZXIub3B0aW9ucyxcbiAgICAgICAgb3B0aW9ucy5maW5kV29ya2VyXG4gICAgICApO1xuICAgICAgY29uc3QgW3dvcmtlciwgcmVnaXN0cmF0aW9uXSA9IGluc3RhbmNlO1xuICAgICAgaWYgKCF3b3JrZXIpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1dvcmtlck1lc3NhZ2UgPSBjdXN0b21PcHRpb25zPy5maW5kV29ya2VyID8gaW1wb3J0X2RldlV0aWxzNy5kZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIGBGYWlsZWQgdG8gbG9jYXRlIHRoZSBTZXJ2aWNlIFdvcmtlciByZWdpc3RyYXRpb24gdXNpbmcgYSBjdXN0b20gXCJmaW5kV29ya2VyXCIgcHJlZGljYXRlLlxuXG5QbGVhc2UgZW5zdXJlIHRoYXQgdGhlIGN1c3RvbSBwcmVkaWNhdGUgcHJvcGVybHkgbG9jYXRlcyB0aGUgU2VydmljZSBXb3JrZXIgcmVnaXN0cmF0aW9uIGF0IFwiJXNcIi5cbk1vcmUgZGV0YWlsczogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL2FwaS9zZXR1cC13b3JrZXIvc3RhcnQjZmluZHdvcmtlclxuYCxcbiAgICAgICAgICBvcHRpb25zLnNlcnZpY2VXb3JrZXIudXJsXG4gICAgICAgICkgOiBpbXBvcnRfZGV2VXRpbHM3LmRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgYEZhaWxlZCB0byBsb2NhdGUgdGhlIFNlcnZpY2UgV29ya2VyIHJlZ2lzdHJhdGlvbi5cblxuVGhpcyBtb3N0IGxpa2VseSBtZWFucyB0aGF0IHRoZSB3b3JrZXIgc2NyaXB0IFVSTCBcIiVzXCIgY2Fubm90IHJlc29sdmUgYWdhaW5zdCB0aGUgYWN0dWFsIHB1YmxpYyBob3N0bmFtZSAoJXMpLiBUaGlzIG1heSBoYXBwZW4gaWYgeW91ciBhcHBsaWNhdGlvbiBydW5zIGJlaGluZCBhIHByb3h5LCBvciBoYXMgYSBkeW5hbWljIGhvc3RuYW1lLlxuXG5QbGVhc2UgY29uc2lkZXIgdXNpbmcgYSBjdXN0b20gXCJzZXJ2aWNlV29ya2VyLnVybFwiIG9wdGlvbiB0byBwb2ludCB0byB0aGUgYWN0dWFsIHdvcmtlciBzY3JpcHQgbG9jYXRpb24sIG9yIGEgY3VzdG9tIFwiZmluZFdvcmtlclwiIG9wdGlvbiB0byByZXNvbHZlIHRoZSBTZXJ2aWNlIFdvcmtlciByZWdpc3RyYXRpb24gbWFudWFsbHkuIE1vcmUgZGV0YWlsczogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL2FwaS9zZXR1cC13b3JrZXIvc3RhcnRgLFxuICAgICAgICAgIG9wdGlvbnMuc2VydmljZVdvcmtlci51cmwsXG4gICAgICAgICAgbG9jYXRpb24uaG9zdFxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWlzc2luZ1dvcmtlck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgY29udGV4dC53b3JrZXIgPSB3b3JrZXI7XG4gICAgICBjb250ZXh0LnJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbjtcbiAgICAgIGNvbnRleHQuZXZlbnRzLmFkZExpc3RlbmVyKHdpbmRvdywgXCJiZWZvcmV1bmxvYWRcIiwgKCkgPT4ge1xuICAgICAgICBpZiAod29ya2VyLnN0YXRlICE9PSBcInJlZHVuZGFudFwiKSB7XG4gICAgICAgICAgY29udGV4dC53b3JrZXJDaGFubmVsLnNlbmQoXCJDTElFTlRfQ0xPU0VEXCIpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGNvbnRleHQua2VlcEFsaXZlSW50ZXJ2YWwpO1xuICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoeyB0eXBlOiBcIm1zdy93b3JrZXI6c3RvcFwiIH0pO1xuICAgICAgfSk7XG4gICAgICBhd2FpdCBjaGVja1dvcmtlckludGVncml0eShjb250ZXh0KS5jYXRjaCgoZXJyb3IyKSA9PiB7XG4gICAgICAgIGltcG9ydF9kZXZVdGlsczcuZGV2VXRpbHMuZXJyb3IoXG4gICAgICAgICAgXCJFcnJvciB3aGlsZSBjaGVja2luZyB0aGUgd29ya2VyIHNjcmlwdCBpbnRlZ3JpdHkuIFBsZWFzZSByZXBvcnQgdGhpcyBvbiBHaXRIdWIgKGh0dHBzOi8vZ2l0aHViLmNvbS9tc3dqcy9tc3cvaXNzdWVzKSwgaW5jbHVkaW5nIHRoZSBvcmlnaW5hbCBlcnJvciBiZWxvdy5cIlxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yMik7XG4gICAgICB9KTtcbiAgICAgIGNvbnRleHQua2VlcEFsaXZlSW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoXG4gICAgICAgICgpID0+IGNvbnRleHQud29ya2VyQ2hhbm5lbC5zZW5kKFwiS0VFUEFMSVZFX1JFUVVFU1RcIiksXG4gICAgICAgIDVlM1xuICAgICAgKTtcbiAgICAgIHZhbGlkYXRlV29ya2VyU2NvcGUocmVnaXN0cmF0aW9uLCBjb250ZXh0LnN0YXJ0T3B0aW9ucyk7XG4gICAgICByZXR1cm4gcmVnaXN0cmF0aW9uO1xuICAgIH07XG4gICAgY29uc3Qgd29ya2VyUmVnaXN0cmF0aW9uID0gc3RhcnRXb3JrZXJJbnN0YW5jZSgpLnRoZW4oXG4gICAgICBhc3luYyAocmVnaXN0cmF0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdJbnN0YW5jZSA9IHJlZ2lzdHJhdGlvbi5pbnN0YWxsaW5nIHx8IHJlZ2lzdHJhdGlvbi53YWl0aW5nO1xuICAgICAgICBpZiAocGVuZGluZ0luc3RhbmNlKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHBlbmRpbmdJbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwic3RhdGVjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocGVuZGluZ0luc3RhbmNlLnN0YXRlID09PSBcImFjdGl2YXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5hYmxlTW9ja2luZyhjb250ZXh0LCBvcHRpb25zKS5jYXRjaCgoZXJyb3IyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZW5hYmxlIG1vY2tpbmc6ICR7ZXJyb3IyPy5tZXNzYWdlfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvbjtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB3b3JrZXJSZWdpc3RyYXRpb247XG4gIH07XG59O1xuXG4vLyBzcmMvYnJvd3Nlci9zZXR1cFdvcmtlci9zdG9wL2NyZWF0ZVN0b3AudHNcbnZhciBpbXBvcnRfZGV2VXRpbHM5ID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbHMvaW50ZXJuYWwvZGV2VXRpbHMuanNcIik7XG5cbi8vIHNyYy9icm93c2VyL3NldHVwV29ya2VyL3N0b3AvdXRpbHMvcHJpbnRTdG9wTWVzc2FnZS50c1xudmFyIGltcG9ydF9kZXZVdGlsczggPSByZXF1aXJlKFwiLi4vY29yZS91dGlscy9pbnRlcm5hbC9kZXZVdGlscy5qc1wiKTtcbmZ1bmN0aW9uIHByaW50U3RvcE1lc3NhZ2UoYXJncyA9IHt9KSB7XG4gIGlmIChhcmdzLnF1aWV0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUubG9nKFxuICAgIGAlYyR7aW1wb3J0X2RldlV0aWxzOC5kZXZVdGlscy5mb3JtYXRNZXNzYWdlKFwiTW9ja2luZyBkaXNhYmxlZC5cIil9YCxcbiAgICBcImNvbG9yOm9yYW5nZXJlZDtmb250LXdlaWdodDpib2xkO1wiXG4gICk7XG59XG5cbi8vIHNyYy9icm93c2VyL3NldHVwV29ya2VyL3N0b3AvY3JlYXRlU3RvcC50c1xudmFyIGNyZWF0ZVN0b3AgPSAoY29udGV4dCkgPT4ge1xuICByZXR1cm4gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoIWNvbnRleHQuaXNNb2NraW5nRW5hYmxlZCkge1xuICAgICAgaW1wb3J0X2RldlV0aWxzOS5kZXZVdGlscy53YXJuKFxuICAgICAgICAnRm91bmQgYSByZWR1bmRhbnQgXCJ3b3JrZXIuc3RvcCgpXCIgY2FsbC4gTm90ZSB0aGF0IHN0b3BwaW5nIHRoZSB3b3JrZXIgd2hpbGUgbW9ja2luZyBhbHJlYWR5IHN0b3BwZWQgaGFzIG5vIGVmZmVjdC4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhpcyBcIndvcmtlci5zdG9wKClcIiBjYWxsLidcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQud29ya2VyQ2hhbm5lbC5zZW5kKFwiTU9DS19ERUFDVElWQVRFXCIpO1xuICAgIGNvbnRleHQuaXNNb2NraW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIHdpbmRvdy5jbGVhckludGVydmFsKGNvbnRleHQua2VlcEFsaXZlSW50ZXJ2YWwpO1xuICAgIHdpbmRvdy5wb3N0TWVzc2FnZSh7IHR5cGU6IFwibXN3L3dvcmtlcjpzdG9wXCIgfSk7XG4gICAgcHJpbnRTdG9wTWVzc2FnZSh7IHF1aWV0OiBjb250ZXh0LnN0YXJ0T3B0aW9ucz8ucXVpZXQgfSk7XG4gIH07XG59O1xuXG4vLyBzcmMvYnJvd3Nlci9zZXR1cFdvcmtlci9zdGFydC91dGlscy9wcmVwYXJlU3RhcnRIYW5kbGVyLnRzXG52YXIgaW1wb3J0X21lcmdlUmlnaHQgPSByZXF1aXJlKFwiLi4vY29yZS91dGlscy9pbnRlcm5hbC9tZXJnZVJpZ2h0LmpzXCIpO1xudmFyIERFRkFVTFRfU1RBUlRfT1BUSU9OUyA9IHtcbiAgc2VydmljZVdvcmtlcjoge1xuICAgIHVybDogXCIvbW9ja1NlcnZpY2VXb3JrZXIuanNcIixcbiAgICBvcHRpb25zOiBudWxsXG4gIH0sXG4gIHF1aWV0OiBmYWxzZSxcbiAgd2FpdFVudGlsUmVhZHk6IHRydWUsXG4gIG9uVW5oYW5kbGVkUmVxdWVzdDogXCJ3YXJuXCIsXG4gIGZpbmRXb3JrZXIoc2NyaXB0VVJMLCBtb2NrU2VydmljZVdvcmtlclVybCkge1xuICAgIHJldHVybiBzY3JpcHRVUkwgPT09IG1vY2tTZXJ2aWNlV29ya2VyVXJsO1xuICB9XG59O1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vQG9wZW4tZHJhZnQrZGVmZXJyZWQtcHJvbWlzZUAyLjIuMC9ub2RlX21vZHVsZXMvQG9wZW4tZHJhZnQvZGVmZXJyZWQtcHJvbWlzZS9idWlsZC9pbmRleC5tanNcbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkRXhlY3V0b3IoKSB7XG4gIGNvbnN0IGV4ZWN1dG9yID0gKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGV4ZWN1dG9yLnN0YXRlID0gXCJwZW5kaW5nXCI7XG4gICAgZXhlY3V0b3IucmVzb2x2ZSA9IChkYXRhKSA9PiB7XG4gICAgICBpZiAoZXhlY3V0b3Iuc3RhdGUgIT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV4ZWN1dG9yLnJlc3VsdCA9IGRhdGE7XG4gICAgICBjb25zdCBvbkZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBleGVjdXRvci5zdGF0ZSA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzb2x2ZShcbiAgICAgICAgZGF0YSBpbnN0YW5jZW9mIFByb21pc2UgPyBkYXRhIDogUHJvbWlzZS5yZXNvbHZlKGRhdGEpLnRoZW4ob25GdWxmaWxsZWQpXG4gICAgICApO1xuICAgIH07XG4gICAgZXhlY3V0b3IucmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuICAgICAgaWYgKGV4ZWN1dG9yLnN0YXRlICE9PSBcInBlbmRpbmdcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGV4ZWN1dG9yLnN0YXRlID0gXCJyZWplY3RlZFwiO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVqZWN0KGV4ZWN1dG9yLnJlamVjdGlvblJlYXNvbiA9IHJlYXNvbik7XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGV4ZWN1dG9yO1xufVxudmFyIERlZmVycmVkUHJvbWlzZSA9IGNsYXNzIGV4dGVuZHMgUHJvbWlzZSB7XG4gICNleGVjdXRvcjtcbiAgcmVzb2x2ZTtcbiAgcmVqZWN0O1xuICBjb25zdHJ1Y3RvcihleGVjdXRvciA9IG51bGwpIHtcbiAgICBjb25zdCBkZWZlcnJlZEV4ZWN1dG9yID0gY3JlYXRlRGVmZXJyZWRFeGVjdXRvcigpO1xuICAgIHN1cGVyKChvcmlnaW5hbFJlc29sdmUsIG9yaWdpbmFsUmVqZWN0KSA9PiB7XG4gICAgICBkZWZlcnJlZEV4ZWN1dG9yKG9yaWdpbmFsUmVzb2x2ZSwgb3JpZ2luYWxSZWplY3QpO1xuICAgICAgZXhlY3V0b3I/LihkZWZlcnJlZEV4ZWN1dG9yLnJlc29sdmUsIGRlZmVycmVkRXhlY3V0b3IucmVqZWN0KTtcbiAgICB9KTtcbiAgICB0aGlzLiNleGVjdXRvciA9IGRlZmVycmVkRXhlY3V0b3I7XG4gICAgdGhpcy5yZXNvbHZlID0gdGhpcy4jZXhlY3V0b3IucmVzb2x2ZTtcbiAgICB0aGlzLnJlamVjdCA9IHRoaXMuI2V4ZWN1dG9yLnJlamVjdDtcbiAgfVxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2V4ZWN1dG9yLnN0YXRlO1xuICB9XG4gIGdldCByZWplY3Rpb25SZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2V4ZWN1dG9yLnJlamVjdGlvblJlYXNvbjtcbiAgfVxuICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlY29yYXRlKHN1cGVyLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpKTtcbiAgfVxuICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlY29yYXRlKHN1cGVyLmNhdGNoKG9uUmVqZWN0ZWQpKTtcbiAgfVxuICBmaW5hbGx5KG9uZmluYWxseSkge1xuICAgIHJldHVybiB0aGlzLiNkZWNvcmF0ZShzdXBlci5maW5hbGx5KG9uZmluYWxseSkpO1xuICB9XG4gICNkZWNvcmF0ZShwcm9taXNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb21pc2UsIHtcbiAgICAgIHJlc29sdmU6IHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcy5yZXNvbHZlIH0sXG4gICAgICByZWplY3Q6IHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcy5yZWplY3QgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vQG1zd2pzK2ludGVyY2VwdG9yc0AwLjM3LjAvbm9kZV9tb2R1bGVzL0Btc3dqcy9pbnRlcmNlcHRvcnMvbGliL2Jyb3dzZXIvY2h1bmstSDVPNzNXRDIubWpzXG52YXIgSW50ZXJjZXB0b3JFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJJbnRlcmNlcHRvckVycm9yXCI7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEludGVyY2VwdG9yRXJyb3IucHJvdG90eXBlKTtcbiAgfVxufTtcbnZhciBrUmVxdWVzdEhhbmRsZWQgPSBTeW1ib2woXCJrUmVxdWVzdEhhbmRsZWRcIik7XG52YXIga1Jlc3BvbnNlUHJvbWlzZSA9IFN5bWJvbChcImtSZXNwb25zZVByb21pc2VcIik7XG52YXIgUmVxdWVzdENvbnRyb2xsZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIHRoaXNba1JlcXVlc3RIYW5kbGVkXSA9IGZhbHNlO1xuICAgIHRoaXNba1Jlc3BvbnNlUHJvbWlzZV0gPSBuZXcgRGVmZXJyZWRQcm9taXNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3BvbmQgdG8gdGhpcyByZXF1ZXN0IHdpdGggdGhlIGdpdmVuIGBSZXNwb25zZWAgaW5zdGFuY2UuXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnRyb2xsZXIucmVzcG9uZFdpdGgobmV3IFJlc3BvbnNlKCkpXG4gICAqIGNvbnRyb2xsZXIucmVzcG9uZFdpdGgoUmVzcG9uc2UuanNvbih7IGlkIH0pKVxuICAgKiBjb250cm9sbGVyLnJlc3BvbmRXaXRoKFJlc3BvbnNlLmVycm9yKCkpXG4gICAqL1xuICByZXNwb25kV2l0aChyZXNwb25zZSkge1xuICAgIGludmFyaWFudC5hcyhcbiAgICAgIEludGVyY2VwdG9yRXJyb3IsXG4gICAgICAhdGhpc1trUmVxdWVzdEhhbmRsZWRdLFxuICAgICAgJ0ZhaWxlZCB0byByZXNwb25kIHRvIHRoZSBcIiVzICVzXCIgcmVxdWVzdDogdGhlIFwicmVxdWVzdFwiIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gaGFuZGxlZC4nLFxuICAgICAgdGhpcy5yZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIHRoaXMucmVxdWVzdC51cmxcbiAgICApO1xuICAgIHRoaXNba1JlcXVlc3RIYW5kbGVkXSA9IHRydWU7XG4gICAgdGhpc1trUmVzcG9uc2VQcm9taXNlXS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgfVxuICAvKipcbiAgICogRXJyb3IgdGhpcyByZXF1ZXN0IHdpdGggdGhlIGdpdmVuIGVycm9yLlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb250cm9sbGVyLmVycm9yV2l0aCgpXG4gICAqIGNvbnRyb2xsZXIuZXJyb3JXaXRoKG5ldyBFcnJvcignT29wcyEnKSlcbiAgICovXG4gIGVycm9yV2l0aChlcnJvcjIpIHtcbiAgICBpbnZhcmlhbnQuYXMoXG4gICAgICBJbnRlcmNlcHRvckVycm9yLFxuICAgICAgIXRoaXNba1JlcXVlc3RIYW5kbGVkXSxcbiAgICAgICdGYWlsZWQgdG8gZXJyb3IgdGhlIFwiJXMgJXNcIiByZXF1ZXN0OiB0aGUgXCJyZXF1ZXN0XCIgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBoYW5kbGVkLicsXG4gICAgICB0aGlzLnJlcXVlc3QubWV0aG9kLFxuICAgICAgdGhpcy5yZXF1ZXN0LnVybFxuICAgICk7XG4gICAgdGhpc1trUmVxdWVzdEhhbmRsZWRdID0gdHJ1ZTtcbiAgICB0aGlzW2tSZXNwb25zZVByb21pc2VdLnJlc29sdmUoZXJyb3IyKTtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGVtaXRBc3luYyhlbWl0dGVyLCBldmVudE5hbWUsIC4uLmRhdGEpIHtcbiAgY29uc3QgbGlzdG5lcnMgPSBlbWl0dGVyLmxpc3RlbmVycyhldmVudE5hbWUpO1xuICBpZiAobGlzdG5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdG5lcnMpIHtcbiAgICBhd2FpdCBsaXN0ZW5lci5hcHBseShlbWl0dGVyLCBkYXRhKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQcm9wZXJ0eUFjY2Vzc2libGUob2JqLCBrZXkpIHtcbiAgdHJ5IHtcbiAgICBvYmpba2V5XTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU2VydmVyRXJyb3JSZXNwb25zZShib2R5KSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UoXG4gICAgSlNPTi5zdHJpbmdpZnkoXG4gICAgICBib2R5IGluc3RhbmNlb2YgRXJyb3IgPyB7XG4gICAgICAgIG5hbWU6IGJvZHkubmFtZSxcbiAgICAgICAgbWVzc2FnZTogYm9keS5tZXNzYWdlLFxuICAgICAgICBzdGFjazogYm9keS5zdGFja1xuICAgICAgfSA6IGJvZHlcbiAgICApLFxuICAgIHtcbiAgICAgIHN0YXR1czogNTAwLFxuICAgICAgc3RhdHVzVGV4dDogXCJVbmhhbmRsZWQgRXhjZXB0aW9uXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZUVycm9yKHJlc3BvbnNlKSB7XG4gIHJldHVybiBpc1Byb3BlcnR5QWNjZXNzaWJsZShyZXNwb25zZSwgXCJ0eXBlXCIpICYmIHJlc3BvbnNlLnR5cGUgPT09IFwiZXJyb3JcIjtcbn1cbmZ1bmN0aW9uIGlzTm9kZUxpa2VFcnJvcihlcnJvcjIpIHtcbiAgaWYgKGVycm9yMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghKGVycm9yMiBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gXCJjb2RlXCIgaW4gZXJyb3IyICYmIFwiZXJybm9cIiBpbiBlcnJvcjI7XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0MihvcHRpb25zKSB7XG4gIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIG9wdGlvbnMub25FcnJvcihyZXNwb25zZSk7XG4gICAgfSBlbHNlIGlmIChpc1Jlc3BvbnNlRXJyb3IocmVzcG9uc2UpKSB7XG4gICAgICBvcHRpb25zLm9uUmVxdWVzdEVycm9yKHJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgb3B0aW9ucy5vblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIGNvbnN0IGhhbmRsZVJlc3BvbnNlRXJyb3IgPSBhc3luYyAoZXJyb3IyKSA9PiB7XG4gICAgaWYgKGVycm9yMiBpbnN0YW5jZW9mIEludGVyY2VwdG9yRXJyb3IpIHtcbiAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgaWYgKGlzTm9kZUxpa2VFcnJvcihlcnJvcjIpKSB7XG4gICAgICBvcHRpb25zLm9uRXJyb3IoZXJyb3IyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXJyb3IyIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVSZXNwb25zZShlcnJvcjIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIG9wdGlvbnMuZW1pdHRlci5vbmNlKFwicmVxdWVzdFwiLCAoeyByZXF1ZXN0SWQ6IHBlbmRpbmdSZXF1ZXN0SWQgfSkgPT4ge1xuICAgIGlmIChwZW5kaW5nUmVxdWVzdElkICE9PSBvcHRpb25zLnJlcXVlc3RJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jb250cm9sbGVyW2tSZXNwb25zZVByb21pc2VdLnN0YXRlID09PSBcInBlbmRpbmdcIikge1xuICAgICAgb3B0aW9ucy5jb250cm9sbGVyW2tSZXNwb25zZVByb21pc2VdLnJlc29sdmUodm9pZCAwKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCByZXF1ZXN0QWJvcnRQcm9taXNlID0gbmV3IERlZmVycmVkUHJvbWlzZSgpO1xuICBpZiAob3B0aW9ucy5yZXF1ZXN0LnNpZ25hbCkge1xuICAgIGlmIChvcHRpb25zLnJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJlcXVlc3RBYm9ydFByb21pc2UucmVqZWN0KG9wdGlvbnMucmVxdWVzdC5zaWduYWwucmVhc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5yZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImFib3J0XCIsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICByZXF1ZXN0QWJvcnRQcm9taXNlLnJlamVjdChvcHRpb25zLnJlcXVlc3Quc2lnbmFsLnJlYXNvbik7XG4gICAgICAgIH0sXG4gICAgICAgIHsgb25jZTogdHJ1ZSB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBhd2FpdCB1bnRpbChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdExpc3R0ZW5lcnNQcm9taXNlID0gZW1pdEFzeW5jKG9wdGlvbnMuZW1pdHRlciwgXCJyZXF1ZXN0XCIsIHtcbiAgICAgIHJlcXVlc3RJZDogb3B0aW9ucy5yZXF1ZXN0SWQsXG4gICAgICByZXF1ZXN0OiBvcHRpb25zLnJlcXVlc3QsXG4gICAgICBjb250cm9sbGVyOiBvcHRpb25zLmNvbnRyb2xsZXJcbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgLy8gU2hvcnQtY2lyY3VpdCB0aGUgcmVxdWVzdCBoYW5kbGluZyBwcm9taXNlIGlmIHRoZSByZXF1ZXN0IGdldHMgYWJvcnRlZC5cbiAgICAgIHJlcXVlc3RBYm9ydFByb21pc2UsXG4gICAgICByZXF1ZXN0TGlzdHRlbmVyc1Byb21pc2UsXG4gICAgICBvcHRpb25zLmNvbnRyb2xsZXJba1Jlc3BvbnNlUHJvbWlzZV1cbiAgICBdKTtcbiAgICBjb25zdCBtb2NrZWRSZXNwb25zZSA9IGF3YWl0IG9wdGlvbnMuY29udHJvbGxlcltrUmVzcG9uc2VQcm9taXNlXTtcbiAgICByZXR1cm4gbW9ja2VkUmVzcG9uc2U7XG4gIH0pO1xuICBpZiAocmVxdWVzdEFib3J0UHJvbWlzZS5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgb3B0aW9ucy5vbkVycm9yKHJlcXVlc3RBYm9ydFByb21pc2UucmVqZWN0aW9uUmVhc29uKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgaWYgKGF3YWl0IGhhbmRsZVJlc3BvbnNlRXJyb3IocmVzdWx0LmVycm9yKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVtaXR0ZXIubGlzdGVuZXJDb3VudChcInVuaGFuZGxlZEV4Y2VwdGlvblwiKSA+IDApIHtcbiAgICAgIGNvbnN0IHVuaGFuZGxlZEV4Y2VwdGlvbkNvbnRyb2xsZXIgPSBuZXcgUmVxdWVzdENvbnRyb2xsZXIoXG4gICAgICAgIG9wdGlvbnMucmVxdWVzdFxuICAgICAgKTtcbiAgICAgIGF3YWl0IGVtaXRBc3luYyhvcHRpb25zLmVtaXR0ZXIsIFwidW5oYW5kbGVkRXhjZXB0aW9uXCIsIHtcbiAgICAgICAgZXJyb3I6IHJlc3VsdC5lcnJvcixcbiAgICAgICAgcmVxdWVzdDogb3B0aW9ucy5yZXF1ZXN0LFxuICAgICAgICByZXF1ZXN0SWQ6IG9wdGlvbnMucmVxdWVzdElkLFxuICAgICAgICBjb250cm9sbGVyOiB1bmhhbmRsZWRFeGNlcHRpb25Db250cm9sbGVyXG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHVuaGFuZGxlZEV4Y2VwdGlvbkNvbnRyb2xsZXJba1Jlc3BvbnNlUHJvbWlzZV0uc3RhdGUgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgdW5oYW5kbGVkRXhjZXB0aW9uQ29udHJvbGxlcltrUmVzcG9uc2VQcm9taXNlXS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV4dFJlc3VsdCA9IGF3YWl0IHVudGlsKFxuICAgICAgICAoKSA9PiB1bmhhbmRsZWRFeGNlcHRpb25Db250cm9sbGVyW2tSZXNwb25zZVByb21pc2VdXG4gICAgICApO1xuICAgICAgaWYgKG5leHRSZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3BvbnNlRXJyb3IobmV4dFJlc3VsdC5lcnJvcik7XG4gICAgICB9XG4gICAgICBpZiAobmV4dFJlc3VsdC5kYXRhKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXNwb25zZShuZXh0UmVzdWx0LmRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRpb25zLm9uUmVzcG9uc2UoY3JlYXRlU2VydmVyRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocmVzdWx0LmRhdGEpIHtcbiAgICByZXR1cm4gaGFuZGxlUmVzcG9uc2UocmVzdWx0LmRhdGEpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0Btc3dqcytpbnRlcmNlcHRvcnNAMC4zNy4wL25vZGVfbW9kdWxlcy9AbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9icm93c2VyL2NodW5rLVRYNUdCVEZZLm1qc1xuZnVuY3Rpb24gaGFzQ29uZmlndXJhYmxlR2xvYmFsKHByb3BlcnR5TmFtZSkge1xuICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWxUaGlzLCBwcm9wZXJ0eU5hbWUpO1xuICBpZiAodHlwZW9mIGRlc2NyaXB0b3IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmdldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZXNjcmlwdG9yLmdldCgpID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09IFwidW5kZWZpbmVkXCIgJiYgZGVzY3JpcHRvci52YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZGVzY3JpcHRvci5zZXQgPT09IFwidW5kZWZpbmVkXCIgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBbTVNXXSBGYWlsZWQgdG8gYXBwbHkgaW50ZXJjZXB0b3I6IHRoZSBnbG9iYWwgXFxgJHtwcm9wZXJ0eU5hbWV9XFxgIHByb3BlcnR5IGlzIG5vbi1jb25maWd1cmFibGUuIFRoaXMgaXMgbGlrZWx5IGFuIGlzc3VlIHdpdGggeW91ciBlbnZpcm9ubWVudC4gSWYgeW91IGFyZSB1c2luZyBhIGZyYW1ld29yaywgcGxlYXNlIG9wZW4gYW4gaXNzdWUgYWJvdXQgdGhpcyBpbiB0aGVpciByZXBvc2l0b3J5LmBcbiAgICApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0Btc3dqcytpbnRlcmNlcHRvcnNAMC4zNy4wL25vZGVfbW9kdWxlcy9AbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9icm93c2VyL2NodW5rLUhFUjNOSEJHLm1qc1xuZnVuY3Rpb24gY2FuUGFyc2VVcmwodXJsKSB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh1cmwpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU5ldHdvcmtFcnJvcihjYXVzZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGZldGNoXCIpLCB7XG4gICAgY2F1c2VcbiAgfSk7XG59XG52YXIgUkVRVUVTVF9CT0RZX0hFQURFUlMgPSBbXG4gIFwiY29udGVudC1lbmNvZGluZ1wiLFxuICBcImNvbnRlbnQtbGFuZ3VhZ2VcIixcbiAgXCJjb250ZW50LWxvY2F0aW9uXCIsXG4gIFwiY29udGVudC10eXBlXCIsXG4gIFwiY29udGVudC1sZW5ndGhcIlxuXTtcbnZhciBrUmVkaXJlY3RDb3VudCA9IFN5bWJvbChcImtSZWRpcmVjdENvdW50XCIpO1xuYXN5bmMgZnVuY3Rpb24gZm9sbG93RmV0Y2hSZWRpcmVjdChyZXF1ZXN0LCByZXNwb25zZSkge1xuICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAzMDMgJiYgcmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY3JlYXRlTmV0d29ya0Vycm9yKCkpO1xuICB9XG4gIGNvbnN0IHJlcXVlc3RVcmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgbGV0IGxvY2F0aW9uVXJsO1xuICB0cnkge1xuICAgIGxvY2F0aW9uVXJsID0gbmV3IFVSTChyZXNwb25zZS5oZWFkZXJzLmdldChcImxvY2F0aW9uXCIpLCByZXF1ZXN0LnVybCk7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjcmVhdGVOZXR3b3JrRXJyb3IoZXJyb3IyKSk7XG4gIH1cbiAgaWYgKCEobG9jYXRpb25VcmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCBsb2NhdGlvblVybC5wcm90b2NvbCA9PT0gXCJodHRwczpcIikpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICBjcmVhdGVOZXR3b3JrRXJyb3IoXCJVUkwgc2NoZW1lIG11c3QgYmUgYSBIVFRQKFMpIHNjaGVtZVwiKVxuICAgICk7XG4gIH1cbiAgaWYgKFJlZmxlY3QuZ2V0KHJlcXVlc3QsIGtSZWRpcmVjdENvdW50KSA+IDIwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNyZWF0ZU5ldHdvcmtFcnJvcihcInJlZGlyZWN0IGNvdW50IGV4Y2VlZGVkXCIpKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWVzdCwga1JlZGlyZWN0Q291bnQsIHtcbiAgICB2YWx1ZTogKFJlZmxlY3QuZ2V0KHJlcXVlc3QsIGtSZWRpcmVjdENvdW50KSB8fCAwKSArIDFcbiAgfSk7XG4gIGlmIChyZXF1ZXN0Lm1vZGUgPT09IFwiY29yc1wiICYmIChsb2NhdGlvblVybC51c2VybmFtZSB8fCBsb2NhdGlvblVybC5wYXNzd29yZCkgJiYgIXNhbWVPcmlnaW4ocmVxdWVzdFVybCwgbG9jYXRpb25VcmwpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgY3JlYXRlTmV0d29ya0Vycm9yKCdjcm9zcyBvcmlnaW4gbm90IGFsbG93ZWQgZm9yIHJlcXVlc3QgbW9kZSBcImNvcnNcIicpXG4gICAgKTtcbiAgfVxuICBjb25zdCByZXF1ZXN0SW5pdCA9IHt9O1xuICBpZiAoWzMwMSwgMzAyXS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpICYmIHJlcXVlc3QubWV0aG9kID09PSBcIlBPU1RcIiB8fCByZXNwb25zZS5zdGF0dXMgPT09IDMwMyAmJiAhW1wiSEVBRFwiLCBcIkdFVFwiXS5pbmNsdWRlcyhyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICByZXF1ZXN0SW5pdC5tZXRob2QgPSBcIkdFVFwiO1xuICAgIHJlcXVlc3RJbml0LmJvZHkgPSBudWxsO1xuICAgIFJFUVVFU1RfQk9EWV9IRUFERVJTLmZvckVhY2goKGhlYWRlck5hbWUpID0+IHtcbiAgICAgIHJlcXVlc3QuaGVhZGVycy5kZWxldGUoaGVhZGVyTmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKCFzYW1lT3JpZ2luKHJlcXVlc3RVcmwsIGxvY2F0aW9uVXJsKSkge1xuICAgIHJlcXVlc3QuaGVhZGVycy5kZWxldGUoXCJhdXRob3JpemF0aW9uXCIpO1xuICAgIHJlcXVlc3QuaGVhZGVycy5kZWxldGUoXCJwcm94eS1hdXRob3JpemF0aW9uXCIpO1xuICAgIHJlcXVlc3QuaGVhZGVycy5kZWxldGUoXCJjb29raWVcIik7XG4gICAgcmVxdWVzdC5oZWFkZXJzLmRlbGV0ZShcImhvc3RcIik7XG4gIH1cbiAgcmVxdWVzdEluaXQuaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycztcbiAgcmV0dXJuIGZldGNoKG5ldyBSZXF1ZXN0KGxvY2F0aW9uVXJsLCByZXF1ZXN0SW5pdCkpO1xufVxuZnVuY3Rpb24gc2FtZU9yaWdpbihsZWZ0LCByaWdodCkge1xuICBpZiAobGVmdC5vcmlnaW4gPT09IHJpZ2h0Lm9yaWdpbiAmJiBsZWZ0Lm9yaWdpbiA9PT0gXCJudWxsXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobGVmdC5wcm90b2NvbCA9PT0gcmlnaHQucHJvdG9jb2wgJiYgbGVmdC5ob3N0bmFtZSA9PT0gcmlnaHQuaG9zdG5hbWUgJiYgbGVmdC5wb3J0ID09PSByaWdodC5wb3J0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIEJyb3RsaURlY29tcHJlc3Npb25TdHJlYW0gPSBjbGFzcyBleHRlbmRzIFRyYW5zZm9ybVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW0ludGVyY2VwdG9yc106IEJyb3RsaSBkZWNvbXByZXNzaW9uIG9mIHJlc3BvbnNlIHN0cmVhbXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlclwiXG4gICAgKTtcbiAgICBzdXBlcih7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbnZhciBQaXBlbGluZVN0cmVhbSA9IGNsYXNzIGV4dGVuZHMgVHJhbnNmb3JtU3RyZWFtIHtcbiAgY29uc3RydWN0b3IodHJhbnNmb3JtU3RyZWFtcywgLi4uc3RyYXRlZ2llcykge1xuICAgIHN1cGVyKHt9LCAuLi5zdHJhdGVnaWVzKTtcbiAgICBjb25zdCByZWFkYWJsZSA9IFtzdXBlci5yZWFkYWJsZSwgLi4udHJhbnNmb3JtU3RyZWFtc10ucmVkdWNlKFxuICAgICAgKHJlYWRhYmxlMiwgdHJhbnNmb3JtKSA9PiByZWFkYWJsZTIucGlwZVRocm91Z2godHJhbnNmb3JtKVxuICAgICk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVhZGFibGVcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gcmVhZGFibGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBwYXJzZUNvbnRlbnRFbmNvZGluZyhjb250ZW50RW5jb2RpbmcpIHtcbiAgcmV0dXJuIGNvbnRlbnRFbmNvZGluZy50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiLFwiKS5tYXAoKGNvZGluZykgPT4gY29kaW5nLnRyaW0oKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWNvbXByZXNzaW9uU3RyZWFtKGNvbnRlbnRFbmNvZGluZykge1xuICBpZiAoY29udGVudEVuY29kaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY29kaW5ncyA9IHBhcnNlQ29udGVudEVuY29kaW5nKGNvbnRlbnRFbmNvZGluZyk7XG4gIGlmIChjb2RpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IGNvZGluZ3MucmVkdWNlUmlnaHQoXG4gICAgKHRyYW5zZm9ybWVyczIsIGNvZGluZykgPT4ge1xuICAgICAgaWYgKGNvZGluZyA9PT0gXCJnemlwXCIgfHwgY29kaW5nID09PSBcIngtZ3ppcFwiKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcnMyLmNvbmNhdChuZXcgRGVjb21wcmVzc2lvblN0cmVhbShcImd6aXBcIikpO1xuICAgICAgfSBlbHNlIGlmIChjb2RpbmcgPT09IFwiZGVmbGF0ZVwiKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcnMyLmNvbmNhdChuZXcgRGVjb21wcmVzc2lvblN0cmVhbShcImRlZmxhdGVcIikpO1xuICAgICAgfSBlbHNlIGlmIChjb2RpbmcgPT09IFwiYnJcIikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXJzMi5jb25jYXQobmV3IEJyb3RsaURlY29tcHJlc3Npb25TdHJlYW0oKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm1lcnMyLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNmb3JtZXJzMjtcbiAgICB9LFxuICAgIFtdXG4gICk7XG4gIHJldHVybiBuZXcgUGlwZWxpbmVTdHJlYW0odHJhbnNmb3JtZXJzKTtcbn1cbmZ1bmN0aW9uIGRlY29tcHJlc3NSZXNwb25zZShyZXNwb25zZSkge1xuICBpZiAocmVzcG9uc2UuYm9keSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGRlY29tcHJlc3Npb25TdHJlYW0gPSBjcmVhdGVEZWNvbXByZXNzaW9uU3RyZWFtKFxuICAgIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC1lbmNvZGluZ1wiKSB8fCBcIlwiXG4gICk7XG4gIGlmICghZGVjb21wcmVzc2lvblN0cmVhbSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlc3BvbnNlLmJvZHkucGlwZVRvKGRlY29tcHJlc3Npb25TdHJlYW0ud3JpdGFibGUpO1xuICByZXR1cm4gZGVjb21wcmVzc2lvblN0cmVhbS5yZWFkYWJsZTtcbn1cbnZhciBfRmV0Y2hJbnRlcmNlcHRvciA9IGNsYXNzIGV4dGVuZHMgSW50ZXJjZXB0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihfRmV0Y2hJbnRlcmNlcHRvci5zeW1ib2wpO1xuICB9XG4gIGNoZWNrRW52aXJvbm1lbnQoKSB7XG4gICAgcmV0dXJuIGhhc0NvbmZpZ3VyYWJsZUdsb2JhbChcImZldGNoXCIpO1xuICB9XG4gIGFzeW5jIHNldHVwKCkge1xuICAgIGNvbnN0IHB1cmVGZXRjaCA9IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXB1cmVGZXRjaFtJU19QQVRDSEVEX01PRFVMRV0sXG4gICAgICAnRmFpbGVkIHRvIHBhdGNoIHRoZSBcImZldGNoXCIgbW9kdWxlOiBhbHJlYWR5IHBhdGNoZWQuJ1xuICAgICk7XG4gICAgZ2xvYmFsVGhpcy5mZXRjaCA9IGFzeW5jIChpbnB1dCwgaW5pdCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdElkID0gY3JlYXRlUmVxdWVzdElkKCk7XG4gICAgICBjb25zdCByZXNvbHZlZElucHV0ID0gdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhY2FuUGFyc2VVcmwoaW5wdXQpID8gbmV3IFVSTChpbnB1dCwgbG9jYXRpb24ub3JpZ2luKSA6IGlucHV0O1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlc29sdmVkSW5wdXQsIGluaXQpO1xuICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gbmV3IERlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBSZXF1ZXN0Q29udHJvbGxlcihyZXF1ZXN0KTtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJbJXNdICVzXCIsIHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCk7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiYXdhaXRpbmcgZm9yIHRoZSBtb2NrZWQgcmVzcG9uc2UuLi5cIik7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAnZW1pdHRpbmcgdGhlIFwicmVxdWVzdFwiIGV2ZW50IGZvciAlcyBsaXN0ZW5lcihzKS4uLicsXG4gICAgICAgIHRoaXMuZW1pdHRlci5saXN0ZW5lckNvdW50KFwicmVxdWVzdFwiKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGlzUmVxdWVzdEhhbmRsZWQgPSBhd2FpdCBoYW5kbGVSZXF1ZXN0Mih7XG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICBvblJlc3BvbnNlOiBhc3luYyAocmF3UmVzcG9uc2UpID0+IHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwicmVjZWl2ZWQgbW9ja2VkIHJlc3BvbnNlIVwiLCB7XG4gICAgICAgICAgICByYXdSZXNwb25zZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZFN0cmVhbSA9IGRlY29tcHJlc3NSZXNwb25zZShyYXdSZXNwb25zZSk7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBkZWNvbXByZXNzZWRTdHJlYW0gPT09IG51bGwgPyByYXdSZXNwb25zZSA6IG5ldyBGZXRjaFJlc3BvbnNlKGRlY29tcHJlc3NlZFN0cmVhbSwgcmF3UmVzcG9uc2UpO1xuICAgICAgICAgIEZldGNoUmVzcG9uc2Uuc2V0VXJsKHJlcXVlc3QudXJsLCByZXNwb25zZSk7XG4gICAgICAgICAgaWYgKEZldGNoUmVzcG9uc2UuaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChjcmVhdGVOZXR3b3JrRXJyb3IoXCJ1bmV4cGVjdGVkIHJlZGlyZWN0XCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3QucmVkaXJlY3QgPT09IFwiZm9sbG93XCIpIHtcbiAgICAgICAgICAgICAgZm9sbG93RmV0Y2hSZWRpcmVjdChyZXF1ZXN0LCByZXNwb25zZSkudGhlbihcbiAgICAgICAgICAgICAgICAocmVzcG9uc2UyKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVzb2x2ZShyZXNwb25zZTIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5lbWl0dGVyLmxpc3RlbmVyQ291bnQoXCJyZXNwb25zZVwiKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ2VtaXR0aW5nIHRoZSBcInJlc3BvbnNlXCIgZXZlbnQuLi4nKTtcbiAgICAgICAgICAgIGF3YWl0IGVtaXRBc3luYyh0aGlzLmVtaXR0ZXIsIFwicmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgbW9ja2VkIHJlc3BvbnNlIGZvciB0aGUgXCJyZXNwb25zZVwiIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICAgICAgICAvLyBUaGlzIHdheSwgdGhlIGxpc3RlbmVyIGNhbiByZWFkIHRoZSByZXNwb25zZSBhbmQgbm90IGxvY2sgaXRzIGJvZHlcbiAgICAgICAgICAgICAgLy8gZm9yIHRoZSBhY3R1YWwgZmV0Y2ggY29uc3VtZXIuXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZS5jbG9uZSgpLFxuICAgICAgICAgICAgICBpc01vY2tlZFJlc3BvbnNlOiB0cnVlLFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNwb25zZVByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdEVycm9yOiAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwicmVxdWVzdCBoYXMgZXJyb3JlZCFcIiwgeyByZXNwb25zZSB9KTtcbiAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KGNyZWF0ZU5ldHdvcmtFcnJvcihyZXNwb25zZSkpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAoZXJyb3IyKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcInJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCFcIiwgeyBlcnJvcjogZXJyb3IyIH0pO1xuICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QoZXJyb3IyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoaXNSZXF1ZXN0SGFuZGxlZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwicmVxdWVzdCBoYXMgYmVlbiBoYW5kbGVkLCByZXR1cm5pbmcgbW9jayBwcm9taXNlLi4uXCIpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgXCJubyBtb2NrZWQgcmVzcG9uc2UgcmVjZWl2ZWQsIHBlcmZvcm1pbmcgcmVxdWVzdCBhcy1pcy4uLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIHB1cmVGZXRjaChyZXF1ZXN0KS50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwib3JpZ2luYWwgZmV0Y2ggcGVyZm9ybWVkXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHRoaXMuZW1pdHRlci5saXN0ZW5lckNvdW50KFwicmVzcG9uc2VcIikgPiAwKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnZW1pdHRpbmcgdGhlIFwicmVzcG9uc2VcIiBldmVudC4uLicpO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ2xvbmUgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgICAgICAgIGF3YWl0IGVtaXRBc3luYyh0aGlzLmVtaXR0ZXIsIFwicmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlQ2xvbmUsXG4gICAgICAgICAgICBpc01vY2tlZFJlc3BvbnNlOiBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLmZldGNoLCBJU19QQVRDSEVEX01PRFVMRSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMuZmV0Y2gsIElTX1BBVENIRURfTU9EVUxFLCB7XG4gICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgICAgZ2xvYmFsVGhpcy5mZXRjaCA9IHB1cmVGZXRjaDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICdyZXN0b3JlZCBuYXRpdmUgXCJnbG9iYWxUaGlzLmZldGNoXCIhJyxcbiAgICAgICAgZ2xvYmFsVGhpcy5mZXRjaC5uYW1lXG4gICAgICApO1xuICAgIH0pO1xuICB9XG59O1xudmFyIEZldGNoSW50ZXJjZXB0b3IgPSBfRmV0Y2hJbnRlcmNlcHRvcjtcbkZldGNoSW50ZXJjZXB0b3Iuc3ltYm9sID0gU3ltYm9sKFwiZmV0Y2hcIik7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AbXN3anMraW50ZXJjZXB0b3JzQDAuMzcuMC9ub2RlX21vZHVsZXMvQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvYnJvd3Nlci9jaHVuay00U1JRRks3Ni5tanNcbmZ1bmN0aW9uIGNvbmNhdEFycmF5QnVmZmVyKGxlZnQsIHJpZ2h0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlZnQuYnl0ZUxlbmd0aCArIHJpZ2h0LmJ5dGVMZW5ndGgpO1xuICByZXN1bHQuc2V0KGxlZnQsIDApO1xuICByZXN1bHQuc2V0KHJpZ2h0LCBsZWZ0LmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEV2ZW50UG9seWZpbGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLk5PTkUgPSAwO1xuICAgIHRoaXMuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbiAgICB0aGlzLkFUX1RBUkdFVCA9IDI7XG4gICAgdGhpcy5CVUJCTElOR19QSEFTRSA9IDM7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcbiAgICB0aGlzLnNyY0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5ldmVudFBoYXNlID0gMDtcbiAgICB0aGlzLmlzVHJ1c3RlZCA9IHRydWU7XG4gICAgdGhpcy5jb21wb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsYWJsZSA9IHRydWU7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgdGhpcy5idWJibGVzID0gdHJ1ZTtcbiAgICB0aGlzLmxlbmd0aENvbXB1dGFibGUgPSB0cnVlO1xuICAgIHRoaXMubG9hZGVkID0gMDtcbiAgICB0aGlzLnRvdGFsID0gMDtcbiAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IGZhbHNlO1xuICAgIHRoaXMucmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50YXJnZXQgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50YXJnZXQpIHx8IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY3VycmVudFRhcmdldCkgfHwgbnVsbDtcbiAgICB0aGlzLnRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gIH1cbiAgY29tcG9zZWRQYXRoKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpbml0RXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5idWJibGVzID0gISFidWJibGVzO1xuICAgIHRoaXMuY2FuY2VsYWJsZSA9ICEhY2FuY2VsYWJsZTtcbiAgfVxuICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICB9XG4gIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgfVxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gIH1cbn07XG52YXIgUHJvZ3Jlc3NFdmVudFBvbHlmaWxsID0gY2xhc3MgZXh0ZW5kcyBFdmVudFBvbHlmaWxsIHtcbiAgY29uc3RydWN0b3IodHlwZSwgaW5pdCkge1xuICAgIHN1cGVyKHR5cGUpO1xuICAgIHRoaXMubGVuZ3RoQ29tcHV0YWJsZSA9IChpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0Lmxlbmd0aENvbXB1dGFibGUpIHx8IGZhbHNlO1xuICAgIHRoaXMuY29tcG9zZWQgPSAoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5jb21wb3NlZCkgfHwgZmFsc2U7XG4gICAgdGhpcy5sb2FkZWQgPSAoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5sb2FkZWQpIHx8IDA7XG4gICAgdGhpcy50b3RhbCA9IChpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnRvdGFsKSB8fCAwO1xuICB9XG59O1xudmFyIFNVUFBPUlRTX1BST0dSRVNTX0VWRU5UID0gdHlwZW9mIFByb2dyZXNzRXZlbnQgIT09IFwidW5kZWZpbmVkXCI7XG5mdW5jdGlvbiBjcmVhdGVFdmVudCh0YXJnZXQsIHR5cGUsIGluaXQpIHtcbiAgY29uc3QgcHJvZ3Jlc3NFdmVudHMgPSBbXG4gICAgXCJlcnJvclwiLFxuICAgIFwicHJvZ3Jlc3NcIixcbiAgICBcImxvYWRzdGFydFwiLFxuICAgIFwibG9hZGVuZFwiLFxuICAgIFwibG9hZFwiLFxuICAgIFwidGltZW91dFwiLFxuICAgIFwiYWJvcnRcIlxuICBdO1xuICBjb25zdCBQcm9ncmVzc0V2ZW50Q2xhc3MgPSBTVVBQT1JUU19QUk9HUkVTU19FVkVOVCA/IFByb2dyZXNzRXZlbnQgOiBQcm9ncmVzc0V2ZW50UG9seWZpbGw7XG4gIGNvbnN0IGV2ZW50ID0gcHJvZ3Jlc3NFdmVudHMuaW5jbHVkZXModHlwZSkgPyBuZXcgUHJvZ3Jlc3NFdmVudENsYXNzKHR5cGUsIHtcbiAgICBsZW5ndGhDb21wdXRhYmxlOiB0cnVlLFxuICAgIGxvYWRlZDogKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQubG9hZGVkKSB8fCAwLFxuICAgIHRvdGFsOiAoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC50b3RhbCkgfHwgMFxuICB9KSA6IG5ldyBFdmVudFBvbHlmaWxsKHR5cGUsIHtcbiAgICB0YXJnZXQsXG4gICAgY3VycmVudFRhcmdldDogdGFyZ2V0XG4gIH0pO1xuICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBmaW5kUHJvcGVydHlTb3VyY2UodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgaWYgKCEocHJvcGVydHlOYW1lIGluIHRhcmdldCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBoYXNQcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3BlcnR5TmFtZSk7XG4gIGlmIChoYXNQcm9wZXJ0eSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgcHJvdG90eXBlID0gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICByZXR1cm4gcHJvdG90eXBlID8gZmluZFByb3BlcnR5U291cmNlKHByb3RvdHlwZSwgcHJvcGVydHlOYW1lKSA6IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm94eSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCBvcHRpb25zVG9Qcm94eUhhbmRsZXIob3B0aW9ucykpO1xuICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBvcHRpb25zVG9Qcm94eUhhbmRsZXIob3B0aW9ucykge1xuICBjb25zdCB7IGNvbnN0cnVjdG9yQ2FsbCwgbWV0aG9kQ2FsbCwgZ2V0UHJvcGVydHksIHNldFByb3BlcnR5IH0gPSBvcHRpb25zO1xuICBjb25zdCBoYW5kbGVyID0ge307XG4gIGlmICh0eXBlb2YgY29uc3RydWN0b3JDYWxsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaGFuZGxlci5jb25zdHJ1Y3QgPSBmdW5jdGlvbih0YXJnZXQsIGFyZ3MsIG5ld1RhcmdldCkge1xuICAgICAgY29uc3QgbmV4dCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQobnVsbCwgdGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yQ2FsbC5jYWxsKG5ld1RhcmdldCwgYXJncywgbmV4dCk7XG4gICAgfTtcbiAgfVxuICBoYW5kbGVyLnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcGVydHlOYW1lLCBuZXh0VmFsdWUpIHtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgcHJvcGVydHlTb3VyY2UgPSBmaW5kUHJvcGVydHlTb3VyY2UodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHx8IHRhcmdldDtcbiAgICAgIGNvbnN0IG93bkRlc2NyaXB0b3JzID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgIHByb3BlcnR5U291cmNlLFxuICAgICAgICBwcm9wZXJ0eU5hbWVcbiAgICAgICk7XG4gICAgICBpZiAodHlwZW9mIChvd25EZXNjcmlwdG9ycyA9PSBudWxsID8gdm9pZCAwIDogb3duRGVzY3JpcHRvcnMuc2V0KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvd25EZXNjcmlwdG9ycy5zZXQuYXBwbHkodGFyZ2V0LCBbbmV4dFZhbHVlXSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkocHJvcGVydHlTb3VyY2UsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogbmV4dFZhbHVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2Ygc2V0UHJvcGVydHkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBzZXRQcm9wZXJ0eS5jYWxsKHRhcmdldCwgW3Byb3BlcnR5TmFtZSwgbmV4dFZhbHVlXSwgbmV4dCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG4gIH07XG4gIGhhbmRsZXIuZ2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHJlY2VpdmVyKSB7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHRhcmdldFtwcm9wZXJ0eU5hbWVdO1xuICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIGdldFByb3BlcnR5ICE9PSBcInVuZGVmaW5lZFwiID8gZ2V0UHJvcGVydHkuY2FsbCh0YXJnZXQsIFtwcm9wZXJ0eU5hbWUsIHJlY2VpdmVyXSwgbmV4dCkgOiBuZXh0KCk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dDIgPSB2YWx1ZS5iaW5kKHRhcmdldCwgLi4uYXJncyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kQ2FsbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHJldHVybiBtZXRob2RDYWxsLmNhbGwodGFyZ2V0LCBbcHJvcGVydHlOYW1lLCBhcmdzXSwgbmV4dDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0MigpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICByZXR1cm4gaGFuZGxlcjtcbn1cbmZ1bmN0aW9uIGlzRG9tUGFyc2VyU3VwcG9ydGVkVHlwZSh0eXBlKSB7XG4gIGNvbnN0IHN1cHBvcnRlZFR5cGVzID0gW1xuICAgIFwiYXBwbGljYXRpb24veGh0bWwreG1sXCIsXG4gICAgXCJhcHBsaWNhdGlvbi94bWxcIixcbiAgICBcImltYWdlL3N2Zyt4bWxcIixcbiAgICBcInRleHQvaHRtbFwiLFxuICAgIFwidGV4dC94bWxcIlxuICBdO1xuICByZXR1cm4gc3VwcG9ydGVkVHlwZXMuc29tZSgoc3VwcG9ydGVkVHlwZSkgPT4ge1xuICAgIHJldHVybiB0eXBlLnN0YXJ0c1dpdGgoc3VwcG9ydGVkVHlwZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VKc29uKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICByZXR1cm4ganNvbjtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZShyZXF1ZXN0LCBib2R5KSB7XG4gIGNvbnN0IHJlc3BvbnNlQm9keU9yTnVsbCA9IEZldGNoUmVzcG9uc2UuaXNSZXNwb25zZVdpdGhCb2R5KHJlcXVlc3Quc3RhdHVzKSA/IGJvZHkgOiBudWxsO1xuICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UocmVzcG9uc2VCb2R5T3JOdWxsLCB7XG4gICAgdXJsOiByZXF1ZXN0LnJlc3BvbnNlVVJMLFxuICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IGNyZWF0ZUhlYWRlcnNGcm9tWE1MSHR0cFJlcWVzdEhlYWRlcnMoXG4gICAgICByZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnNGcm9tWE1MSHR0cFJlcWVzdEhlYWRlcnMoaGVhZGVyc1N0cmluZykge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgY29uc3QgbGluZXMgPSBoZWFkZXJzU3RyaW5nLnNwbGl0KC9bXFxyXFxuXSsvKTtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgaWYgKGxpbmUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgW25hbWUsIC4uLnBhcnRzXSA9IGxpbmUuc3BsaXQoXCI6IFwiKTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnRzLmpvaW4oXCI6IFwiKTtcbiAgICBoZWFkZXJzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCb2R5Qnl0ZUxlbmd0aChpbnB1dCkge1xuICBjb25zdCBleHBsaWNpdENvbnRlbnRMZW5ndGggPSBpbnB1dC5oZWFkZXJzLmdldChcImNvbnRlbnQtbGVuZ3RoXCIpO1xuICBpZiAoZXhwbGljaXRDb250ZW50TGVuZ3RoICE9IG51bGwgJiYgZXhwbGljaXRDb250ZW50TGVuZ3RoICE9PSBcIlwiKSB7XG4gICAgcmV0dXJuIE51bWJlcihleHBsaWNpdENvbnRlbnRMZW5ndGgpO1xuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGlucHV0LmFycmF5QnVmZmVyKCk7XG4gIHJldHVybiBidWZmZXIuYnl0ZUxlbmd0aDtcbn1cbnZhciBrSXNSZXF1ZXN0SGFuZGxlZCA9IFN5bWJvbChcImtJc1JlcXVlc3RIYW5kbGVkXCIpO1xudmFyIElTX05PREUyID0gaXNOb2RlUHJvY2VzcygpO1xudmFyIGtGZXRjaFJlcXVlc3QgPSBTeW1ib2woXCJrRmV0Y2hSZXF1ZXN0XCIpO1xudmFyIFhNTEh0dHBSZXF1ZXN0Q29udHJvbGxlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbFJlcXVlc3QsIGxvZ2dlcikge1xuICAgIHRoaXMuaW5pdGlhbFJlcXVlc3QgPSBpbml0aWFsUmVxdWVzdDtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgdGhpcy51cmwgPSBudWxsO1xuICAgIHRoaXNba0lzUmVxdWVzdEhhbmRsZWRdID0gZmFsc2U7XG4gICAgdGhpcy5ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMudXBsb2FkRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IGNyZWF0ZVJlcXVlc3RJZCgpO1xuICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIHRoaXMucmVzcG9uc2VCdWZmZXIgPSBuZXcgVWludDhBcnJheSgpO1xuICAgIHRoaXMucmVxdWVzdCA9IGNyZWF0ZVByb3h5KGluaXRpYWxSZXF1ZXN0LCB7XG4gICAgICBzZXRQcm9wZXJ0eTogKFtwcm9wZXJ0eU5hbWUsIG5leHRWYWx1ZV0sIGludm9rZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJvbnRpbWVvdXRcIjoge1xuICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gcHJvcGVydHlOYW1lLnNsaWNlKFxuICAgICAgICAgICAgICAyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBuZXh0VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kQ2FsbDogKFttZXRob2ROYW1lLCBhcmdzXSwgaW52b2tlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3dpdGNoIChtZXRob2ROYW1lKSB7XG4gICAgICAgICAgY2FzZSBcIm9wZW5cIjoge1xuICAgICAgICAgICAgY29uc3QgW21ldGhvZCwgdXJsXSA9IGFyZ3M7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICB0aGlzLm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICAgICAgICAgIHRoaXMudXJsID0gdG9BYnNvbHV0ZVVybChtZXRob2QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgICAgIHRoaXMudXJsID0gdG9BYnNvbHV0ZVVybCh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSB0aGlzLmxvZ2dlci5leHRlbmQoYCR7dGhpcy5tZXRob2R9ICR7dGhpcy51cmwuaHJlZn1gKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJvcGVuXCIsIHRoaXMubWV0aG9kLCB0aGlzLnVybC5ocmVmKTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImFkZEV2ZW50TGlzdGVuZXJcIjoge1xuICAgICAgICAgICAgY29uc3QgW2V2ZW50TmFtZSwgbGlzdGVuZXJdID0gYXJncztcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudChldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJhZGRFdmVudExpc3RlbmVyXCIsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwic2V0UmVxdWVzdEhlYWRlclwiOiB7XG4gICAgICAgICAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gYXJncztcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEhlYWRlcnMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJzZXRSZXF1ZXN0SGVhZGVyXCIsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInNlbmRcIjoge1xuICAgICAgICAgICAgY29uc3QgW2JvZHldID0gYXJncztcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlc3BvbnNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmV0Y2hSZXNwb25zZSA9IGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgKiBUaGUgYHJlc3BvbnNlYCBwcm9wZXJ0eSBpcyB0aGUgcmlnaHQgd2F5IHRvIHJlYWRcbiAgICAgICAgICAgICAgICAgICAqIHRoZSBhbWJpZ3VvdXMgcmVzcG9uc2UgYm9keSwgYXMgdGhlIHJlcXVlc3QncyBcInJlc3BvbnNlVHlwZVwiIG1heSBkaWZmZXIuXG4gICAgICAgICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8veGhyLnNwZWMud2hhdHdnLm9yZy8jdGhlLXJlc3BvbnNlLWF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3QucmVzcG9uc2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMub25SZXNwb25zZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBmZXRjaFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgaXNNb2NrZWRSZXNwb25zZTogdGhpc1trSXNSZXF1ZXN0SGFuZGxlZF0sXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0OiBmZXRjaFJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHRoaXMucmVxdWVzdElkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB0eXBlb2YgYm9keSA9PT0gXCJzdHJpbmdcIiA/IGVuY29kZUJ1ZmZlcihib2R5KSA6IGJvZHk7XG4gICAgICAgICAgICBjb25zdCBmZXRjaFJlcXVlc3QgPSB0aGlzLnRvRmV0Y2hBcGlSZXF1ZXN0KHJlcXVlc3RCb2R5KTtcbiAgICAgICAgICAgIHRoaXNba0ZldGNoUmVxdWVzdF0gPSBmZXRjaFJlcXVlc3QuY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IG9uY2VSZXF1ZXN0U2V0dGxlZCA9ICgoX2EgPSB0aGlzLm9uUmVxdWVzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICByZXF1ZXN0OiBmZXRjaFJlcXVlc3QsXG4gICAgICAgICAgICAgIHJlcXVlc3RJZDogdGhpcy5yZXF1ZXN0SWRcbiAgICAgICAgICAgIH0pKSB8fCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIG9uY2VSZXF1ZXN0U2V0dGxlZC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzW2tJc1JlcXVlc3RIYW5kbGVkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICBcInJlcXVlc3QgY2FsbGJhY2sgc2V0dGxlZCBidXQgcmVxdWVzdCBoYXMgbm90IGJlZW4gaGFuZGxlZCAocmVhZHlzdGF0ZSAlZCksIHBlcmZvcm1pbmcgYXMtaXMuLi5cIixcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdC5yZWFkeVN0YXRlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoSVNfTk9ERTIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKFxuICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTF9SRVFVRVNUX0lEX0hFQURFUl9OQU1FLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RJZFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludm9rZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVmaW5lKFxuICAgICAgdGhpcy5yZXF1ZXN0LFxuICAgICAgXCJ1cGxvYWRcIixcbiAgICAgIGNyZWF0ZVByb3h5KHRoaXMucmVxdWVzdC51cGxvYWQsIHtcbiAgICAgICAgc2V0UHJvcGVydHk6IChbcHJvcGVydHlOYW1lLCBuZXh0VmFsdWVdLCBpbnZva2UpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcIm9ubG9hZHN0YXJ0XCI6XG4gICAgICAgICAgICBjYXNlIFwib25wcm9ncmVzc1wiOlxuICAgICAgICAgICAgY2FzZSBcIm9uYWJvYXJ0XCI6XG4gICAgICAgICAgICBjYXNlIFwib25lcnJvclwiOlxuICAgICAgICAgICAgY2FzZSBcIm9ubG9hZFwiOlxuICAgICAgICAgICAgY2FzZSBcIm9udGltZW91dFwiOlxuICAgICAgICAgICAgY2FzZSBcIm9ubG9hZGVuZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IHByb3BlcnR5TmFtZS5zbGljZShcbiAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRFdmVudChldmVudE5hbWUsIG5leHRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnZva2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWV0aG9kQ2FsbDogKFttZXRob2ROYW1lLCBhcmdzXSwgaW52b2tlKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWRkRXZlbnRMaXN0ZW5lclwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IFtldmVudE5hbWUsIGxpc3RlbmVyXSA9IGFyZ3M7XG4gICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRFdmVudChldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcInVwbG9hZC5hZGRFdmVudExpc3RlbmVyXCIsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICByZXR1cm4gaW52b2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgcmVnaXN0ZXJFdmVudChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgcHJldkV2ZW50cyA9IHRoaXMuZXZlbnRzLmdldChldmVudE5hbWUpIHx8IFtdO1xuICAgIGNvbnN0IG5leHRFdmVudHMgPSBwcmV2RXZlbnRzLmNvbmNhdChsaXN0ZW5lcik7XG4gICAgdGhpcy5ldmVudHMuc2V0KGV2ZW50TmFtZSwgbmV4dEV2ZW50cyk7XG4gICAgdGhpcy5sb2dnZXIuaW5mbygncmVnaXN0ZXJlZCBldmVudCBcIiVzXCInLCBldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuICByZWdpc3RlclVwbG9hZEV2ZW50KGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBwcmV2RXZlbnRzID0gdGhpcy51cGxvYWRFdmVudHMuZ2V0KGV2ZW50TmFtZSkgfHwgW107XG4gICAgY29uc3QgbmV4dEV2ZW50cyA9IHByZXZFdmVudHMuY29uY2F0KGxpc3RlbmVyKTtcbiAgICB0aGlzLnVwbG9hZEV2ZW50cy5zZXQoZXZlbnROYW1lLCBuZXh0RXZlbnRzKTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKCdyZWdpc3RlcmVkIHVwbG9hZCBldmVudCBcIiVzXCInLCBldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuICAvKipcbiAgICogUmVzcG9uZHMgdG8gdGhlIGN1cnJlbnQgcmVxdWVzdCB3aXRoIHRoZSBnaXZlblxuICAgKiBGZXRjaCBBUEkgYFJlc3BvbnNlYCBpbnN0YW5jZS5cbiAgICovXG4gIGFzeW5jIHJlc3BvbmRXaXRoKHJlc3BvbnNlKSB7XG4gICAgdGhpc1trSXNSZXF1ZXN0SGFuZGxlZF0gPSB0cnVlO1xuICAgIGlmICh0aGlzW2tGZXRjaFJlcXVlc3RdKSB7XG4gICAgICBjb25zdCB0b3RhbFJlcXVlc3RCb2R5TGVuZ3RoID0gYXdhaXQgZ2V0Qm9keUJ5dGVMZW5ndGgoXG4gICAgICAgIHRoaXNba0ZldGNoUmVxdWVzdF1cbiAgICAgICk7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJsb2Fkc3RhcnRcIiwgdGhpcy5yZXF1ZXN0LnVwbG9hZCwge1xuICAgICAgICBsb2FkZWQ6IDAsXG4gICAgICAgIHRvdGFsOiB0b3RhbFJlcXVlc3RCb2R5TGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHRoaXMudHJpZ2dlcihcInByb2dyZXNzXCIsIHRoaXMucmVxdWVzdC51cGxvYWQsIHtcbiAgICAgICAgbG9hZGVkOiB0b3RhbFJlcXVlc3RCb2R5TGVuZ3RoLFxuICAgICAgICB0b3RhbDogdG90YWxSZXF1ZXN0Qm9keUxlbmd0aFxuICAgICAgfSk7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJsb2FkXCIsIHRoaXMucmVxdWVzdC51cGxvYWQsIHtcbiAgICAgICAgbG9hZGVkOiB0b3RhbFJlcXVlc3RCb2R5TGVuZ3RoLFxuICAgICAgICB0b3RhbDogdG90YWxSZXF1ZXN0Qm9keUxlbmd0aFxuICAgICAgfSk7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJsb2FkZW5kXCIsIHRoaXMucmVxdWVzdC51cGxvYWQsIHtcbiAgICAgICAgbG9hZGVkOiB0b3RhbFJlcXVlc3RCb2R5TGVuZ3RoLFxuICAgICAgICB0b3RhbDogdG90YWxSZXF1ZXN0Qm9keUxlbmd0aFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICBcInJlc3BvbmRpbmcgd2l0aCBhIG1vY2tlZCByZXNwb25zZTogJWQgJXNcIixcbiAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICApO1xuICAgIGRlZmluZSh0aGlzLnJlcXVlc3QsIFwic3RhdHVzXCIsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgZGVmaW5lKHRoaXMucmVxdWVzdCwgXCJzdGF0dXNUZXh0XCIsIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgIGRlZmluZSh0aGlzLnJlcXVlc3QsIFwicmVzcG9uc2VVUkxcIiwgdGhpcy51cmwuaHJlZik7XG4gICAgdGhpcy5yZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyID0gbmV3IFByb3h5KHRoaXMucmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlciwge1xuICAgICAgYXBwbHk6IChfLCBfXywgYXJncykgPT4ge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiZ2V0UmVzcG9uc2VIZWFkZXJcIiwgYXJnc1swXSk7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QucmVhZHlTdGF0ZSA8IHRoaXMucmVxdWVzdC5IRUFERVJTX1JFQ0VJVkVEKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcImhlYWRlcnMgbm90IHJlY2VpdmVkIHlldCwgcmV0dXJuaW5nIG51bGxcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVyVmFsdWUgPSByZXNwb25zZS5oZWFkZXJzLmdldChhcmdzWzBdKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAncmVzb2x2ZWQgcmVzcG9uc2UgaGVhZGVyIFwiJXNcIiB0bycsXG4gICAgICAgICAgYXJnc1swXSxcbiAgICAgICAgICBoZWFkZXJWYWx1ZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gaGVhZGVyVmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5yZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycyA9IG5ldyBQcm94eShcbiAgICAgIHRoaXMucmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMsXG4gICAgICB7XG4gICAgICAgIGFwcGx5OiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcImdldEFsbFJlc3BvbnNlSGVhZGVyc1wiKTtcbiAgICAgICAgICBpZiAodGhpcy5yZXF1ZXN0LnJlYWR5U3RhdGUgPCB0aGlzLnJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcImhlYWRlcnMgbm90IHJlY2VpdmVkIHlldCwgcmV0dXJuaW5nIGVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBoZWFkZXJzTGlzdCA9IEFycmF5LmZyb20ocmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpO1xuICAgICAgICAgIGNvbnN0IGFsbEhlYWRlcnMgPSBoZWFkZXJzTGlzdC5tYXAoKFtoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgJHtoZWFkZXJOYW1lfTogJHtoZWFkZXJWYWx1ZX1gO1xuICAgICAgICAgIH0pLmpvaW4oXCJcXHJcXG5cIik7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcInJlc29sdmVkIGFsbCByZXNwb25zZSBoZWFkZXJzIHRvXCIsIGFsbEhlYWRlcnMpO1xuICAgICAgICAgIHJldHVybiBhbGxIZWFkZXJzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLnJlcXVlc3QsIHtcbiAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogKCkgPT4gdGhpcy5yZXNwb25zZVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlVGV4dDoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQ6ICgpID0+IHRoaXMucmVzcG9uc2VUZXh0XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VYTUw6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLnJlc3BvbnNlWE1MXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgdG90YWxSZXNwb25zZUJvZHlMZW5ndGggPSBhd2FpdCBnZXRCb2R5Qnl0ZUxlbmd0aChyZXNwb25zZS5jbG9uZSgpKTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKFwiY2FsY3VsYXRlZCByZXNwb25zZSBib2R5IGxlbmd0aFwiLCB0b3RhbFJlc3BvbnNlQm9keUxlbmd0aCk7XG4gICAgdGhpcy50cmlnZ2VyKFwibG9hZHN0YXJ0XCIsIHRoaXMucmVxdWVzdCwge1xuICAgICAgbG9hZGVkOiAwLFxuICAgICAgdG90YWw6IHRvdGFsUmVzcG9uc2VCb2R5TGVuZ3RoXG4gICAgfSk7XG4gICAgdGhpcy5zZXRSZWFkeVN0YXRlKHRoaXMucmVxdWVzdC5IRUFERVJTX1JFQ0VJVkVEKTtcbiAgICB0aGlzLnNldFJlYWR5U3RhdGUodGhpcy5yZXF1ZXN0LkxPQURJTkcpO1xuICAgIGNvbnN0IGZpbmFsaXplUmVzcG9uc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiZmluYWxpemluZyB0aGUgbW9ja2VkIHJlc3BvbnNlLi4uXCIpO1xuICAgICAgdGhpcy5zZXRSZWFkeVN0YXRlKHRoaXMucmVxdWVzdC5ET05FKTtcbiAgICAgIHRoaXMudHJpZ2dlcihcImxvYWRcIiwgdGhpcy5yZXF1ZXN0LCB7XG4gICAgICAgIGxvYWRlZDogdGhpcy5yZXNwb25zZUJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICB0b3RhbDogdG90YWxSZXNwb25zZUJvZHlMZW5ndGhcbiAgICAgIH0pO1xuICAgICAgdGhpcy50cmlnZ2VyKFwibG9hZGVuZFwiLCB0aGlzLnJlcXVlc3QsIHtcbiAgICAgICAgbG9hZGVkOiB0aGlzLnJlc3BvbnNlQnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgIHRvdGFsOiB0b3RhbFJlc3BvbnNlQm9keUxlbmd0aFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIm1vY2tlZCByZXNwb25zZSBoYXMgYm9keSwgc3RyZWFtaW5nLi4uXCIpO1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIGNvbnN0IHJlYWROZXh0UmVzcG9uc2VCb2R5Q2h1bmsgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcInJlc3BvbnNlIGJvZHkgc3RyZWFtIGRvbmUhXCIpO1xuICAgICAgICAgIGZpbmFsaXplUmVzcG9uc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcInJlYWQgcmVzcG9uc2UgYm9keSBjaHVuazpcIiwgdmFsdWUpO1xuICAgICAgICAgIHRoaXMucmVzcG9uc2VCdWZmZXIgPSBjb25jYXRBcnJheUJ1ZmZlcih0aGlzLnJlc3BvbnNlQnVmZmVyLCB2YWx1ZSk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKFwicHJvZ3Jlc3NcIiwgdGhpcy5yZXF1ZXN0LCB7XG4gICAgICAgICAgICBsb2FkZWQ6IHRoaXMucmVzcG9uc2VCdWZmZXIuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsOiB0b3RhbFJlc3BvbnNlQm9keUxlbmd0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlYWROZXh0UmVzcG9uc2VCb2R5Q2h1bmsoKTtcbiAgICAgIH07XG4gICAgICByZWFkTmV4dFJlc3BvbnNlQm9keUNodW5rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmFsaXplUmVzcG9uc2UoKTtcbiAgICB9XG4gIH1cbiAgcmVzcG9uc2VCdWZmZXJUb1RleHQoKSB7XG4gICAgcmV0dXJuIGRlY29kZUJ1ZmZlcih0aGlzLnJlc3BvbnNlQnVmZmVyKTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgIFwiZ2V0UmVzcG9uc2UgKHJlc3BvbnNlVHlwZTogJXMpXCIsXG4gICAgICB0aGlzLnJlcXVlc3QucmVzcG9uc2VUeXBlXG4gICAgKTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0LnJlYWR5U3RhdGUgIT09IHRoaXMucmVxdWVzdC5ET05FKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnJlcXVlc3QucmVzcG9uc2VUeXBlKSB7XG4gICAgICBjYXNlIFwianNvblwiOiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IHBhcnNlSnNvbih0aGlzLnJlc3BvbnNlQnVmZmVyVG9UZXh0KCkpO1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwicmVzb2x2ZWQgcmVzcG9uc2UgSlNPTlwiLCByZXNwb25zZUpzb24pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VKc29uO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6IHtcbiAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSB0b0FycmF5QnVmZmVyKHRoaXMucmVzcG9uc2VCdWZmZXIpO1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwicmVzb2x2ZWQgcmVzcG9uc2UgQXJyYXlCdWZmZXJcIiwgYXJyYXlCdWZmZXIpO1xuICAgICAgICByZXR1cm4gYXJyYXlCdWZmZXI7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYmxvYlwiOiB7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gdGhpcy5yZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpIHx8IFwidGV4dC9wbGFpblwiO1xuICAgICAgICBjb25zdCByZXNwb25zZUJsb2IgPSBuZXcgQmxvYihbdGhpcy5yZXNwb25zZUJ1ZmZlclRvVGV4dCgpXSwge1xuICAgICAgICAgIHR5cGU6IG1pbWVUeXBlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgIFwicmVzb2x2ZWQgcmVzcG9uc2UgQmxvYiAobWltZSB0eXBlOiAlcylcIixcbiAgICAgICAgICByZXNwb25zZUJsb2IsXG4gICAgICAgICAgbWltZVR5cGVcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlQmxvYjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gdGhpcy5yZXNwb25zZUJ1ZmZlclRvVGV4dCgpO1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICdyZXNvbHZpbmcgXCIlc1wiIHJlc3BvbnNlIHR5cGUgYXMgdGV4dCcsXG4gICAgICAgICAgdGhpcy5yZXF1ZXN0LnJlc3BvbnNlVHlwZSxcbiAgICAgICAgICByZXNwb25zZVRleHRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlVGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHJlc3BvbnNlVGV4dCgpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICB0aGlzLnJlcXVlc3QucmVzcG9uc2VUeXBlID09PSBcIlwiIHx8IHRoaXMucmVxdWVzdC5yZXNwb25zZVR5cGUgPT09IFwidGV4dFwiLFxuICAgICAgXCJJbnZhbGlkU3RhdGVFcnJvcjogVGhlIG9iamVjdCBpcyBpbiBpbnZhbGlkIHN0YXRlLlwiXG4gICAgKTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0LnJlYWR5U3RhdGUgIT09IHRoaXMucmVxdWVzdC5MT0FESU5HICYmIHRoaXMucmVxdWVzdC5yZWFkeVN0YXRlICE9PSB0aGlzLnJlcXVlc3QuRE9ORSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IHRoaXMucmVzcG9uc2VCdWZmZXJUb1RleHQoKTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKCdnZXRSZXNwb25zZVRleHQ6IFwiJXNcIicsIHJlc3BvbnNlVGV4dCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlVGV4dDtcbiAgfVxuICBnZXQgcmVzcG9uc2VYTUwoKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgdGhpcy5yZXF1ZXN0LnJlc3BvbnNlVHlwZSA9PT0gXCJcIiB8fCB0aGlzLnJlcXVlc3QucmVzcG9uc2VUeXBlID09PSBcImRvY3VtZW50XCIsXG4gICAgICBcIkludmFsaWRTdGF0ZUVycm9yOiBUaGUgb2JqZWN0IGlzIGluIGludmFsaWQgc3RhdGUuXCJcbiAgICApO1xuICAgIGlmICh0aGlzLnJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gdGhpcy5yZXF1ZXN0LkRPTkUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHRoaXMucmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSB8fCBcIlwiO1xuICAgIGlmICh0eXBlb2YgRE9NUGFyc2VyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiQ2Fubm90IHJldHJpZXZlIFhNTEh0dHBSZXF1ZXN0IHJlc3BvbnNlIGJvZHkgYXMgWE1MOiBET01QYXJzZXIgaXMgbm90IGRlZmluZWQuIFlvdSBhcmUgbGlrZWx5IHVzaW5nIGFuIGVudmlyb25tZW50IHRoYXQgaXMgbm90IGJyb3dzZXIgb3IgZG9lcyBub3QgcG9seWZpbGwgYnJvd3NlciBnbG9iYWxzIGNvcnJlY3RseS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNEb21QYXJzZXJTdXBwb3J0ZWRUeXBlKGNvbnRlbnRUeXBlKSkge1xuICAgICAgcmV0dXJuIG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoXG4gICAgICAgIHRoaXMucmVzcG9uc2VCdWZmZXJUb1RleHQoKSxcbiAgICAgICAgY29udGVudFR5cGVcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGVycm9yV2l0aChlcnJvcjIpIHtcbiAgICB0aGlzW2tJc1JlcXVlc3RIYW5kbGVkXSA9IHRydWU7XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcInJlc3BvbmRpbmcgd2l0aCBhbiBlcnJvclwiKTtcbiAgICB0aGlzLnNldFJlYWR5U3RhdGUodGhpcy5yZXF1ZXN0LkRPTkUpO1xuICAgIHRoaXMudHJpZ2dlcihcImVycm9yXCIsIHRoaXMucmVxdWVzdCk7XG4gICAgdGhpcy50cmlnZ2VyKFwibG9hZGVuZFwiLCB0aGlzLnJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2l0aW9ucyB0aGlzIHJlcXVlc3QncyBgcmVhZHlTdGF0ZWAgdG8gdGhlIGdpdmVuIG9uZS5cbiAgICovXG4gIHNldFJlYWR5U3RhdGUobmV4dFJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgXCJzZXRSZWFkeVN0YXRlOiAlZCAtPiAlZFwiLFxuICAgICAgdGhpcy5yZXF1ZXN0LnJlYWR5U3RhdGUsXG4gICAgICBuZXh0UmVhZHlTdGF0ZVxuICAgICk7XG4gICAgaWYgKHRoaXMucmVxdWVzdC5yZWFkeVN0YXRlID09PSBuZXh0UmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcInJlYWR5IHN0YXRlIGlkZW50aWNhbCwgc2tpcHBpbmcgdHJhbnNpdGlvbi4uLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVmaW5lKHRoaXMucmVxdWVzdCwgXCJyZWFkeVN0YXRlXCIsIG5leHRSZWFkeVN0YXRlKTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKFwic2V0IHJlYWR5U3RhdGUgdG86ICVkXCIsIG5leHRSZWFkeVN0YXRlKTtcbiAgICBpZiAobmV4dFJlYWR5U3RhdGUgIT09IHRoaXMucmVxdWVzdC5VTlNFTlQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ3RyaWdnZXJyaW5nIFwicmVhZHlzdGF0ZWNoYW5nZVwiIGV2ZW50Li4uJyk7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIHRoaXMucmVxdWVzdCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VycyBnaXZlbiBldmVudCBvbiB0aGUgYFhNTEh0dHBSZXF1ZXN0YCBpbnN0YW5jZS5cbiAgICovXG4gIHRyaWdnZXIoZXZlbnROYW1lLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRhcmdldFtgb24ke2V2ZW50TmFtZX1gXTtcbiAgICBjb25zdCBldmVudCA9IGNyZWF0ZUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBvcHRpb25zKTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKCd0cmlnZ2VyIFwiJXNcIicsIGV2ZW50TmFtZSwgb3B0aW9ucyB8fCBcIlwiKTtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ2ZvdW5kIGEgZGlyZWN0IFwiJXNcIiBjYWxsYmFjaywgY2FsbGluZy4uLicsIGV2ZW50TmFtZSk7XG4gICAgICBjYWxsYmFjay5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgIH1cbiAgICBjb25zdCBldmVudHMgPSB0YXJnZXQgaW5zdGFuY2VvZiBYTUxIdHRwUmVxdWVzdFVwbG9hZCA/IHRoaXMudXBsb2FkRXZlbnRzIDogdGhpcy5ldmVudHM7XG4gICAgZm9yIChjb25zdCBbcmVnaXN0ZXJlZEV2ZW50TmFtZSwgbGlzdGVuZXJzXSBvZiBldmVudHMpIHtcbiAgICAgIGlmIChyZWdpc3RlcmVkRXZlbnROYW1lID09PSBldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAnZm91bmQgJWQgbGlzdGVuZXIocykgZm9yIFwiJXNcIiBldmVudCwgY2FsbGluZy4uLicsXG4gICAgICAgICAgbGlzdGVuZXJzLmxlbmd0aCxcbiAgICAgICAgICBldmVudE5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lci5jYWxsKHRhcmdldCwgZXZlbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgYFhNTEh0dHBSZXF1ZXN0YCBpbnN0YW5jZSBpbnRvIGEgRmV0Y2ggQVBJIGBSZXF1ZXN0YCBpbnN0YW5jZS5cbiAgICovXG4gIHRvRmV0Y2hBcGlSZXF1ZXN0KGJvZHkpIHtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKFwiY29udmVydGluZyByZXF1ZXN0IHRvIGEgRmV0Y2ggQVBJIFJlcXVlc3QuLi5cIik7XG4gICAgY29uc3QgcmVzb2x2ZWRCb2R5ID0gYm9keSBpbnN0YW5jZW9mIERvY3VtZW50ID8gYm9keS5kb2N1bWVudEVsZW1lbnQuaW5uZXJUZXh0IDogYm9keTtcbiAgICBjb25zdCBmZXRjaFJlcXVlc3QgPSBuZXcgUmVxdWVzdCh0aGlzLnVybC5ocmVmLCB7XG4gICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgaGVhZGVyczogdGhpcy5yZXF1ZXN0SGVhZGVycyxcbiAgICAgIC8qKlxuICAgICAgICogQHNlZSBodHRwczovL3hoci5zcGVjLndoYXR3Zy5vcmcvI2Nyb3NzLW9yaWdpbi1jcmVkZW50aWFsc1xuICAgICAgICovXG4gICAgICBjcmVkZW50aWFsczogdGhpcy5yZXF1ZXN0LndpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJzYW1lLW9yaWdpblwiLFxuICAgICAgYm9keTogW1wiR0VUXCIsIFwiSEVBRFwiXS5pbmNsdWRlcyh0aGlzLm1ldGhvZC50b1VwcGVyQ2FzZSgpKSA/IG51bGwgOiByZXNvbHZlZEJvZHlcbiAgICB9KTtcbiAgICBjb25zdCBwcm94eUhlYWRlcnMgPSBjcmVhdGVQcm94eShmZXRjaFJlcXVlc3QuaGVhZGVycywge1xuICAgICAgbWV0aG9kQ2FsbDogKFttZXRob2ROYW1lLCBhcmdzXSwgaW52b2tlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kTmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJhcHBlbmRcIjpcbiAgICAgICAgICBjYXNlIFwic2V0XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IFtoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZV0gPSBhcmdzO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJkZWxldGVcIjoge1xuICAgICAgICAgICAgY29uc3QgW2hlYWRlck5hbWVdID0gYXJncztcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgYFhNTEh0dHBSZXF1ZXN0OiBDYW5ub3QgcmVtb3ZlIGEgXCIke2hlYWRlck5hbWV9XCIgaGVhZGVyIGZyb20gdGhlIEZldGNoIEFQSSByZXByZXNlbnRhdGlvbiBvZiB0aGUgXCIke2ZldGNoUmVxdWVzdC5tZXRob2R9ICR7ZmV0Y2hSZXF1ZXN0LnVybH1cIiByZXF1ZXN0LiBYTUxIdHRwUmVxdWVzdCBoZWFkZXJzIGNhbm5vdCBiZSByZW1vdmVkLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludm9rZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlZmluZShmZXRjaFJlcXVlc3QsIFwiaGVhZGVyc1wiLCBwcm94eUhlYWRlcnMpO1xuICAgIHRoaXMubG9nZ2VyLmluZm8oXCJjb252ZXJ0ZWQgcmVxdWVzdCB0byBhIEZldGNoIEFQSSBSZXF1ZXN0IVwiLCBmZXRjaFJlcXVlc3QpO1xuICAgIHJldHVybiBmZXRjaFJlcXVlc3Q7XG4gIH1cbn07XG5mdW5jdGlvbiB0b0Fic29sdXRlVXJsKHVybCkge1xuICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwodXJsKTtcbiAgfVxuICByZXR1cm4gbmV3IFVSTCh1cmwudG9TdHJpbmcoKSwgbG9jYXRpb24uaHJlZik7XG59XG5mdW5jdGlvbiBkZWZpbmUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB7XG4gICAgLy8gRW5zdXJlIHdyaXRhYmxlIHByb3BlcnRpZXMgdG8gYWxsb3cgcmVkZWZpbmluZyByZWFkb25seSBwcm9wZXJ0aWVzLlxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWVcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVYTUxIdHRwUmVxdWVzdFByb3h5KHtcbiAgZW1pdHRlcixcbiAgbG9nZ2VyXG59KSB7XG4gIGNvbnN0IFhNTEh0dHBSZXF1ZXN0UHJveHkgPSBuZXcgUHJveHkoZ2xvYmFsVGhpcy5YTUxIdHRwUmVxdWVzdCwge1xuICAgIGNvbnN0cnVjdCh0YXJnZXQsIGFyZ3MsIG5ld1RhcmdldCkge1xuICAgICAgbG9nZ2VyLmluZm8oXCJjb25zdHJ1Y3RlZCBuZXcgWE1MSHR0cFJlcXVlc3RcIik7XG4gICAgICBjb25zdCBvcmlnaW5hbFJlcXVlc3QgPSBSZWZsZWN0LmNvbnN0cnVjdChcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBhcmdzLFxuICAgICAgICBuZXdUYXJnZXRcbiAgICAgICk7XG4gICAgICBjb25zdCBwcm90b3R5cGVEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKFxuICAgICAgICB0YXJnZXQucHJvdG90eXBlXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgaW4gcHJvdG90eXBlRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICBvcmlnaW5hbFJlcXVlc3QsXG4gICAgICAgICAgcHJvcGVydHlOYW1lLFxuICAgICAgICAgIHByb3RvdHlwZURlc2NyaXB0b3JzW3Byb3BlcnR5TmFtZV1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHhoclJlcXVlc3RDb250cm9sbGVyID0gbmV3IFhNTEh0dHBSZXF1ZXN0Q29udHJvbGxlcihcbiAgICAgICAgb3JpZ2luYWxSZXF1ZXN0LFxuICAgICAgICBsb2dnZXJcbiAgICAgICk7XG4gICAgICB4aHJSZXF1ZXN0Q29udHJvbGxlci5vblJlcXVlc3QgPSBhc3luYyBmdW5jdGlvbih7IHJlcXVlc3QsIHJlcXVlc3RJZCB9KSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgUmVxdWVzdENvbnRyb2xsZXIocmVxdWVzdCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJhd2FpdGluZyBtb2NrZWQgcmVzcG9uc2UuLi5cIik7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgJ2VtaXR0aW5nIHRoZSBcInJlcXVlc3RcIiBldmVudCBmb3IgJXMgbGlzdGVuZXIocykuLi4nLFxuICAgICAgICAgIGVtaXR0ZXIubGlzdGVuZXJDb3VudChcInJlcXVlc3RcIilcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaXNSZXF1ZXN0SGFuZGxlZCA9IGF3YWl0IGhhbmRsZVJlcXVlc3QyKHtcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgIGVtaXR0ZXIsXG4gICAgICAgICAgb25SZXNwb25zZTogYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3BvbmRXaXRoKHJlc3BvbnNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uUmVxdWVzdEVycm9yOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVycm9yV2l0aChuZXcgVHlwZUVycm9yKFwiTmV0d29yayBlcnJvclwiKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVycm9yOiAoZXJyb3IyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwicmVxdWVzdCBlcnJvcmVkIVwiLCB7IGVycm9yOiBlcnJvcjIgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5lcnJvcldpdGgoZXJyb3IyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlzUmVxdWVzdEhhbmRsZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgXCJubyBtb2NrZWQgcmVzcG9uc2UgcmVjZWl2ZWQsIHBlcmZvcm1pbmcgcmVxdWVzdCBhcy1pcy4uLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHhoclJlcXVlc3RDb250cm9sbGVyLm9uUmVzcG9uc2UgPSBhc3luYyBmdW5jdGlvbih7XG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBpc01vY2tlZFJlc3BvbnNlLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICByZXF1ZXN0SWRcbiAgICAgIH0pIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAnZW1pdHRpbmcgdGhlIFwicmVzcG9uc2VcIiBldmVudCBmb3IgJXMgbGlzdGVuZXIocykuLi4nLFxuICAgICAgICAgIGVtaXR0ZXIubGlzdGVuZXJDb3VudChcInJlc3BvbnNlXCIpXG4gICAgICAgICk7XG4gICAgICAgIGVtaXR0ZXIuZW1pdChcInJlc3BvbnNlXCIsIHtcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICBpc01vY2tlZFJlc3BvbnNlLFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB4aHJSZXF1ZXN0Q29udHJvbGxlci5yZXF1ZXN0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBYTUxIdHRwUmVxdWVzdFByb3h5O1xufVxudmFyIF9YTUxIdHRwUmVxdWVzdEludGVyY2VwdG9yID0gY2xhc3MgZXh0ZW5kcyBJbnRlcmNlcHRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKF9YTUxIdHRwUmVxdWVzdEludGVyY2VwdG9yLmludGVyY2VwdG9yU3ltYm9sKTtcbiAgfVxuICBjaGVja0Vudmlyb25tZW50KCkge1xuICAgIHJldHVybiBoYXNDb25maWd1cmFibGVHbG9iYWwoXCJYTUxIdHRwUmVxdWVzdFwiKTtcbiAgfVxuICBzZXR1cCgpIHtcbiAgICBjb25zdCBsb2dnZXIgPSB0aGlzLmxvZ2dlci5leHRlbmQoXCJzZXR1cFwiKTtcbiAgICBsb2dnZXIuaW5mbygncGF0Y2hpbmcgXCJYTUxIdHRwUmVxdWVzdFwiIG1vZHVsZS4uLicpO1xuICAgIGNvbnN0IFB1cmVYTUxIdHRwUmVxdWVzdCA9IGdsb2JhbFRoaXMuWE1MSHR0cFJlcXVlc3Q7XG4gICAgaW52YXJpYW50KFxuICAgICAgIVB1cmVYTUxIdHRwUmVxdWVzdFtJU19QQVRDSEVEX01PRFVMRV0sXG4gICAgICAnRmFpbGVkIHRvIHBhdGNoIHRoZSBcIlhNTEh0dHBSZXF1ZXN0XCIgbW9kdWxlOiBhbHJlYWR5IHBhdGNoZWQuJ1xuICAgICk7XG4gICAgZ2xvYmFsVGhpcy5YTUxIdHRwUmVxdWVzdCA9IGNyZWF0ZVhNTEh0dHBSZXF1ZXN0UHJveHkoe1xuICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgbG9nZ2VyOiB0aGlzLmxvZ2dlclxuICAgIH0pO1xuICAgIGxvZ2dlci5pbmZvKFxuICAgICAgJ25hdGl2ZSBcIlhNTEh0dHBSZXF1ZXN0XCIgbW9kdWxlIHBhdGNoZWQhJyxcbiAgICAgIGdsb2JhbFRoaXMuWE1MSHR0cFJlcXVlc3QubmFtZVxuICAgICk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMuWE1MSHR0cFJlcXVlc3QsIElTX1BBVENIRURfTU9EVUxFLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcy5YTUxIdHRwUmVxdWVzdCwgSVNfUEFUQ0hFRF9NT0RVTEUsIHtcbiAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgICBnbG9iYWxUaGlzLlhNTEh0dHBSZXF1ZXN0ID0gUHVyZVhNTEh0dHBSZXF1ZXN0O1xuICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICduYXRpdmUgXCJYTUxIdHRwUmVxdWVzdFwiIG1vZHVsZSByZXN0b3JlZCEnLFxuICAgICAgICBnbG9iYWxUaGlzLlhNTEh0dHBSZXF1ZXN0Lm5hbWVcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgWE1MSHR0cFJlcXVlc3RJbnRlcmNlcHRvciA9IF9YTUxIdHRwUmVxdWVzdEludGVyY2VwdG9yO1xuWE1MSHR0cFJlcXVlc3RJbnRlcmNlcHRvci5pbnRlcmNlcHRvclN5bWJvbCA9IFN5bWJvbChcInhoclwiKTtcblxuLy8gc3JjL2Jyb3dzZXIvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlRmFsbGJhY2tSZXF1ZXN0TGlzdGVuZXIudHNcbnZhciBpbXBvcnRfaGFuZGxlUmVxdWVzdDIgPSByZXF1aXJlKFwiLi4vY29yZS91dGlscy9oYW5kbGVSZXF1ZXN0LmpzXCIpO1xudmFyIGltcG9ydF9pc0hhbmRsZXJLaW5kMiA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxzL2ludGVybmFsL2lzSGFuZGxlcktpbmQuanNcIik7XG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja1JlcXVlc3RMaXN0ZW5lcihjb250ZXh0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGludGVyY2VwdG9yID0gbmV3IEJhdGNoSW50ZXJjZXB0b3Ioe1xuICAgIG5hbWU6IFwiZmFsbGJhY2tcIixcbiAgICBpbnRlcmNlcHRvcnM6IFtuZXcgRmV0Y2hJbnRlcmNlcHRvcigpLCBuZXcgWE1MSHR0cFJlcXVlc3RJbnRlcmNlcHRvcigpXVxuICB9KTtcbiAgaW50ZXJjZXB0b3Iub24oXCJyZXF1ZXN0XCIsIGFzeW5jICh7IHJlcXVlc3QsIHJlcXVlc3RJZCwgY29udHJvbGxlciB9KSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdENsb25lRm9yTG9ncyA9IHJlcXVlc3QuY2xvbmUoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0ICgwLCBpbXBvcnRfaGFuZGxlUmVxdWVzdDIuaGFuZGxlUmVxdWVzdCkoXG4gICAgICByZXF1ZXN0LFxuICAgICAgcmVxdWVzdElkLFxuICAgICAgY29udGV4dC5nZXRSZXF1ZXN0SGFuZGxlcnMoKS5maWx0ZXIoKDAsIGltcG9ydF9pc0hhbmRsZXJLaW5kMi5pc0hhbmRsZXJLaW5kKShcIlJlcXVlc3RIYW5kbGVyXCIpKSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjb250ZXh0LmVtaXR0ZXIsXG4gICAgICB7XG4gICAgICAgIG9uTW9ja2VkUmVzcG9uc2UoXywgeyBoYW5kbGVyLCBwYXJzZWRSZXN1bHQgfSkge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5xdWlldCkge1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLm9uY2UoXCJyZXNwb25zZTptb2NrZWRcIiwgKHsgcmVzcG9uc2U6IHJlc3BvbnNlMiB9KSA9PiB7XG4gICAgICAgICAgICAgIGhhbmRsZXIubG9nKHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0Q2xvbmVGb3JMb2dzLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZTIsXG4gICAgICAgICAgICAgICAgcGFyc2VkUmVzdWx0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIGNvbnRyb2xsZXIucmVzcG9uZFdpdGgocmVzcG9uc2UpO1xuICAgIH1cbiAgfSk7XG4gIGludGVyY2VwdG9yLm9uKFxuICAgIFwicmVzcG9uc2VcIixcbiAgICAoeyByZXNwb25zZSwgaXNNb2NrZWRSZXNwb25zZSwgcmVxdWVzdCwgcmVxdWVzdElkIH0pID0+IHtcbiAgICAgIGNvbnRleHQuZW1pdHRlci5lbWl0KFxuICAgICAgICBpc01vY2tlZFJlc3BvbnNlID8gXCJyZXNwb25zZTptb2NrZWRcIiA6IFwicmVzcG9uc2U6YnlwYXNzXCIsXG4gICAgICAgIHtcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgKTtcbiAgaW50ZXJjZXB0b3IuYXBwbHkoKTtcbiAgcmV0dXJuIGludGVyY2VwdG9yO1xufVxuXG4vLyBzcmMvYnJvd3Nlci9zZXR1cFdvcmtlci9zdGFydC9jcmVhdGVGYWxsYmFja1N0YXJ0LnRzXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja1N0YXJ0KGNvbnRleHQpIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0KG9wdGlvbnMpIHtcbiAgICBjb250ZXh0LmZhbGxiYWNrSW50ZXJjZXB0b3IgPSBjcmVhdGVGYWxsYmFja1JlcXVlc3RMaXN0ZW5lcihcbiAgICAgIGNvbnRleHQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBwcmludFN0YXJ0TWVzc2FnZSh7XG4gICAgICBtZXNzYWdlOiBcIk1vY2tpbmcgZW5hYmxlZCAoZmFsbGJhY2sgbW9kZSkuXCIsXG4gICAgICBxdWlldDogb3B0aW9ucy5xdWlldFxuICAgIH0pO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH07XG59XG5cbi8vIHNyYy9icm93c2VyL3NldHVwV29ya2VyL3N0b3AvY3JlYXRlRmFsbGJhY2tTdG9wLnRzXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja1N0b3AoY29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBjb250ZXh0LmZhbGxiYWNrSW50ZXJjZXB0b3I/LmRpc3Bvc2UoKTtcbiAgICBwcmludFN0b3BNZXNzYWdlKHsgcXVpZXQ6IGNvbnRleHQuc3RhcnRPcHRpb25zPy5xdWlldCB9KTtcbiAgfTtcbn1cblxuLy8gc3JjL2Jyb3dzZXIvc2V0dXBXb3JrZXIvc2V0dXBXb3JrZXIudHNcbnZhciBpbXBvcnRfZGV2VXRpbHMxMCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxzL2ludGVybmFsL2RldlV0aWxzLmpzXCIpO1xudmFyIGltcG9ydF9TZXR1cEFwaSA9IHJlcXVpcmUoXCIuLi9jb3JlL1NldHVwQXBpLmpzXCIpO1xudmFyIGltcG9ydF9tZXJnZVJpZ2h0MiA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxzL2ludGVybmFsL21lcmdlUmlnaHQuanNcIik7XG5cbi8vIHNyYy9icm93c2VyL3V0aWxzL3N1cHBvcnRzUmVhZGFibGVTdHJlYW1UcmFuc2Zlci50c1xuZnVuY3Rpb24gc3VwcG9ydHNSZWFkYWJsZVN0cmVhbVRyYW5zZmVyKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydDogKGNvbnRyb2xsZXIpID0+IGNvbnRyb2xsZXIuY2xvc2UoKVxuICAgIH0pO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBtZXNzYWdlLnBvcnQxLnBvc3RNZXNzYWdlKHN0cmVhbSwgW3N0cmVhbV0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gc3JjL2Jyb3dzZXIvc2V0dXBXb3JrZXIvc2V0dXBXb3JrZXIudHNcbnZhciBpbXBvcnRfd2ViU29ja2V0SW50ZXJjZXB0b3IgPSByZXF1aXJlKFwiLi4vY29yZS93cy93ZWJTb2NrZXRJbnRlcmNlcHRvci5qc1wiKTtcbnZhciBpbXBvcnRfaGFuZGxlV2ViU29ja2V0RXZlbnQgPSByZXF1aXJlKFwiLi4vY29yZS93cy9oYW5kbGVXZWJTb2NrZXRFdmVudC5qc1wiKTtcbnZhciBpbXBvcnRfYXR0YWNoV2ViU29ja2V0TG9nZ2VyID0gcmVxdWlyZShcIi4uL2NvcmUvd3MvdXRpbHMvYXR0YWNoV2ViU29ja2V0TG9nZ2VyLmpzXCIpO1xudmFyIFNldHVwV29ya2VyQXBpID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfU2V0dXBBcGkuU2V0dXBBcGkge1xuICBjb250ZXh0O1xuICBzdGFydEhhbmRsZXIgPSBudWxsO1xuICBzdG9wSGFuZGxlciA9IG51bGw7XG4gIGxpc3RlbmVycztcbiAgY29uc3RydWN0b3IoLi4uaGFuZGxlcnMpIHtcbiAgICBzdXBlciguLi5oYW5kbGVycyk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIWlzTm9kZVByb2Nlc3MoKSxcbiAgICAgIGltcG9ydF9kZXZVdGlsczEwLmRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgYHNldHVwV29ya2VyYCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiBDb25zaWRlciB1c2luZyBgc2V0dXBTZXJ2ZXJgIGZvciBOb2RlLmpzIGVudmlyb25tZW50IGluc3RlYWQuXCJcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jcmVhdGVXb3JrZXJDb250ZXh0KCk7XG4gIH1cbiAgY3JlYXRlV29ya2VyQ29udGV4dCgpIHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgLy8gTW9ja2luZyBpcyBub3QgY29uc2lkZXJlZCBlbmFibGVkIHVudGlsIHRoZSB3b3JrZXJcbiAgICAgIC8vIHNpZ25hbHMgYmFjayB0aGUgc3VjY2Vzc2Z1bCBhY3RpdmF0aW9uIGV2ZW50LlxuICAgICAgaXNNb2NraW5nRW5hYmxlZDogZmFsc2UsXG4gICAgICBzdGFydE9wdGlvbnM6IG51bGwsXG4gICAgICB3b3JrZXI6IG51bGwsXG4gICAgICBnZXRSZXF1ZXN0SGFuZGxlcnM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnNDb250cm9sbGVyLmN1cnJlbnRIYW5kbGVycygpO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdHJhdGlvbjogbnVsbCxcbiAgICAgIHJlcXVlc3RzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgd29ya2VyQ2hhbm5lbDoge1xuICAgICAgICBvbjogKGV2ZW50VHlwZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICB0aGlzLmNvbnRleHQuZXZlbnRzLmFkZExpc3RlbmVyKG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLCBcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlICE9PSB0aGlzLmNvbnRleHQud29ya2VyKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhldmVudCwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbmQ6ICh0eXBlKSA9PiB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0Lndvcmtlcj8ucG9zdE1lc3NhZ2UodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgYWRkTGlzdGVuZXI6ICh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUFsbExpc3RlbmVyczogKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2sgfSBvZiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2U6IChldmVudFR5cGUpID0+IHtcbiAgICAgICAgICBjb25zdCBiaW5kaW5ncyA9IFtdO1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVJbmNvbWluZ01lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goXG4gICAgICAgICAgICAgIHRoaXMuY29udGV4dC5ldmVudHMuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIsXG4gICAgICAgICAgICAgICAgXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgaGFuZGxlSW5jb21pbmdNZXNzYWdlXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHRoaXMuY29udGV4dC5ldmVudHMuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIsXG4gICAgICAgICAgICAgICAgXCJtZXNzYWdlZXJyb3JcIixcbiAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGJpbmRpbmdzLmZvckVhY2goKHVuYmluZCkgPT4gdW5iaW5kKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3VwcG9ydHM6IHtcbiAgICAgICAgc2VydmljZVdvcmtlckFwaTogIShcInNlcnZpY2VXb3JrZXJcIiBpbiBuYXZpZ2F0b3IpIHx8IGxvY2F0aW9uLnByb3RvY29sID09PSBcImZpbGU6XCIsXG4gICAgICAgIHJlYWRhYmxlU3RyZWFtVHJhbnNmZXI6IHN1cHBvcnRzUmVhZGFibGVTdHJlYW1UcmFuc2ZlcigpXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnN0YXJ0SGFuZGxlciA9IGNvbnRleHQuc3VwcG9ydHMuc2VydmljZVdvcmtlckFwaSA/IGNyZWF0ZUZhbGxiYWNrU3RhcnQoY29udGV4dCkgOiBjcmVhdGVTdGFydEhhbmRsZXIoY29udGV4dCk7XG4gICAgdGhpcy5zdG9wSGFuZGxlciA9IGNvbnRleHQuc3VwcG9ydHMuc2VydmljZVdvcmtlckFwaSA/IGNyZWF0ZUZhbGxiYWNrU3RvcChjb250ZXh0KSA6IGNyZWF0ZVN0b3AoY29udGV4dCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgYXN5bmMgc3RhcnQob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMud2FpdFVudGlsUmVhZHkgPT09IHRydWUpIHtcbiAgICAgIGltcG9ydF9kZXZVdGlsczEwLmRldlV0aWxzLndhcm4oXG4gICAgICAgICdUaGUgXCJ3YWl0VW50aWxSZWFkeVwiIG9wdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgcmVtb3ZlIGl0IGZyb20gdGhpcyBcIndvcmtlci5zdGFydCgpXCIgY2FsbC4gRm9sbG93IHRoZSByZWNvbW1lbmRlZCBCcm93c2VyIGludGVncmF0aW9uIChodHRwczovL21zd2pzLmlvL2RvY3MvaW50ZWdyYXRpb25zL2Jyb3dzZXIpIHRvIGVsaW1pbmF0ZSBhbnkgcmFjZSBjb25kaXRpb25zIGJldHdlZW4gdGhlIFNlcnZpY2UgV29ya2VyIHJlZ2lzdHJhdGlvbiBhbmQgYW55IHJlcXVlc3RzIG1hZGUgYnkgeW91ciBhcHBsaWNhdGlvbiBvbiBpbml0aWFsIHJlbmRlci4nXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmNvbnRleHQuc3RhcnRPcHRpb25zID0gKDAsIGltcG9ydF9tZXJnZVJpZ2h0Mi5tZXJnZVJpZ2h0KShcbiAgICAgIERFRkFVTFRfU1RBUlRfT1BUSU9OUyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgICgwLCBpbXBvcnRfaGFuZGxlV2ViU29ja2V0RXZlbnQuaGFuZGxlV2ViU29ja2V0RXZlbnQpKHtcbiAgICAgIGdldFVuaGFuZGxlZFJlcXVlc3RTdHJhdGVneTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0T3B0aW9ucy5vblVuaGFuZGxlZFJlcXVlc3Q7XG4gICAgICB9LFxuICAgICAgZ2V0SGFuZGxlcnM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnNDb250cm9sbGVyLmN1cnJlbnRIYW5kbGVycygpO1xuICAgICAgfSxcbiAgICAgIG9uTW9ja2VkQ29ubmVjdGlvbjogKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuc3RhcnRPcHRpb25zLnF1aWV0KSB7XG4gICAgICAgICAgKDAsIGltcG9ydF9hdHRhY2hXZWJTb2NrZXRMb2dnZXIuYXR0YWNoV2ViU29ja2V0TG9nZ2VyKShjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUGFzc3Rocm91Z2hDb25uZWN0aW9uKCkge1xuICAgICAgfVxuICAgIH0pO1xuICAgIGltcG9ydF93ZWJTb2NrZXRJbnRlcmNlcHRvci53ZWJTb2NrZXRJbnRlcmNlcHRvci5hcHBseSgpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgIGltcG9ydF93ZWJTb2NrZXRJbnRlcmNlcHRvci53ZWJTb2NrZXRJbnRlcmNlcHRvci5kaXNwb3NlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc3RhcnRIYW5kbGVyKHRoaXMuY29udGV4dC5zdGFydE9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuY29udGV4dC5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5jb250ZXh0LmVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zdG9wSGFuZGxlcigpO1xuICB9XG59O1xuZnVuY3Rpb24gc2V0dXBXb3JrZXIoLi4uaGFuZGxlcnMpIHtcbiAgcmV0dXJuIG5ldyBTZXR1cFdvcmtlckFwaSguLi5oYW5kbGVycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/browser/index.js\n"));

/***/ }),

/***/ "../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/isHandlerKind.js":
/*!********************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/isHandlerKind.js ***!
  \********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar isHandlerKind_exports = {};\n__export(isHandlerKind_exports, {\n  isHandlerKind: () => isHandlerKind\n});\nmodule.exports = __toCommonJS(isHandlerKind_exports);\nfunction isHandlerKind(kind) {\n  return (input) => {\n    return input != null && typeof input === \"object\" && \"__kind\" in input && input.__kind === kind;\n  };\n}\n//# sourceMappingURL=isHandlerKind.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS91dGlscy9pbnRlcm5hbC9pc0hhbmRsZXJLaW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvaHllb25qb25nL0RvY3VtZW50cy9HaXRIdWIvbXN3LXNjZW5hcmlvcy9ub2RlX21vZHVsZXMvLnBucG0vbXN3QDIuNi42X0B0eXBlcytub2RlQDIyLjEwLjFfdHlwZXNjcmlwdEA1LjkuMi9ub2RlX21vZHVsZXMvbXN3L2xpYi9jb3JlL3V0aWxzL2ludGVybmFsL2lzSGFuZGxlcktpbmQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGlzSGFuZGxlcktpbmRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaXNIYW5kbGVyS2luZF9leHBvcnRzLCB7XG4gIGlzSGFuZGxlcktpbmQ6ICgpID0+IGlzSGFuZGxlcktpbmRcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoaXNIYW5kbGVyS2luZF9leHBvcnRzKTtcbmZ1bmN0aW9uIGlzSGFuZGxlcktpbmQoa2luZCkge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgcmV0dXJuIGlucHV0ICE9IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICYmIFwiX19raW5kXCIgaW4gaW5wdXQgJiYgaW5wdXQuX19raW5kID09PSBraW5kO1xuICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNIYW5kbGVyS2luZC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/isHandlerKind.js\n"));

/***/ }),

/***/ "../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/isObject.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/isObject.js ***!
  \***************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar isObject_exports = {};\n__export(isObject_exports, {\n  isObject: () => isObject\n});\nmodule.exports = __toCommonJS(isObject_exports);\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n}\n//# sourceMappingURL=isObject.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS91dGlscy9pbnRlcm5hbC9pc09iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvaHllb25qb25nL0RvY3VtZW50cy9HaXRIdWIvbXN3LXNjZW5hcmlvcy9ub2RlX21vZHVsZXMvLnBucG0vbXN3QDIuNi42X0B0eXBlcytub2RlQDIyLjEwLjFfdHlwZXNjcmlwdEA1LjkuMi9ub2RlX21vZHVsZXMvbXN3L2xpYi9jb3JlL3V0aWxzL2ludGVybmFsL2lzT2JqZWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBpc09iamVjdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChpc09iamVjdF9leHBvcnRzLCB7XG4gIGlzT2JqZWN0OiAoKSA9PiBpc09iamVjdFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpc09iamVjdF9leHBvcnRzKTtcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc09iamVjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/isObject.js\n"));

/***/ }),

/***/ "../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/mergeRight.js":
/*!*****************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/mergeRight.js ***!
  \*****************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar mergeRight_exports = {};\n__export(mergeRight_exports, {\n  mergeRight: () => mergeRight\n});\nmodule.exports = __toCommonJS(mergeRight_exports);\nvar import_isObject = __webpack_require__(/*! ./isObject.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/isObject.js\");\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce(\n    (result, [key, rightValue]) => {\n      const leftValue = result[key];\n      if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n        result[key] = leftValue.concat(rightValue);\n        return result;\n      }\n      if ((0, import_isObject.isObject)(leftValue) && (0, import_isObject.isObject)(rightValue)) {\n        result[key] = mergeRight(leftValue, rightValue);\n        return result;\n      }\n      result[key] = rightValue;\n      return result;\n    },\n    Object.assign({}, left)\n  );\n}\n//# sourceMappingURL=mergeRight.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS91dGlscy9pbnRlcm5hbC9tZXJnZVJpZ2h0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc0pBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvaHllb25qb25nL0RvY3VtZW50cy9HaXRIdWIvbXN3LXNjZW5hcmlvcy9ub2RlX21vZHVsZXMvLnBucG0vbXN3QDIuNi42X0B0eXBlcytub2RlQDIyLjEwLjFfdHlwZXNjcmlwdEA1LjkuMi9ub2RlX21vZHVsZXMvbXN3L2xpYi9jb3JlL3V0aWxzL2ludGVybmFsL21lcmdlUmlnaHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIG1lcmdlUmlnaHRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobWVyZ2VSaWdodF9leHBvcnRzLCB7XG4gIG1lcmdlUmlnaHQ6ICgpID0+IG1lcmdlUmlnaHRcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMobWVyZ2VSaWdodF9leHBvcnRzKTtcbnZhciBpbXBvcnRfaXNPYmplY3QgPSByZXF1aXJlKFwiLi9pc09iamVjdC5qc1wiKTtcbmZ1bmN0aW9uIG1lcmdlUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJpZ2h0KS5yZWR1Y2UoXG4gICAgKHJlc3VsdCwgW2tleSwgcmlnaHRWYWx1ZV0pID0+IHtcbiAgICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHJlc3VsdFtrZXldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGVmdFZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHJpZ2h0VmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gbGVmdFZhbHVlLmNvbmNhdChyaWdodFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICgoMCwgaW1wb3J0X2lzT2JqZWN0LmlzT2JqZWN0KShsZWZ0VmFsdWUpICYmICgwLCBpbXBvcnRfaXNPYmplY3QuaXNPYmplY3QpKHJpZ2h0VmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VSaWdodChsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmVzdWx0W2tleV0gPSByaWdodFZhbHVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIE9iamVjdC5hc3NpZ24oe30sIGxlZnQpXG4gICk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZVJpZ2h0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/mergeRight.js\n"));

/***/ }),

/***/ "../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/toResponseInit.js":
/*!************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/toResponseInit.js ***!
  \************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar toResponseInit_exports = {};\n__export(toResponseInit_exports, {\n  toResponseInit: () => toResponseInit\n});\nmodule.exports = __toCommonJS(toResponseInit_exports);\nfunction toResponseInit(response) {\n  return {\n    status: response.status,\n    statusText: response.statusText,\n    headers: Object.fromEntries(response.headers.entries())\n  };\n}\n//# sourceMappingURL=toResponseInit.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS91dGlscy90b1Jlc3BvbnNlSW5pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oeWVvbmpvbmcvRG9jdW1lbnRzL0dpdEh1Yi9tc3ctc2NlbmFyaW9zL25vZGVfbW9kdWxlcy8ucG5wbS9tc3dAMi42LjZfQHR5cGVzK25vZGVAMjIuMTAuMV90eXBlc2NyaXB0QDUuOS4yL25vZGVfbW9kdWxlcy9tc3cvbGliL2NvcmUvdXRpbHMvdG9SZXNwb25zZUluaXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHRvUmVzcG9uc2VJbml0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHRvUmVzcG9uc2VJbml0X2V4cG9ydHMsIHtcbiAgdG9SZXNwb25zZUluaXQ6ICgpID0+IHRvUmVzcG9uc2VJbml0XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHRvUmVzcG9uc2VJbml0X2V4cG9ydHMpO1xuZnVuY3Rpb24gdG9SZXNwb25zZUluaXQocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSlcbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvUmVzcG9uc2VJbml0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/toResponseInit.js\n"));

/***/ }),

/***/ "../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/handleWebSocketEvent.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/handleWebSocketEvent.js ***!
  \***************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar handleWebSocketEvent_exports = {};\n__export(handleWebSocketEvent_exports, {\n  handleWebSocketEvent: () => handleWebSocketEvent\n});\nmodule.exports = __toCommonJS(handleWebSocketEvent_exports);\nvar import_WebSocketHandler = __webpack_require__(/*! ../handlers/WebSocketHandler.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/handlers/WebSocketHandler.js\");\nvar import_webSocketInterceptor = __webpack_require__(/*! ./webSocketInterceptor.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/webSocketInterceptor.js\");\nvar import_onUnhandledRequest = __webpack_require__(/*! ../utils/request/onUnhandledRequest.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/request/onUnhandledRequest.js\");\nvar import_isHandlerKind = __webpack_require__(/*! ../utils/internal/isHandlerKind.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/isHandlerKind.js\");\nfunction handleWebSocketEvent(options) {\n  import_webSocketInterceptor.webSocketInterceptor.on(\"connection\", async (connection) => {\n    const handlers = options.getHandlers();\n    const connectionEvent = new MessageEvent(\"connection\", {\n      data: connection\n    });\n    const matchingHandlers = [];\n    for (const handler of handlers) {\n      if ((0, import_isHandlerKind.isHandlerKind)(\"EventHandler\")(handler) && handler.predicate({\n        event: connectionEvent,\n        parsedResult: handler.parse({\n          event: connectionEvent\n        })\n      })) {\n        matchingHandlers.push(handler);\n      }\n    }\n    if (matchingHandlers.length > 0) {\n      options?.onMockedConnection(connection);\n      for (const handler of matchingHandlers) {\n        handler[import_WebSocketHandler.kDispatchEvent](connectionEvent);\n      }\n    } else {\n      const request = new Request(connection.client.url, {\n        headers: {\n          upgrade: \"websocket\",\n          connection: \"upgrade\"\n        }\n      });\n      await (0, import_onUnhandledRequest.onUnhandledRequest)(\n        request,\n        options.getUnhandledRequestStrategy()\n      ).catch((error) => {\n        const errorEvent = new Event(\"error\");\n        Object.defineProperty(errorEvent, \"cause\", {\n          enumerable: true,\n          configurable: false,\n          value: error\n        });\n        connection.client.socket.dispatchEvent(errorEvent);\n      });\n      options?.onPassthroughConnection(connection);\n      connection.server.connect();\n    }\n  });\n}\n//# sourceMappingURL=handleWebSocketEvent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS93cy9oYW5kbGVXZWJTb2NrZXRFdmVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDhCQUE4QixtQkFBTyxDQUFDLDBLQUFpQztBQUN2RSxrQ0FBa0MsbUJBQU8sQ0FBQyxrS0FBMkI7QUFDckUsZ0NBQWdDLG1CQUFPLENBQUMsd0xBQXdDO0FBQ2hGLDJCQUEyQixtQkFBTyxDQUFDLGdMQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2h5ZW9uam9uZy9Eb2N1bWVudHMvR2l0SHViL21zdy1zY2VuYXJpb3Mvbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS93cy9oYW5kbGVXZWJTb2NrZXRFdmVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgaGFuZGxlV2ViU29ja2V0RXZlbnRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaGFuZGxlV2ViU29ja2V0RXZlbnRfZXhwb3J0cywge1xuICBoYW5kbGVXZWJTb2NrZXRFdmVudDogKCkgPT4gaGFuZGxlV2ViU29ja2V0RXZlbnRcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoaGFuZGxlV2ViU29ja2V0RXZlbnRfZXhwb3J0cyk7XG52YXIgaW1wb3J0X1dlYlNvY2tldEhhbmRsZXIgPSByZXF1aXJlKFwiLi4vaGFuZGxlcnMvV2ViU29ja2V0SGFuZGxlci5qc1wiKTtcbnZhciBpbXBvcnRfd2ViU29ja2V0SW50ZXJjZXB0b3IgPSByZXF1aXJlKFwiLi93ZWJTb2NrZXRJbnRlcmNlcHRvci5qc1wiKTtcbnZhciBpbXBvcnRfb25VbmhhbmRsZWRSZXF1ZXN0ID0gcmVxdWlyZShcIi4uL3V0aWxzL3JlcXVlc3Qvb25VbmhhbmRsZWRSZXF1ZXN0LmpzXCIpO1xudmFyIGltcG9ydF9pc0hhbmRsZXJLaW5kID0gcmVxdWlyZShcIi4uL3V0aWxzL2ludGVybmFsL2lzSGFuZGxlcktpbmQuanNcIik7XG5mdW5jdGlvbiBoYW5kbGVXZWJTb2NrZXRFdmVudChvcHRpb25zKSB7XG4gIGltcG9ydF93ZWJTb2NrZXRJbnRlcmNlcHRvci53ZWJTb2NrZXRJbnRlcmNlcHRvci5vbihcImNvbm5lY3Rpb25cIiwgYXN5bmMgKGNvbm5lY3Rpb24pID0+IHtcbiAgICBjb25zdCBoYW5kbGVycyA9IG9wdGlvbnMuZ2V0SGFuZGxlcnMoKTtcbiAgICBjb25zdCBjb25uZWN0aW9uRXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KFwiY29ubmVjdGlvblwiLCB7XG4gICAgICBkYXRhOiBjb25uZWN0aW9uXG4gICAgfSk7XG4gICAgY29uc3QgbWF0Y2hpbmdIYW5kbGVycyA9IFtdO1xuICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgaWYgKCgwLCBpbXBvcnRfaXNIYW5kbGVyS2luZC5pc0hhbmRsZXJLaW5kKShcIkV2ZW50SGFuZGxlclwiKShoYW5kbGVyKSAmJiBoYW5kbGVyLnByZWRpY2F0ZSh7XG4gICAgICAgIGV2ZW50OiBjb25uZWN0aW9uRXZlbnQsXG4gICAgICAgIHBhcnNlZFJlc3VsdDogaGFuZGxlci5wYXJzZSh7XG4gICAgICAgICAgZXZlbnQ6IGNvbm5lY3Rpb25FdmVudFxuICAgICAgICB9KVxuICAgICAgfSkpIHtcbiAgICAgICAgbWF0Y2hpbmdIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2hpbmdIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBvcHRpb25zPy5vbk1vY2tlZENvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgbWF0Y2hpbmdIYW5kbGVycykge1xuICAgICAgICBoYW5kbGVyW2ltcG9ydF9XZWJTb2NrZXRIYW5kbGVyLmtEaXNwYXRjaEV2ZW50XShjb25uZWN0aW9uRXZlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoY29ubmVjdGlvbi5jbGllbnQudXJsLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICB1cGdyYWRlOiBcIndlYnNvY2tldFwiLFxuICAgICAgICAgIGNvbm5lY3Rpb246IFwidXBncmFkZVwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYXdhaXQgKDAsIGltcG9ydF9vblVuaGFuZGxlZFJlcXVlc3Qub25VbmhhbmRsZWRSZXF1ZXN0KShcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgb3B0aW9ucy5nZXRVbmhhbmRsZWRSZXF1ZXN0U3RyYXRlZ3koKVxuICAgICAgKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JFdmVudCA9IG5ldyBFdmVudChcImVycm9yXCIpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JFdmVudCwgXCJjYXVzZVwiLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBlcnJvclxuICAgICAgICB9KTtcbiAgICAgICAgY29ubmVjdGlvbi5jbGllbnQuc29ja2V0LmRpc3BhdGNoRXZlbnQoZXJyb3JFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIG9wdGlvbnM/Lm9uUGFzc3Rocm91Z2hDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgY29ubmVjdGlvbi5zZXJ2ZXIuY29ubmVjdCgpO1xuICAgIH1cbiAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYW5kbGVXZWJTb2NrZXRFdmVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/handleWebSocketEvent.js\n"));

/***/ }),

/***/ "../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/attachWebSocketLogger.js":
/*!**********************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/attachWebSocketLogger.js ***!
  \**********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar attachWebSocketLogger_exports = {};\n__export(attachWebSocketLogger_exports, {\n  attachWebSocketLogger: () => attachWebSocketLogger,\n  logConnectionOpen: () => logConnectionOpen\n});\nmodule.exports = __toCommonJS(attachWebSocketLogger_exports);\nvar import_devUtils = __webpack_require__(/*! ../../utils/internal/devUtils.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/internal/devUtils.js\");\nvar import_getTimestamp = __webpack_require__(/*! ../../utils/logging/getTimestamp.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/logging/getTimestamp.js\");\nvar import_toPublicUrl = __webpack_require__(/*! ../../utils/request/toPublicUrl.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/utils/request/toPublicUrl.js\");\nvar import_getMessageLength = __webpack_require__(/*! ./getMessageLength.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/getMessageLength.js\");\nvar import_getPublicData = __webpack_require__(/*! ./getPublicData.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/getPublicData.js\");\nconst colors = {\n  system: \"#3b82f6\",\n  outgoing: \"#22c55e\",\n  incoming: \"#ef4444\",\n  mocked: \"#ff6a33\"\n};\nfunction attachWebSocketLogger(connection) {\n  const { client, server } = connection;\n  logConnectionOpen(client);\n  client.addEventListener(\"message\", (event) => {\n    logOutgoingClientMessage(event);\n  });\n  client.addEventListener(\"close\", (event) => {\n    logConnectionClose(event);\n  });\n  client.socket.addEventListener(\"error\", (event) => {\n    logClientError(event);\n  });\n  client.send = new Proxy(client.send, {\n    apply(target, thisArg, args) {\n      const [data] = args;\n      const messageEvent = new MessageEvent(\"message\", { data });\n      Object.defineProperties(messageEvent, {\n        currentTarget: {\n          enumerable: true,\n          writable: false,\n          value: client.socket\n        },\n        target: {\n          enumerable: true,\n          writable: false,\n          value: client.socket\n        }\n      });\n      queueMicrotask(() => {\n        logIncomingMockedClientMessage(messageEvent);\n      });\n      return Reflect.apply(target, thisArg, args);\n    }\n  });\n  server.addEventListener(\n    \"open\",\n    () => {\n      server.addEventListener(\"message\", (event) => {\n        logIncomingServerMessage(event);\n      });\n    },\n    { once: true }\n  );\n  server.send = new Proxy(server.send, {\n    apply(target, thisArg, args) {\n      const [data] = args;\n      const messageEvent = new MessageEvent(\"message\", { data });\n      Object.defineProperties(messageEvent, {\n        currentTarget: {\n          enumerable: true,\n          writable: false,\n          value: server.socket\n        },\n        target: {\n          enumerable: true,\n          writable: false,\n          value: server.socket\n        }\n      });\n      logOutgoingMockedClientMessage(messageEvent);\n      return Reflect.apply(target, thisArg, args);\n    }\n  });\n}\nfunction logConnectionOpen(client) {\n  const publicUrl = (0, import_toPublicUrl.toPublicUrl)(client.url);\n  console.groupCollapsed(\n    import_devUtils.devUtils.formatMessage(`${(0, import_getTimestamp.getTimestamp)()} %c\\u25B6%c ${publicUrl}`),\n    `color:${colors.system}`,\n    \"color:inherit\"\n  );\n  console.log(\"Client:\", client.socket);\n  console.groupEnd();\n}\nfunction logConnectionClose(event) {\n  const target = event.target;\n  const publicUrl = (0, import_toPublicUrl.toPublicUrl)(target.url);\n  console.groupCollapsed(\n    import_devUtils.devUtils.formatMessage(\n      `${(0, import_getTimestamp.getTimestamp)({ milliseconds: true })} %c\\u25A0%c ${publicUrl}`\n    ),\n    `color:${colors.system}`,\n    \"color:inherit\"\n  );\n  console.log(event);\n  console.groupEnd();\n}\nfunction logClientError(event) {\n  const socket = event.target;\n  const publicUrl = (0, import_toPublicUrl.toPublicUrl)(socket.url);\n  console.groupCollapsed(\n    import_devUtils.devUtils.formatMessage(\n      `${(0, import_getTimestamp.getTimestamp)({ milliseconds: true })} %c\\xD7%c ${publicUrl}`\n    ),\n    `color:${colors.system}`,\n    \"color:inherit\"\n  );\n  console.log(event);\n  console.groupEnd();\n}\nasync function logOutgoingClientMessage(event) {\n  const byteLength = (0, import_getMessageLength.getMessageLength)(event.data);\n  const publicData = await (0, import_getPublicData.getPublicData)(event.data);\n  const arrow = event.defaultPrevented ? \"\\u21E1\" : \"\\u2B06\";\n  console.groupCollapsed(\n    import_devUtils.devUtils.formatMessage(\n      `${(0, import_getTimestamp.getTimestamp)({ milliseconds: true })} %c${arrow}%c ${publicData} %c${byteLength}%c`\n    ),\n    `color:${colors.outgoing}`,\n    \"color:inherit\",\n    \"color:gray;font-weight:normal\",\n    \"color:inherit;font-weight:inherit\"\n  );\n  console.log(event);\n  console.groupEnd();\n}\nasync function logOutgoingMockedClientMessage(event) {\n  const byteLength = (0, import_getMessageLength.getMessageLength)(event.data);\n  const publicData = await (0, import_getPublicData.getPublicData)(event.data);\n  console.groupCollapsed(\n    import_devUtils.devUtils.formatMessage(\n      `${(0, import_getTimestamp.getTimestamp)({ milliseconds: true })} %c\\u2B06%c ${publicData} %c${byteLength}%c`\n    ),\n    `color:${colors.mocked}`,\n    \"color:inherit\",\n    \"color:gray;font-weight:normal\",\n    \"color:inherit;font-weight:inherit\"\n  );\n  console.log(event);\n  console.groupEnd();\n}\nasync function logIncomingMockedClientMessage(event) {\n  const byteLength = (0, import_getMessageLength.getMessageLength)(event.data);\n  const publicData = await (0, import_getPublicData.getPublicData)(event.data);\n  console.groupCollapsed(\n    import_devUtils.devUtils.formatMessage(\n      `${(0, import_getTimestamp.getTimestamp)({ milliseconds: true })} %c\\u2B07%c ${publicData} %c${byteLength}%c`\n    ),\n    `color:${colors.mocked}`,\n    \"color:inherit\",\n    \"color:gray;font-weight:normal\",\n    \"color:inherit;font-weight:inherit\"\n  );\n  console.log(event);\n  console.groupEnd();\n}\nasync function logIncomingServerMessage(event) {\n  const byteLength = (0, import_getMessageLength.getMessageLength)(event.data);\n  const publicData = await (0, import_getPublicData.getPublicData)(event.data);\n  const arrow = event.defaultPrevented ? \"\\u21E3\" : \"\\u2B07\";\n  console.groupCollapsed(\n    import_devUtils.devUtils.formatMessage(\n      `${(0, import_getTimestamp.getTimestamp)({ milliseconds: true })} %c${arrow}%c ${publicData} %c${byteLength}%c`\n    ),\n    `color:${colors.incoming}`,\n    \"color:inherit\",\n    \"color:gray;font-weight:normal\",\n    \"color:inherit;font-weight:inherit\"\n  );\n  console.log(event);\n  console.groupEnd();\n}\n//# sourceMappingURL=attachWebSocketLogger.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS93cy91dGlscy9hdHRhY2hXZWJTb2NrZXRMb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHlLQUFrQztBQUNoRSwwQkFBMEIsbUJBQU8sQ0FBQywrS0FBcUM7QUFDdkUseUJBQXlCLG1CQUFPLENBQUMsNktBQW9DO0FBQ3JFLDhCQUE4QixtQkFBTyxDQUFDLGdLQUF1QjtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQywwSkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE1BQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx5Q0FBeUMsYUFBYSxVQUFVO0FBQzlHLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0NBQXdDLG9CQUFvQixHQUFHLGFBQWEsVUFBVTtBQUMvRjtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0NBQXdDLG9CQUFvQixHQUFHLFdBQVcsVUFBVTtBQUM3RjtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3Q0FBd0Msb0JBQW9CLEdBQUcsSUFBSSxNQUFNLEtBQUssWUFBWSxJQUFJLFdBQVc7QUFDbEg7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3Q0FBd0Msb0JBQW9CLEdBQUcsYUFBYSxZQUFZLElBQUksV0FBVztBQUNoSDtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3Q0FBd0Msb0JBQW9CLEdBQUcsYUFBYSxZQUFZLElBQUksV0FBVztBQUNoSDtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdDQUF3QyxvQkFBb0IsR0FBRyxJQUFJLE1BQU0sS0FBSyxZQUFZLElBQUksV0FBVztBQUNsSDtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvaHllb25qb25nL0RvY3VtZW50cy9HaXRIdWIvbXN3LXNjZW5hcmlvcy9ub2RlX21vZHVsZXMvLnBucG0vbXN3QDIuNi42X0B0eXBlcytub2RlQDIyLjEwLjFfdHlwZXNjcmlwdEA1LjkuMi9ub2RlX21vZHVsZXMvbXN3L2xpYi9jb3JlL3dzL3V0aWxzL2F0dGFjaFdlYlNvY2tldExvZ2dlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgYXR0YWNoV2ViU29ja2V0TG9nZ2VyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGF0dGFjaFdlYlNvY2tldExvZ2dlcl9leHBvcnRzLCB7XG4gIGF0dGFjaFdlYlNvY2tldExvZ2dlcjogKCkgPT4gYXR0YWNoV2ViU29ja2V0TG9nZ2VyLFxuICBsb2dDb25uZWN0aW9uT3BlbjogKCkgPT4gbG9nQ29ubmVjdGlvbk9wZW5cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoYXR0YWNoV2ViU29ja2V0TG9nZ2VyX2V4cG9ydHMpO1xudmFyIGltcG9ydF9kZXZVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9pbnRlcm5hbC9kZXZVdGlscy5qc1wiKTtcbnZhciBpbXBvcnRfZ2V0VGltZXN0YW1wID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dpbmcvZ2V0VGltZXN0YW1wLmpzXCIpO1xudmFyIGltcG9ydF90b1B1YmxpY1VybCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9yZXF1ZXN0L3RvUHVibGljVXJsLmpzXCIpO1xudmFyIGltcG9ydF9nZXRNZXNzYWdlTGVuZ3RoID0gcmVxdWlyZShcIi4vZ2V0TWVzc2FnZUxlbmd0aC5qc1wiKTtcbnZhciBpbXBvcnRfZ2V0UHVibGljRGF0YSA9IHJlcXVpcmUoXCIuL2dldFB1YmxpY0RhdGEuanNcIik7XG5jb25zdCBjb2xvcnMgPSB7XG4gIHN5c3RlbTogXCIjM2I4MmY2XCIsXG4gIG91dGdvaW5nOiBcIiMyMmM1NWVcIixcbiAgaW5jb21pbmc6IFwiI2VmNDQ0NFwiLFxuICBtb2NrZWQ6IFwiI2ZmNmEzM1wiXG59O1xuZnVuY3Rpb24gYXR0YWNoV2ViU29ja2V0TG9nZ2VyKGNvbm5lY3Rpb24pIHtcbiAgY29uc3QgeyBjbGllbnQsIHNlcnZlciB9ID0gY29ubmVjdGlvbjtcbiAgbG9nQ29ubmVjdGlvbk9wZW4oY2xpZW50KTtcbiAgY2xpZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgIGxvZ091dGdvaW5nQ2xpZW50TWVzc2FnZShldmVudCk7XG4gIH0pO1xuICBjbGllbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIChldmVudCkgPT4ge1xuICAgIGxvZ0Nvbm5lY3Rpb25DbG9zZShldmVudCk7XG4gIH0pO1xuICBjbGllbnQuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXZlbnQpID0+IHtcbiAgICBsb2dDbGllbnRFcnJvcihldmVudCk7XG4gIH0pO1xuICBjbGllbnQuc2VuZCA9IG5ldyBQcm94eShjbGllbnQuc2VuZCwge1xuICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJncykge1xuICAgICAgY29uc3QgW2RhdGFdID0gYXJncztcbiAgICAgIGNvbnN0IG1lc3NhZ2VFdmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoXCJtZXNzYWdlXCIsIHsgZGF0YSB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG1lc3NhZ2VFdmVudCwge1xuICAgICAgICBjdXJyZW50VGFyZ2V0OiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IGNsaWVudC5zb2NrZXRcbiAgICAgICAgfSxcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IGNsaWVudC5zb2NrZXRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGxvZ0luY29taW5nTW9ja2VkQ2xpZW50TWVzc2FnZShtZXNzYWdlRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3MpO1xuICAgIH1cbiAgfSk7XG4gIHNlcnZlci5hZGRFdmVudExpc3RlbmVyKFxuICAgIFwib3BlblwiLFxuICAgICgpID0+IHtcbiAgICAgIHNlcnZlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgbG9nSW5jb21pbmdTZXJ2ZXJNZXNzYWdlKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgeyBvbmNlOiB0cnVlIH1cbiAgKTtcbiAgc2VydmVyLnNlbmQgPSBuZXcgUHJveHkoc2VydmVyLnNlbmQsIHtcbiAgICBhcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgIGNvbnN0IFtkYXRhXSA9IGFyZ3M7XG4gICAgICBjb25zdCBtZXNzYWdlRXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KFwibWVzc2FnZVwiLCB7IGRhdGEgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtZXNzYWdlRXZlbnQsIHtcbiAgICAgICAgY3VycmVudFRhcmdldDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBzZXJ2ZXIuc29ja2V0XG4gICAgICAgIH0sXG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBzZXJ2ZXIuc29ja2V0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbG9nT3V0Z29pbmdNb2NrZWRDbGllbnRNZXNzYWdlKG1lc3NhZ2VFdmVudCk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3MpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBsb2dDb25uZWN0aW9uT3BlbihjbGllbnQpIHtcbiAgY29uc3QgcHVibGljVXJsID0gKDAsIGltcG9ydF90b1B1YmxpY1VybC50b1B1YmxpY1VybCkoY2xpZW50LnVybCk7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgaW1wb3J0X2RldlV0aWxzLmRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoYCR7KDAsIGltcG9ydF9nZXRUaW1lc3RhbXAuZ2V0VGltZXN0YW1wKSgpfSAlY1xcdTI1QjYlYyAke3B1YmxpY1VybH1gKSxcbiAgICBgY29sb3I6JHtjb2xvcnMuc3lzdGVtfWAsXG4gICAgXCJjb2xvcjppbmhlcml0XCJcbiAgKTtcbiAgY29uc29sZS5sb2coXCJDbGllbnQ6XCIsIGNsaWVudC5zb2NrZXQpO1xuICBjb25zb2xlLmdyb3VwRW5kKCk7XG59XG5mdW5jdGlvbiBsb2dDb25uZWN0aW9uQ2xvc2UoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBjb25zdCBwdWJsaWNVcmwgPSAoMCwgaW1wb3J0X3RvUHVibGljVXJsLnRvUHVibGljVXJsKSh0YXJnZXQudXJsKTtcbiAgY29uc29sZS5ncm91cENvbGxhcHNlZChcbiAgICBpbXBvcnRfZGV2VXRpbHMuZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgIGAkeygwLCBpbXBvcnRfZ2V0VGltZXN0YW1wLmdldFRpbWVzdGFtcCkoeyBtaWxsaXNlY29uZHM6IHRydWUgfSl9ICVjXFx1MjVBMCVjICR7cHVibGljVXJsfWBcbiAgICApLFxuICAgIGBjb2xvcjoke2NvbG9ycy5zeXN0ZW19YCxcbiAgICBcImNvbG9yOmluaGVyaXRcIlxuICApO1xuICBjb25zb2xlLmxvZyhldmVudCk7XG4gIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbn1cbmZ1bmN0aW9uIGxvZ0NsaWVudEVycm9yKGV2ZW50KSB7XG4gIGNvbnN0IHNvY2tldCA9IGV2ZW50LnRhcmdldDtcbiAgY29uc3QgcHVibGljVXJsID0gKDAsIGltcG9ydF90b1B1YmxpY1VybC50b1B1YmxpY1VybCkoc29ja2V0LnVybCk7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgaW1wb3J0X2RldlV0aWxzLmRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICBgJHsoMCwgaW1wb3J0X2dldFRpbWVzdGFtcC5nZXRUaW1lc3RhbXApKHsgbWlsbGlzZWNvbmRzOiB0cnVlIH0pfSAlY1xceEQ3JWMgJHtwdWJsaWNVcmx9YFxuICAgICksXG4gICAgYGNvbG9yOiR7Y29sb3JzLnN5c3RlbX1gLFxuICAgIFwiY29sb3I6aW5oZXJpdFwiXG4gICk7XG4gIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgY29uc29sZS5ncm91cEVuZCgpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9nT3V0Z29pbmdDbGllbnRNZXNzYWdlKGV2ZW50KSB7XG4gIGNvbnN0IGJ5dGVMZW5ndGggPSAoMCwgaW1wb3J0X2dldE1lc3NhZ2VMZW5ndGguZ2V0TWVzc2FnZUxlbmd0aCkoZXZlbnQuZGF0YSk7XG4gIGNvbnN0IHB1YmxpY0RhdGEgPSBhd2FpdCAoMCwgaW1wb3J0X2dldFB1YmxpY0RhdGEuZ2V0UHVibGljRGF0YSkoZXZlbnQuZGF0YSk7XG4gIGNvbnN0IGFycm93ID0gZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA/IFwiXFx1MjFFMVwiIDogXCJcXHUyQjA2XCI7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgaW1wb3J0X2RldlV0aWxzLmRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICBgJHsoMCwgaW1wb3J0X2dldFRpbWVzdGFtcC5nZXRUaW1lc3RhbXApKHsgbWlsbGlzZWNvbmRzOiB0cnVlIH0pfSAlYyR7YXJyb3d9JWMgJHtwdWJsaWNEYXRhfSAlYyR7Ynl0ZUxlbmd0aH0lY2BcbiAgICApLFxuICAgIGBjb2xvcjoke2NvbG9ycy5vdXRnb2luZ31gLFxuICAgIFwiY29sb3I6aW5oZXJpdFwiLFxuICAgIFwiY29sb3I6Z3JheTtmb250LXdlaWdodDpub3JtYWxcIixcbiAgICBcImNvbG9yOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdFwiXG4gICk7XG4gIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgY29uc29sZS5ncm91cEVuZCgpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9nT3V0Z29pbmdNb2NrZWRDbGllbnRNZXNzYWdlKGV2ZW50KSB7XG4gIGNvbnN0IGJ5dGVMZW5ndGggPSAoMCwgaW1wb3J0X2dldE1lc3NhZ2VMZW5ndGguZ2V0TWVzc2FnZUxlbmd0aCkoZXZlbnQuZGF0YSk7XG4gIGNvbnN0IHB1YmxpY0RhdGEgPSBhd2FpdCAoMCwgaW1wb3J0X2dldFB1YmxpY0RhdGEuZ2V0UHVibGljRGF0YSkoZXZlbnQuZGF0YSk7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgaW1wb3J0X2RldlV0aWxzLmRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICBgJHsoMCwgaW1wb3J0X2dldFRpbWVzdGFtcC5nZXRUaW1lc3RhbXApKHsgbWlsbGlzZWNvbmRzOiB0cnVlIH0pfSAlY1xcdTJCMDYlYyAke3B1YmxpY0RhdGF9ICVjJHtieXRlTGVuZ3RofSVjYFxuICAgICksXG4gICAgYGNvbG9yOiR7Y29sb3JzLm1vY2tlZH1gLFxuICAgIFwiY29sb3I6aW5oZXJpdFwiLFxuICAgIFwiY29sb3I6Z3JheTtmb250LXdlaWdodDpub3JtYWxcIixcbiAgICBcImNvbG9yOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdFwiXG4gICk7XG4gIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgY29uc29sZS5ncm91cEVuZCgpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9nSW5jb21pbmdNb2NrZWRDbGllbnRNZXNzYWdlKGV2ZW50KSB7XG4gIGNvbnN0IGJ5dGVMZW5ndGggPSAoMCwgaW1wb3J0X2dldE1lc3NhZ2VMZW5ndGguZ2V0TWVzc2FnZUxlbmd0aCkoZXZlbnQuZGF0YSk7XG4gIGNvbnN0IHB1YmxpY0RhdGEgPSBhd2FpdCAoMCwgaW1wb3J0X2dldFB1YmxpY0RhdGEuZ2V0UHVibGljRGF0YSkoZXZlbnQuZGF0YSk7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgaW1wb3J0X2RldlV0aWxzLmRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICBgJHsoMCwgaW1wb3J0X2dldFRpbWVzdGFtcC5nZXRUaW1lc3RhbXApKHsgbWlsbGlzZWNvbmRzOiB0cnVlIH0pfSAlY1xcdTJCMDclYyAke3B1YmxpY0RhdGF9ICVjJHtieXRlTGVuZ3RofSVjYFxuICAgICksXG4gICAgYGNvbG9yOiR7Y29sb3JzLm1vY2tlZH1gLFxuICAgIFwiY29sb3I6aW5oZXJpdFwiLFxuICAgIFwiY29sb3I6Z3JheTtmb250LXdlaWdodDpub3JtYWxcIixcbiAgICBcImNvbG9yOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdFwiXG4gICk7XG4gIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgY29uc29sZS5ncm91cEVuZCgpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9nSW5jb21pbmdTZXJ2ZXJNZXNzYWdlKGV2ZW50KSB7XG4gIGNvbnN0IGJ5dGVMZW5ndGggPSAoMCwgaW1wb3J0X2dldE1lc3NhZ2VMZW5ndGguZ2V0TWVzc2FnZUxlbmd0aCkoZXZlbnQuZGF0YSk7XG4gIGNvbnN0IHB1YmxpY0RhdGEgPSBhd2FpdCAoMCwgaW1wb3J0X2dldFB1YmxpY0RhdGEuZ2V0UHVibGljRGF0YSkoZXZlbnQuZGF0YSk7XG4gIGNvbnN0IGFycm93ID0gZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA/IFwiXFx1MjFFM1wiIDogXCJcXHUyQjA3XCI7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgaW1wb3J0X2RldlV0aWxzLmRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICBgJHsoMCwgaW1wb3J0X2dldFRpbWVzdGFtcC5nZXRUaW1lc3RhbXApKHsgbWlsbGlzZWNvbmRzOiB0cnVlIH0pfSAlYyR7YXJyb3d9JWMgJHtwdWJsaWNEYXRhfSAlYyR7Ynl0ZUxlbmd0aH0lY2BcbiAgICApLFxuICAgIGBjb2xvcjoke2NvbG9ycy5pbmNvbWluZ31gLFxuICAgIFwiY29sb3I6aW5oZXJpdFwiLFxuICAgIFwiY29sb3I6Z3JheTtmb250LXdlaWdodDpub3JtYWxcIixcbiAgICBcImNvbG9yOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdFwiXG4gICk7XG4gIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgY29uc29sZS5ncm91cEVuZCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0YWNoV2ViU29ja2V0TG9nZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/attachWebSocketLogger.js\n"));

/***/ }),

/***/ "../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/getMessageLength.js":
/*!*****************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/getMessageLength.js ***!
  \*****************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar getMessageLength_exports = {};\n__export(getMessageLength_exports, {\n  getMessageLength: () => getMessageLength\n});\nmodule.exports = __toCommonJS(getMessageLength_exports);\nfunction getMessageLength(data) {\n  if (data instanceof Blob) {\n    return data.size;\n  }\n  if (data instanceof ArrayBuffer) {\n    return data.byteLength;\n  }\n  return new Blob([data]).size;\n}\n//# sourceMappingURL=getMessageLength.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS93cy91dGlscy9nZXRNZXNzYWdlTGVuZ3RoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oeWVvbmpvbmcvRG9jdW1lbnRzL0dpdEh1Yi9tc3ctc2NlbmFyaW9zL25vZGVfbW9kdWxlcy8ucG5wbS9tc3dAMi42LjZfQHR5cGVzK25vZGVAMjIuMTAuMV90eXBlc2NyaXB0QDUuOS4yL25vZGVfbW9kdWxlcy9tc3cvbGliL2NvcmUvd3MvdXRpbHMvZ2V0TWVzc2FnZUxlbmd0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgZ2V0TWVzc2FnZUxlbmd0aF9leHBvcnRzID0ge307XG5fX2V4cG9ydChnZXRNZXNzYWdlTGVuZ3RoX2V4cG9ydHMsIHtcbiAgZ2V0TWVzc2FnZUxlbmd0aDogKCkgPT4gZ2V0TWVzc2FnZUxlbmd0aFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhnZXRNZXNzYWdlTGVuZ3RoX2V4cG9ydHMpO1xuZnVuY3Rpb24gZ2V0TWVzc2FnZUxlbmd0aChkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiBkYXRhLnNpemU7XG4gIH1cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBkYXRhLmJ5dGVMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9iKFtkYXRhXSkuc2l6ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldE1lc3NhZ2VMZW5ndGguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/getMessageLength.js\n"));

/***/ }),

/***/ "../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/getPublicData.js":
/*!**************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/getPublicData.js ***!
  \**************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar getPublicData_exports = {};\n__export(getPublicData_exports, {\n  getPublicData: () => getPublicData\n});\nmodule.exports = __toCommonJS(getPublicData_exports);\nvar import_truncateMessage = __webpack_require__(/*! ./truncateMessage.js */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/truncateMessage.js\");\nasync function getPublicData(data) {\n  if (data instanceof Blob) {\n    const text = await data.text();\n    return `Blob(${(0, import_truncateMessage.truncateMessage)(text)})`;\n  }\n  if (typeof data === \"object\" && \"byteLength\" in data) {\n    const text = new TextDecoder().decode(data);\n    return `ArrayBuffer(${(0, import_truncateMessage.truncateMessage)(text)})`;\n  }\n  return (0, import_truncateMessage.truncateMessage)(data);\n}\n//# sourceMappingURL=getPublicData.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS93cy91dGlscy9nZXRQdWJsaWNEYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkJBQTZCLG1CQUFPLENBQUMsOEpBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBa0Q7QUFDckU7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFrRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2h5ZW9uam9uZy9Eb2N1bWVudHMvR2l0SHViL21zdy1zY2VuYXJpb3Mvbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS93cy91dGlscy9nZXRQdWJsaWNEYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBnZXRQdWJsaWNEYXRhX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGdldFB1YmxpY0RhdGFfZXhwb3J0cywge1xuICBnZXRQdWJsaWNEYXRhOiAoKSA9PiBnZXRQdWJsaWNEYXRhXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGdldFB1YmxpY0RhdGFfZXhwb3J0cyk7XG52YXIgaW1wb3J0X3RydW5jYXRlTWVzc2FnZSA9IHJlcXVpcmUoXCIuL3RydW5jYXRlTWVzc2FnZS5qc1wiKTtcbmFzeW5jIGZ1bmN0aW9uIGdldFB1YmxpY0RhdGEoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgZGF0YS50ZXh0KCk7XG4gICAgcmV0dXJuIGBCbG9iKCR7KDAsIGltcG9ydF90cnVuY2F0ZU1lc3NhZ2UudHJ1bmNhdGVNZXNzYWdlKSh0ZXh0KX0pYDtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgXCJieXRlTGVuZ3RoXCIgaW4gZGF0YSkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSk7XG4gICAgcmV0dXJuIGBBcnJheUJ1ZmZlcigkeygwLCBpbXBvcnRfdHJ1bmNhdGVNZXNzYWdlLnRydW5jYXRlTWVzc2FnZSkodGV4dCl9KWA7XG4gIH1cbiAgcmV0dXJuICgwLCBpbXBvcnRfdHJ1bmNhdGVNZXNzYWdlLnRydW5jYXRlTWVzc2FnZSkoZGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRQdWJsaWNEYXRhLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/getPublicData.js\n"));

/***/ }),

/***/ "../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/truncateMessage.js":
/*!****************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/truncateMessage.js ***!
  \****************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar truncateMessage_exports = {};\n__export(truncateMessage_exports, {\n  truncateMessage: () => truncateMessage\n});\nmodule.exports = __toCommonJS(truncateMessage_exports);\nconst MAX_LENGTH = 24;\nfunction truncateMessage(message) {\n  if (message.length <= MAX_LENGTH) {\n    return message;\n  }\n  return `${message.slice(0, MAX_LENGTH)}\\u2026`;\n}\n//# sourceMappingURL=truncateMessage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS93cy91dGlscy90cnVuY2F0ZU1lc3NhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2h5ZW9uam9uZy9Eb2N1bWVudHMvR2l0SHViL21zdy1zY2VuYXJpb3Mvbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS93cy91dGlscy90cnVuY2F0ZU1lc3NhZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHRydW5jYXRlTWVzc2FnZV9leHBvcnRzID0ge307XG5fX2V4cG9ydCh0cnVuY2F0ZU1lc3NhZ2VfZXhwb3J0cywge1xuICB0cnVuY2F0ZU1lc3NhZ2U6ICgpID0+IHRydW5jYXRlTWVzc2FnZVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyh0cnVuY2F0ZU1lc3NhZ2VfZXhwb3J0cyk7XG5jb25zdCBNQVhfTEVOR1RIID0gMjQ7XG5mdW5jdGlvbiB0cnVuY2F0ZU1lc3NhZ2UobWVzc2FnZSkge1xuICBpZiAobWVzc2FnZS5sZW5ndGggPD0gTUFYX0xFTkdUSCkge1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIHJldHVybiBgJHttZXNzYWdlLnNsaWNlKDAsIE1BWF9MRU5HVEgpfVxcdTIwMjZgO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJ1bmNhdGVNZXNzYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/utils/truncateMessage.js\n"));

/***/ }),

/***/ "../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/webSocketInterceptor.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/webSocketInterceptor.js ***!
  \***************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar webSocketInterceptor_exports = {};\n__export(webSocketInterceptor_exports, {\n  webSocketInterceptor: () => webSocketInterceptor\n});\nmodule.exports = __toCommonJS(webSocketInterceptor_exports);\nvar import_WebSocket = __webpack_require__(/*! @mswjs/interceptors/WebSocket */ \"../../../node_modules/.pnpm/@mswjs+interceptors@0.37.1/node_modules/@mswjs/interceptors/lib/browser/interceptors/WebSocket/index.js\");\nconst webSocketInterceptor = new import_WebSocket.WebSocketInterceptor();\n//# sourceMappingURL=webSocketInterceptor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zd0AyLjYuNl9AdHlwZXMrbm9kZUAyMi4xMC4xX3R5cGVzY3JpcHRANS45LjIvbm9kZV9tb2R1bGVzL21zdy9saWIvY29yZS93cy93ZWJTb2NrZXRJbnRlcmNlcHRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDBLQUErQjtBQUM5RDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvaHllb25qb25nL0RvY3VtZW50cy9HaXRIdWIvbXN3LXNjZW5hcmlvcy9ub2RlX21vZHVsZXMvLnBucG0vbXN3QDIuNi42X0B0eXBlcytub2RlQDIyLjEwLjFfdHlwZXNjcmlwdEA1LjkuMi9ub2RlX21vZHVsZXMvbXN3L2xpYi9jb3JlL3dzL3dlYlNvY2tldEludGVyY2VwdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciB3ZWJTb2NrZXRJbnRlcmNlcHRvcl9leHBvcnRzID0ge307XG5fX2V4cG9ydCh3ZWJTb2NrZXRJbnRlcmNlcHRvcl9leHBvcnRzLCB7XG4gIHdlYlNvY2tldEludGVyY2VwdG9yOiAoKSA9PiB3ZWJTb2NrZXRJbnRlcmNlcHRvclxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyh3ZWJTb2NrZXRJbnRlcmNlcHRvcl9leHBvcnRzKTtcbnZhciBpbXBvcnRfV2ViU29ja2V0ID0gcmVxdWlyZShcIkBtc3dqcy9pbnRlcmNlcHRvcnMvV2ViU29ja2V0XCIpO1xuY29uc3Qgd2ViU29ja2V0SW50ZXJjZXB0b3IgPSBuZXcgaW1wb3J0X1dlYlNvY2tldC5XZWJTb2NrZXRJbnRlcmNlcHRvcigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViU29ja2V0SW50ZXJjZXB0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/core/ws/webSocketInterceptor.js\n"));

/***/ }),

/***/ "./mocks/browser.ts":
/*!**************************!*\
  !*** ./mocks/browser.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   worker: () => (/* binding */ worker)\n/* harmony export */ });\n/* harmony import */ var msw_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! msw/browser */ \"../../../node_modules/.pnpm/msw@2.6.6_@types+node@22.10.1_typescript@5.9.2/node_modules/msw/lib/browser/index.js\");\n/* harmony import */ var msw_browser__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(msw_browser__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _handlers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./handlers */ \"./mocks/handlers.ts\");\n/* harmony import */ var _src_worker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/src/worker */ \"../../../src/worker.ts\");\n\n\n\nconst worker = (0,msw_browser__WEBPACK_IMPORTED_MODULE_2__.setupWorker)(..._handlers__WEBPACK_IMPORTED_MODULE_0__.handlers.handlers);\n_src_worker__WEBPACK_IMPORTED_MODULE_1__.workerManager.setupWorker(worker);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tb2Nrcy9icm93c2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTBDO0FBQ0o7QUFDTztBQUV0QyxNQUFNRyxTQUFTSCx3REFBV0EsSUFBSUMsK0NBQVFBLENBQUNBLFFBQVEsRUFBRTtBQUN4REMsc0RBQWFBLENBQUNGLFdBQVcsQ0FBQ0ciLCJzb3VyY2VzIjpbIi9Vc2Vycy9oeWVvbmpvbmcvRG9jdW1lbnRzL0dpdEh1Yi9tc3ctc2NlbmFyaW9zL3Rlc3RzL2UyZS90ZXN0LWFwcC9tb2Nrcy9icm93c2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNldHVwV29ya2VyIH0gZnJvbSAnbXN3L2Jyb3dzZXInO1xuaW1wb3J0IHsgaGFuZGxlcnMgfSBmcm9tICcuL2hhbmRsZXJzJztcbmltcG9ydCB7IHdvcmtlck1hbmFnZXIgfSBmcm9tICdAL3NyYy93b3JrZXInO1xuXG5leHBvcnQgY29uc3Qgd29ya2VyID0gc2V0dXBXb3JrZXIoLi4uaGFuZGxlcnMuaGFuZGxlcnMpO1xud29ya2VyTWFuYWdlci5zZXR1cFdvcmtlcih3b3JrZXIpO1xuIl0sIm5hbWVzIjpbInNldHVwV29ya2VyIiwiaGFuZGxlcnMiLCJ3b3JrZXJNYW5hZ2VyIiwid29ya2VyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./mocks/browser.ts\n"));

/***/ })

}]);